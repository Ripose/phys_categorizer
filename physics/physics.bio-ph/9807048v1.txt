8
9
9
1
 
l
u
J
 
7
2
 
 
]
h
p
-
o
i
b
.
s
c
i
s
y
h
p
[
 
 
1
v
8
4
0
7
0
8
9
/
s
c
i
s
y
h
p
:
v
i
X
r
a

A dynamic programming algorithm for
RNA structure prediction including pseudoknots

Elena Rivas and Sean R. Eddy1

Department of Genetics,
Washington University, St. Louis, MO 63130 USA

Abstract

We describe a dynamic programming algorithm for predicting opti-
mal RNA secondary structure, including pseudoknots. The algorithm
has a worst case complexity of O(N 6) in time and O(N 4) in storage.
The description of the algorithm is complex, which led us to adopt a use-
ful graphical representation (Feynman diagrams) borrowed from quantum
ﬁeld theory. We present an implementation of the algorithm that gener-
ates the optimal minimum energy structure for a single RNA sequence,
using standard RNA folding thermodynamic parameters augmented by a
few parameters describing the thermodynamic stability of pseudoknots.
We demonstrate the properties of the algorithm by using it to predict
structures for several small pseudoknotted and non-pseudoknotted RNAs.
Although the time and memory demands of the algorithm are steep, we
believe this is the ﬁrst algorithm to be able to fold optimal (minimum
energy) pseudoknotted RNAs with the accepted RNA thermodynamic
model.

Running title RNA pseudoknot prediction by dynamic programming.

Keywords RNA, secondary structure prediction, pseudoknots, dynamic pro-

gramming, thermodynamic stability.

1To whom correspondence should be addressed. Tel: +1 314 362 7666; Fax: +1 314 362

7855; Email: eddy@genetics.wustl.edu.

1

INTRODUCTION

Many RNAs fold into structures that are important for regulatory, catalytic, or
structural roles in the cell. An RNA’s structure is dominated by base pairing in-
teractions, most of which are Watson-Crick pairs between complementary bases.
The base paired structure of an RNA is called its secondary structure. Because
Watson-Crick pairs are such a stereotyped and relatively simple interaction,
accurate RNA secondary structure prediction appears to be an achievable goal.
A rather reliable approach for RNA structure prediction is comparative se-
quence analysis, in which covarying residues (e.g. compensatory mutations)
are identiﬁed in a multiple sequence alignment of RNAs with similar structures
but diﬀerent sequences (Woese & Pace, 1993). Covarying residues, particularly
pairs which covary to maintain Watson-Crick complementarity, are indicative
of conserved base pairing interactions. The accepted secondary structures of
most structural and catalytic RNAs were generated by comparative sequence
analysis.

If one has only a single RNA sequence (or a small family of RNAs with little
sequence diversity) comparative sequence analysis cannot be applied. Here the
best current approaches are energy minimization algorithms (Schuster et al.,
1997). While not as accurate as comparative sequence analysis, these algorithms
have still proven to be useful research tools. Thermodynamic parameters are
available for predicting the ∆G of a given RNA structure (Freier et al., 1986;
Serra et al., 1995). The Zuker algorithm (implemented in the programs MFOLD
(Zuker, 1989a) and ViennaRNA (Schuster et al., 1994)) is an eﬃcient dynamic
programming algorithm for identifying the globally minimal energy structure for
a sequence, as deﬁned by such a thermodynamic model (Zuker & Stiegler, 1981;
Zuker & Sankoﬀ, 1984; Sankoﬀ, 1985). The Zuker algorithm requires O(N 3)
time and O(N 2) space for a sequence of length N , and so is reasonably eﬃcient
and practical even for large RNA sequences. The Zuker dynamic programming
algorithm was subsequently extended to allow experimental constraints, and
to sample suboptimal folds (Zuker, 1989b). McCaskill’s variant of the Zuker
algorithm calculates probabilities (conﬁdence estimates) for particular base pairs
(McCaskill, 1990).

One well-known limitation of the Zuker algorithm is that it is incapable of
predicting so-called RNA pseudoknots. This is the problem that we address in
this paper.

The thermodynamic model for non-pseudoknotted RNA secondary struc-
ture includes some stereotypical interactions, such as stacked base-paired stems,
hairpins, bulges, internal loops, and multiloops. Formally, non pseudoknotted
structures obey a “nesting” convention: that for any two base pairs i, j and k, l
(where i < j and k < l), either i < k < l < j or k < i < j < l. It is precisely
this “nesting” convention that the Zuker dynamic programming algorithm re-
lies upon to recursively calculate the minimal energy structure on progressively
longer subsequences. An RNA pseudoknot is deﬁned as a structure contain-
ing base pairs which violate the nesting convention. An example of a simple
pseudoknot is shown in Figure 1.

RNA pseudoknots are functionally important in several known RNAs (ten
Dam et al., 1992). For example, by comparative analysis, RNA pseudoknots are
conserved in ribosomal RNAs, the catalytic core of group I introns, and RNase P
RNAs. Plausible pseudoknotted structures have been proposed (Florentz et al.,

1

U C

A

A

C•G
U•G
U•A

5′— C

A A U G A C —3′

A

5′— C U U C
• • •
A G G

−→

A C U
• • •
U G A C —3′

A

A

Figure 1: A simple pseudoknot. In a pseudoknot, nucleotides inside a hairpin
loop pair with nucleotides outside the stem-loop.

1982), and recently conﬁrmed (Kolk et al., 1998) for the 3’ end of several plant
viral RNAs, where pseudoknots are apparently used to mimic tRNA structure.
In vitro RNA evolution (SELEX) experiments have yielded families of RNA
structures which appear to share a common pseudoknotted structure, such as
RNA ligands selected to bind HIV-1 reverse transcriptase (Tuerk et al., 1992).
Most methods for RNA folding which are capable of folding pseudoknots
adopt heuristic search procedures and sacriﬁce optimality. Examples of these
approaches include quasi-Monte Carlo searches (Abrahams et al., 1990) and
genetic algorithms (Gultyaev et al., 1995; van Batenburg et al., 1995). These
approaches are inherently unable to guarantee that they have found the “best”
structure given the thermodynamic model, and consequently unable to say how
far a given prediction is from optimality.

A diﬀerent approach to pseudoknot prediction based on the maximum weigh-
ted matching (MWM) algorithm (Edmonds, 1965; Gabow, 1976) was introduced
by Cary and Stormo (1995). Using the MWM algorithm, an optimal structure
is found, even in the presence of complicated knotted interactions, in O(N 3)
time and O(N 2) space. However, MWM seems best suited to folding sequences
for which a previous alignment exists. In the scoring system used by Cary and
Stormo, weights are assigned by comparative analysis. It is not clear to us that
the MWM algorithm will be amenable to folding single sequences or collections
of sequences which present little variation respect to each other. However, we
believe that this was the ﬁrst work that indicated that optimal RNA pseudoknot
predictions can be made with polynomial time algorithms. It had been widely
believed, but never proven, that pseudoknot prediction would be an NP problem
(NP = nondeterministic polynomial; e.g. only solvable by heuristic or brute
force approaches).

In this paper we describe a dynamic programming algorithm which ﬁnds
optimal pseudoknotted RNA structures. We describe the algorithm using a
diagrammatic representation borrowed from quantum ﬁeld theory (Feynman
diagrams). We implement a version of the algorithm that ﬁnds minimal energy
RNA structures using the standard RNA secondary structure thermodynamic
model (Freier et al., 1986, Serra et al., 1995), augmented by a few pseudoknot-
speciﬁc parameters that are not yet available in the standard folding parameters,
and by coaxial stacking energies (Walter et al., 1994) for both pseudoknotted
and non-pseudoknotted structures. We demonstrate the properties of the algo-

2

multiloop

int loop

ss

stem hairpin

hairpin

bulge

Figure 2: Diagrammatic representation of RNA most relevant secondary struc-
tures, including a pseudoknot.

pseudoknot

rithm by testing it on several small RNA structures, including both structures
thought to contain pseudoknots and structures thought not to contain pseudo-
knots.

2 ALGORITHM

In this section we will introduce a diagrammatic way of representing RNA fold-
ing algorithms. We will start by describing the Nussinov algorithm (Nussinov
et al., 1978), and the Zuker-Sankoﬀ algorithm (Zuker & Sankoﬀ 1984; Sankoﬀ
1985) in the context of this representation. Later on we will extend the dia-
grammatic representation to include pseudoknots and coaxial stackings. The
Nussinov and Zuker-Sankoﬀ algorithms can be implemented without the dia-
grammatic representation, but this representation is essential to manage the
complexity introduced by pseudoknots.

2.1 Preliminaries

From here on, unless otherwise stated, a ﬂat solid line will represent the back-
bone of a RNA sequence with its 5′ end placed in the left hand side of the
segment. N will represent the length (in number of nucleotides) of the RNA.

Secondary interactions will be represented by wavy lines connecting the two
interacting positions in the backbone chain, while the backbone itself always
remains ﬂat. No more than two bases are allowed to interact at once. This
representation does not provide insight about real (3D) spatial arrangements,
but is very convenient for algorithmic purposes. When necessary for clariﬁca-
tion single stranded regions will be marked by dots, but when unambiguous,

3

dots will be omitted for simplicity. Using this representation (ﬁgure 2) we can
describe hairpins, bulges, stems, internal loops and multiloops as simple nested
structures; a pseudoknot, on the other hand, corresponds to a non-nested struc-
ture.

2.2 Diagrammatic representation of nested algorithms

In order to describe a nested algorithm we need to introduce two triangular
N × N matrices, to be called vx and wx. These matrices are deﬁned in the
following way: vx(i, j) is the score of the best folding between positions i and
j provided that i and j are paired to each other; whereas wx(i, j) is the score
of the best folding between positions i and j regardless of whether i and j pair
to each other or not. These matrices are graphically represented in the form
indicated in ﬁg. 3. The ﬁlled inner space indicates that we do not know how
many interactions (if any) occur for the nucleotides inside, in contrast with
a blank inner space which indicates that the fragment inside is known to be
single stranded. The wavy line in vx, as previously, indicates that i and j are
deﬁnitely paired, and similarly the discontinuous line in wx indicates that the
relation between i and j is unknown. Also part of our convention is that for a
given fragment, nucleotide i is at the 5′-end, and nucleotide j is at the 3′-end,
so that i ≤ j.

i

wx

j

i

vx

j

Figure 3: W x and vx matrices.

The purpose of a dynamic programming algorithm is to ﬁll the vx and wx
matrices with appropriate numerical weights by means of some sort of recursive
calculation.

The recursion relations used to ﬁll the wx matrix include: single-stranded
nucleotides, external pairs, external dangling bases, and bifurcations. The ac-
tual recursion is easier to understand by looking at the diagrams involved (given
in ﬁg. 4) and the recursion can be expressed as,

4

j

j

j

=

i

i

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

j

j

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

i

i

i

i

i

i

j

j

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

i+1

j-1

k k+1

j

Figure 4: Recursion for wx in the nested algorithm

i+1,j−1 + P + vx(i + 1, j − 1)

(cid:3)

P + vx(i, j)
i+1,j−1 + Rj
Li
Li
i+1,j + P + vx(i + 1, j)
Rj
i,j−1 + P + vx(i, j − 1)

Q + wx(i + 1, j)
Q + wx(i, j − 1)

paired

dangles

single
stranded





(cid:21)

wx(i, k) + wx(k + 1, j)

[∀k,

i ≤ k ≤ j].

bifurcations

wx(i, j) = optimal






(1)
Each line gives the formal score of one of the diagrams in ﬁg. 4. The diagram
on the left is calculated as the score of the best diagram on the right. Here P is
some value that represents the score for a base pair. Q represents the score for
a single stranded nucleotide, whereas Li
i,j−1 stand for the score of
a nucleotide dangling oﬀ a base pair of nucleotides, at the 5′-end or the 3′-end
respectively.

i+1,j and Rj

(cid:3)

The recursion for vx includes hairpins, bulges, internal loops, and multiloops.
But what is special about hairpins, bulges, internal loops, and multiloops in this
diagrammatic representation? To answer this question we have to introduce two
more deﬁnitions: Surfaces (S) and Irreducible Surfaces (IS).

Roughly speaking a Surface is any alternating sequence of solid and wavy
lines that closes on itself. An Irreducible Surface is a Surface such that if one

5

of the H-bonds (or secondary interactions) is broken there is no other surface
contained inside, that is, an IS cannot be “reduced” to any other surface. (ISs
are similar to the “k-loops” deﬁned by Sankoﬀ (1985).) The order, O, of an IS
is given by the number of wavy lines (secondary interactions), which is equal to
the number of solid-line intervals. It is easy to see that hairpin loops constitute
the ISs of O(1); stems, bulges and internal loops are all the ISs of O(2), and
what are referred to in the literature as “multiloops” are the ISs of O > 2.

(cid:12)
(cid:12)
(cid:12)

i






i

j

i

k

l

j

k l m n

j

(cid:12)
(cid:12)
(cid:12)

i

=

j

i

(cid:12)
(cid:12)
(cid:12)

...

(cid:12)
(cid:12)
(cid:12)

k l m n r s

j

Figure 5: General recursion for vx in the nested algorithm.

The actual recursion for vx is given in ﬁg. 5, and can be expressed as,

vx(i, j) = optimal

IS1(i, j)
IS2(i, j : k, l) + vx(k, l)
IS3(i, j : k, l : m, n) + vx(k, l) + vx(m, n)
IS4(i, j : k, l : m, n : r, s) + vx(k, l)

(2)

+vx(m, n) + vx(r, s)

O(IS5)

[∀k, l, m, n, r, s,

i ≤ k ≤ l ≤ r ≤ s ≤ m ≤ n ≤ j]

This recursion is an expansion in ISs of successively higher order. Here ISn(i1, j1 :
i2, j2 : ... : in, jn) represent the score for an IS of order n, in which ik is paired to
jk. This general algorithm is quite impractical, because each IS of O(γ) adds a
complexity of O(N 2γ ) to the calculation. [An IS of O(N 2γ) requires us to search
through 2γ independent segments in the entire sequence of N nucleotides.] To
make it useful we have to truncate the expansion in IS’s at some order in the
recursion for vx in ﬁg. 5. The symbol O(IS5) indicates the order of IS at which
we truncate the recursion. (Note that the recursion for wx will remain always
the same.)

These recursions are equivalent to those proposed by Sankoﬀ (1985) in The-
orem 2. Notice also that in deﬁning the recursive algorithm we have not yet
had to specify anything about the particular manner in which the contribution
from diﬀerent IS’s are calculated in order to obtain the most optimal folding.

The simplest truncation is to stop at order zero. In this approximation none
of the ISs (hairpin, bulge, internal loop...) are given any specialized scores. We

6

i

= i

j

i+1

j

j-1

Figure 6: Recursion for vx truncated at O(0)

only have to provide a speciﬁc score for a base pair, B. The recursion for vx
then simpliﬁes to ﬁg. 6, and can be cast into the form,

vx(i, j) = B + wx(i + 1, j − 1).

(3)

If we set B = P = +1, and Q = 0 in equation (1) then we have the Nussinov
algorithm (Nussinov et al., 1978). This simple algorithm calculates the folding
with the maximum number of base pairs.

i

=

j

i

j

i

k

l

j

k k+1

j

(cid:12)
(cid:12)
(cid:12)

i

(cid:12)
(cid:12)
(cid:12)

Figure 7: Recursion for vx truncated at O(2).

The next order of complexity we explore corresponds to a truncation at ISs of
O(2). Hairpin loops, bulges, stems, and internal loops are treated with precision
by the scoring functions IS1 and IS2. The rest of ISs, collected under the name
of “multiloops”—which are much less frequent than the previous—are described
in an approximate form. The diagrams of this approximation are given in ﬁg. 7,
and correspond to,

vx(i, j) = optimal

IS1(i, j)
IS2(i, j : k, l) + vx(k, l)
PI + M + wxI (i + 1, k) + wxI (k + 1, j − 1)

(4)






[∀k, l

i ≤ k ≤ l ≤ j]

This is the algorithm described by Sankoﬀ (1985) in theorem 3. This is the
approximation that MFOLD (Zuker, 1981) and ViennaRNA (Schuster et al.,
1994) implement. PI stands for the scoring parameter for a pair in a multiloop,
and parameter M stands for the score for a multiloop. Note that the matrix
wxI used to truncate the recursion for vx in (4) does not have to be the same as
the one used in (1). Matrix wxI is used exclusively for diagrams which will be
incorporated into multiloops. Although both matrices wx and wxI have similar
recursions, the parameters of these two recursions will have in general diﬀerent

7

values (represent here by P , Q, L, R and PI , QI , LI , RI respectively). This
feature is implemented both in MFOLD and in our program.

Higher orders of speciﬁcity of the general algorithm are possible, but are
certainly more time consuming, and they have not been explored so far. One
reason for this relative lack of development is that there is little information
about the energetic properties of multiloops. The generalized nested algorithm
provides a way to unify the currently available dynamic algorithms for RNA
folding. At a given order, the error of the approximation is given by the diﬀer-
ence between the assigned score to “multiloops” and the precise score that one
of those higher order ISs deserves.

2.3 Description of the pseudoknot algorithm

Pseudoknots are non-nested conﬁgurations and clearly cannot be described with
just the wx and vx matrices we introduced in the previous section. The key point
of the pseudoknot algorithm is the use of gap matrices in addition to the wx
and vx matrices. Looking at the graphical representation of one of the simplest
pseudoknots, ﬁg. 8, we can see that we could describe such a conﬁguration by
putting together two gap matrices with complementary holes.

The pseudoknot dynamic programming algorithm uses one-hole or gap ma-
trices (ﬁg. 9) as a generalization of the wx and vx matrices. Let us deﬁne
whx(i, j : k, l) as the graph that describes the best folding that connects seg-
ments [i, k] with [l, j], i ≤ k ≤ l ≤ j such that the relation between i and j and
k and l is undetermined. Similarly we deﬁne vhx(i, j : k, l) as the graph that
describes the best folding that connects segments [i, k] with [l, j], i ≤ k ≤ l ≤ j
such that i and j are base-paired and k and l are also base-paired. For com-
pleteness we have to introduce also matrix yhx(i, j : k, l) in which k and l are
paired, but the relation between i and j is undetermined, and its counterpart
zhx(i, j : k, l) in which i and j are paired, but the relation between k and l is
undetermined.

matrix
(i ≤ k ≤ l ≤ j)
wx(i, j)
vx(i, j)
whx(i, j : k, l)
vhx(i, j : k, l)
zhx(i, j : k, l)
yhx(i, j : k, l)

relationship
i, j
undetermined
paired
undetermined
paired
paired
undetermined

relationship
k, l
—
—
undetermined
paired
undetermined
paired

Table 1: Speciﬁcations of the matrices used in the pseudoknot algorithm.

The non-gap matrices wx, vx are contained as a particular case of the gap

matrices. When there is no hole, k = l − 1, then by construction,

whx(i, j : k, k + 1) = wx(i, j)
zhx(i, j : k, k + 1) = vx(i, j) ∀k,

i ≤ k ≤ j.

(5)

We have the gap matrices as the building blocks of the algorithm, but how
do we establish a consistent and complete recursion relation? Here is where the

8

29

A

5′–

AUUCCG
• • • • •
AGGGC

=
AACUCGA
• • • • • •
UGAGCUA – 3′

A A A

1

A

23

29

5′–

AUUCCG
• • • • •
AGGGC

11

15

+

16

22

AACUCGA
• • • • • •
UGAGCUA – 3′

=

1

A A A

10

29

23

15

11

22

16

10

1

+

=

Figure 8: Construction of a simple pseudoknot using two gap matrices.

10

1

29

23

9

i

i

k whx

l

k

vhx

l

j

j

i

i

j

j

k

zhx

l

k

yhx

l

Figure 9: Representation of the gap matrices used in the algorithm for pseu-
doknots.

analogy between the gap matrices and the Feynman diagrams of quantum ﬁeld
theory was of great help (Bjorken & Drell 1965).2

Let us start with the generalization of the recursions for wx and vx in the
presence of gap matrices. A non-gap matrix can be obtained by combining two
gap matrices together, therefore the recursions for wx and vx add one more dia-
gram with two gap matrices to recursions (1) and (2). Again the diagrammatic
representation (ﬁg. 10, 11) is more helpful than words in explaining the recur-
sion. Note that the new term introduced in both recursions involves two gap
matrices. In fact the recursion is an expansion in the number of gap matrices
necessary at each step of the recursion.

wx(i, j) = optimal

i+1,j−1 + P + vx(i + 1, j − 1)

P + vx(i, j)
i+1,j−1 + Rj
Li
Li
i+1,j + P + vx(i + 1, j)
Rj
i,j−1 + P + vx(i, j − 1)
Q + wx(i + 1, j)
Q + wx(i, j − i)
wx(i, k) + wx(k + 1, j)
Gw + whx(i, r : k, l) + whx(k + 1, j : l − 1, r + 1)
O(whx + whx + whx)

Where Gw denotes the score for introducing a pseudoknot.

Similarly for vx,

vx(i, j) = optimal

IS1(i, j)
IS2(i, j : k, l) + vx(k, l)
PI + M + wxI (i + 1, k) + wxI (k + 1, j − 1)
M + GwI + whx(i + 1, r : k, l)
PI +

+whx(k + 1, j − 1 : l − 1, r + 1)

O(whx + whx + whx)

f

2 More precisely, the analogy is more cleanly expressed in terms of Schwinger-Dyson dia-
grams which in QFT are used to represent full interacting vertices and propagators recursively
in terms of elementary interactions.











(6)

(7)

10

i

i

i

j

j

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

j-1

i+1

i

i

j

j

j

=

i

i

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

i+1

j-1

i+1

j

j

j-1

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

i

k k+1

j

i

(cid:12)
(cid:12)
(cid:12)
Figure 10: Recursion for wx in the pseudoknot algorithm truncated at O(whx+
whx + whx).

j

[∀i, k, l, r, j

i ≤ k ≤ l ≤ r ≤ j]

M stands for a generic score for generating a non-nested multiloop, and

Here
GwI stands for the score for generating an internal pseudoknot.

f

Practical considerations make us truncate the expansion at this point, so we
will not include diagrams that require three or more gap matrices. This state-
ment should not mislead one into thinking that we cannot deal with complicated
pseudoknots. The recursive nature of the approximation allows us to describe
overlapping pseudoknots (deﬁned as those pseudoknots for which a planar rep-
resentation does not require crossing lines) as well as non-planar pseudoknots
(for which a planar representation requires crossing lines). The Escherichia
coli α mRNA presented by Gluick et al. (1994) is an example of a non-planar
RNA pseudoknot that can be parsed using the pseudoknot algorithm. However
the algorithm is not able to ﬁnd all possible knotted conﬁgurations (ﬁg. 12).
Nevertheless, the approximation seems to be adequate for the currently known
pseudoknots in RNA folding.

Note that two approximations are involved in the algorithm. Apart from that
just mentioned (how to truncate the inﬁnite expansion in gap matrices to make
the algorithm polynomial), we also use the approximation previously introduced
for the nested algorithm (that IS’s of O > 2 or multiloops are described in some
approximated form).

The algorithm is not complete until we provide the full recursive expressions
to calculate the gap matrices. For a given gap matrix, we have to consider
in how many diﬀerent ways that diagram can be assembled using one or two
matrices at a time. The full description of those diagrams is given in Subsection
5.2 . (Again Feynman diagrams are of great use here.)

11

i

=

j

i

j

i

k

l

j

i

i+1

k

j-1

j

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

i

j

Figure 11: Recursion for vx in the pseudoknot algorithm truncated at O(whx+
whx + whx).

2.4 Coaxial stacking

It is quite frequent in RNA folding to create a more stable conﬁguration when
two independent conﬁgurations stack coaxially. That occurs for instance, when
two hairpin loops with their respective stems are contiguous, so that one of them
can fall on top of the other creating a more stable conﬁguration than when the
two hairpins just coexist without interaction of any kind.

The algorithm implements coaxial energies for both nested and non-nested
structures. We adopt the coaxial energies provided by Walter et al. (1994) for
coaxial stacking of nested structures. For coaxial stacking of non-nested struc-
tures we multiply these previous energies by an estimated (ad hoc) weighting
parameter g < 1.

Using our diagrammatic representation it is possible to be systematic in
describing the possible coaxial stacking that can occur. In the general recur-
sion one has to look for contiguous nucleotides and allow them to be explicitly
paired—but not to each other. This is best understood with an example. Con-
sider the recursion for wx in ﬁg. 10, in particular the bifurcation diagram

wx(i, j) −→ wx(i, k) + wx(k + 1, j),

∀k, i ≤ k ≤ j.

In order to allow for the possibility of coaxial stacking such diagram has to be
complemented with another one in which the nucleotides of the bifurcation are
base-paired

wx(i, j) −→ vx(i, k) + vx(k + 1, j) + C(k, i : k + 1, j),

∀k, i ≤ k ≤ j.

12

6

10

5

1

6
25

20

15

=

I

IV

II/III

=

+

6

20
15
10
5
1

40

30

6
45

35

25

=

6
70
65
60
55
50

=

=

=

+

Figure 12: Top: The non-planar pseudoknot presented in α mRNA and how
to build it with gap matrices. The Roman numbers correspond to the num-
bering of stems introduced by Gluick et al. (1994). Bottom: An example of a
pseudoknot that the algorithm cannot handle: interlaced interactions as seen in
proteins in parallel β-sheet. The assembly of this interaction using gap matrices
would require us to use four gap matrices at once which is not allowed by the
approximation at hand.

13

This new diagram indicates that if nucleotides k and k + 1 are paired to nu-
cleotides i and j respectively, that conﬁguration is specially favored by an
amount C(k, i : k + 1, j) (presumably negative in energy units) because both
sub-structures, vx(i, k) and vx(k + 1, j), will stack onto each other.

Notice also that the new diagram really corresponds to four new diagrams
because once we allow pairing, dangling bases have also to be considered, so the
full nearest-neighbour interaction is taken into account. For purposes of clarity
we will not explicitly specify any of the extra diagrams with dangling involved.
The rest of the additional diagrams to be included in the recursions to take care
of coaxial stackings are also given in Subsection 5.2 along with the full set of
diagrams. Coaxial diagrams can be recognized by the empty dots representing
the contiguous coaxially-stacking nucleotides.

2.5 Minimum-energy implementation. Thermodynamic

parameters

We have implemented the pseudoknot algorithm using thermodynamic param-
eters in order to ﬁll the scoring matrices, both gapped and ungapped. For
the relevant nested structures: hairpin loops, bulges, stems, internal loops and
multiloops we have used the same set of energies as used in MFOLD.3 Free en-
ergies for coaxial stacking C where obtained from Walter et al., (1994). Table 2
provides a list of the parameters used for nested conformations.

Symbol
IS1
IS2
C
P
Q
R, L
PI
QI
RI , LI
M

Scoring parameter for
hairpin loops
bulges, stems and int loops
coaxial stacking
external pair
single stranded base
base dangling oﬀ an external pair
pair in a multiloop
not paired base inside multiloop
base dangling oﬀ a multiloop pair
nested multiloop

Value(Kcal/mol)
varies
varies
varies
0
0
dangle + Q
0.1
0.4
dangle + QI
4.6

Table 2: This table includes all the parameters for which there is thermody-
namic information provided by the Turner group. This parameters are identical
to those used in MFOLD (http://www.ibc.wustl.edu/˜zuker/rna).

For the non-nested conﬁgurations, there is not much thermodynamic infor-
mation available (Wyatt et al., 1990; Gluick et al., 1994). This is not an untyp-
ical situation; there is already very little thermodynamic information available
for regular multiloops, let alone for pseudoknots. We had to tune by hand the pa-
rameters related to pseudoknots. For some non-nested structures we multiplied
the nested parameters by an estimated weighting parameter g < 1. It would be
3Since the implementation of the pseudoknot algorithm the Turner group has produced a
new complete and more accurate list of parameters (Matthews et al., 1998) which we have
not yet implemented.

14

very useful, in order to improve the accuracy of this thermodynamic implemen-
tation of the pseudoknot algorithm, to have more accurate experimentally-based
determinations of these parameters. Table 3 provides a list of the parameters
we used for pseudoknot-related conformations.

Symbol

2

IS
C
f
P
e
Q
e
L
R,
e
M
e
e
Gw
f
GwI
Gwh

Scoring parameter for
IS2 in a gap matrix
coaxial stacking in pseudoknots
pair in a pseudoknot
not paired base in pseudoknot
base dangling oﬀ a pseudoknot pair
non-nested multiloop
generating a new pseudoknot
generating a pseudoknot in a multiloop
overlapping pseudoknots

Value(Kcal/mol)
IS2 ∗ g(0.83)
C ∗ g
0.1
0.2
dangle ∗ g +
8.43
7.0
13.0
6.0

Q

e

Table 3:
for pseudoknot conﬁgurations what we had to estimate.

In this table we introduce the new thermodynamic parameters speciﬁc

3 RESULTS

The main purpose of this paper is to present an algorithm that solves opti-
mal pseudoknotted RNA structures by dynamic programming. RNA structure
prediction of single sequences with nested algorithms already involves some ap-
proximation and inaccuracy (Zuker, 1995; Huynen et al, 1997). We expect this
inaccuracy to increase in our case since the algorithm now allows a much larger
conﬁguration space. Therefore our limited objective here is to show that on
a few small RNAs that are thought to conserve pseudoknots, our program (a
minimal-energy implementation of the pseudoknot algorithm using a thermo-
dynamic model) will actually ﬁnd the pseudoknots; and for a few small RNAs
that do not conserve pseudoknots, our program ﬁnds results similar to MFOLD,
and does not introduce spurious pseudoknots.

3.1 tRNAs

Almost all transfer RNAs (tRNA) share a common cloverleaf structure. We
have tested the algorithm on a group of 25 tRNAs selected at random from the
Sprinzl tRNA database (Steinberg et al., 1993). The program ﬁnds no spurious
pseudoknot for any of the tested sequences. All tRNAs fold into a cloverleaf
conﬁguration but one (DT5090). Of the 24 cloverleaf foldings, 15 are completely
consistent with their proposed structures (that is, each helical region has at least
3 base pairs in common with its proposed folding). The remaining 9 cloverleaf
foldings misplace one (6 sequences) or two (3 sequences) of the helical regions.
On the other hand, MFOLD’s lowest–energy prediction for the same set of tRNA
sequences includes only 19 cloverleaf foldings of which 14 are completely consis-
tent with their proposed structures. Performance for our program is therefore

15

at least comparable to MFOLD; the inaccuracies found are the result of the ap-
proximations in the thermodynamic model, not a problem with the pseudoknot
algorithm per se. The relevant result in relation to the pseudoknot algorithm is
that its implementation predicts no spurious pseudoknots for tRNAs.

One should not think of this result as a trivial one, because when knots
are allowed, the conﬁguration space available becomes much larger than the
observed class of conformations. This problem is particularly relevant for “maxi-
mum-pairing-like” algorithms, such as the MWM algorithm presented by Cary
& Stormo (1995) or a Nussinov implementation of our pseudoknot algorithm
(ﬁg 6). In both cases, the result is almost universal pairing because there is
enough freedom to be able to coordinate any position with another one in the
sequence.

Another important aspect of tRNA folding is coaxial energies. Most tRNAs
gain stability by stacking coaxially two of the hairpin loops, and the third one
with the acceptor stem. This aspect of tRNA folding is very important and in
some cases crucial to determine the right structure. There are situations like
tRNA DA0260 in which MFOLD does not assign the lowest energy to the cor-
rect structure (the MFOLD 3.0 prediction for DA0260 misses the acceptor stem,
and has a free energy of −22.0 Kcal/mol). Our algorithm, on the other hand,
implements coaxial energies; as a result the cloverleaf conﬁguration becomes the
most stable folding for tRNA DA0260 (∆G = −24.3 Kcal/mol). The implemen-
tation of coaxial energies explains why we found more cloverleaf structures for
tRNAs than MFOLD does.

3.2 HIV-1-RT-ligand RNA pseudoknots

High-aﬃnity ligands of the reverse transcriptase of human immunodeﬁciency
virus type 1 (HIV-1) isolated by a SELEX procedure by Tuerk et al. (1992) seem
to have a pseudoknot consensus secondary structure. These oligonucleotides
have between 34 and 47 bases and fold into a simple pseudoknot. Of a total of 63
SELEX-selected pseudoknotted sequences available from Tuerk et al. (1992), we
found 54 foldings that agreed exactly with the structures derived by comparative
analysis. (∆G = −10.9 Kcal/mol for sequence pattern I (3-2)). As expected,
MFOLD predicts only one of the two stems (∆G = −7.5 Kcal/mol for the same
sequence).

3.3 Viral RNAs

Some virus RNA genomes [such as turnip yellow mosaic virus (TYMV) (Guil-
ley et al, 1979)] present a tRNA-like structure at their 3′ end that includes a
pseudoknot in the aminoacyl acceptor arm very close to the 3′ end (Kolk et al,
1998; Florentz et al., 1982; Dumas et al, 1987). Our program predicts correctly
the TYMV tRNA-like structure with its pseudoknot for the last 86 bases at the
3′ end with ∆G = −30.4 Kcal/mol (the MFOLD 3.0 prediction for TYMV has
a free energy of ∆G = −28.9 Kcal/mol). The tRNA-like 3′ terminal structure
is conserved among tymoviruses and also for the tobacco mosaic virus cowpea
strain (CcTMV) another valine acceptor. Of the seven valine-acceptor tRNA-
like structures proposed to date (Van Belkum et al, 1987) we reproduce six of
them, except for kennedya yellow mosaic virus (KYMV).

16

Finally we have considered the last 189 bases of the 3′ terminal of the To-
bacco mosaic virus (TMV) (Van Belkum et al, 1985). TMV also has a tRNA-like
structure at the end, but it may have additional upstream pseudoknots, up to a
total of ﬁve, forming a long quasi-continuous helix. We folded the upstream and
downstream regions separately in a piece of 84 nucleotides (the folding requires
52 minutes and 9.8 Mb) and 105 nucleotides (the folding requires 246 minutes
and 22.5 Mb) respectively. Our program predicts the 105 nucleotides down-
stream region exactly with ∆G = −32.5 Kcal/mol. For the 84 nucleotides up-
stream region we ﬁnd four of the ﬁve helical regions with ∆G = −19.0 Kcal/mol.

4 DISCUSSION

In this paper we present an algorithm able to predict pseudoknots by dynamic
programming. This algorithm demonstrates that using certain approximations
consistent with the accepted Turner thermodynamic model, the prediction of
pseudoknotted structures is a problem of polynomial complexity (although ad-
mittedly high). Having an optimal dynamic programming algorithm will enable
extending other dynamic programming based methods that rigorously explore
the conformational space for RNA folding (McCaskill, 1990; Bonhoeﬀer et al.,
1993) to pseudoknotted structures.

Apart from the usefulness of the algorithm in predicting pseudoknots, we
also include coaxial energies (when two stems stack coaxially), a very common
feature of RNA folding. We expect MFOLD will also include coaxial energies
in the near future (Matthews et al., 1998).

Our algorithm is presented in the context of a general framework in which
a generic folding is expressed in terms of its elementary secondary interactions
(which we have identiﬁed as the irreducible surfaces). This is a further general-
ization of Sankoﬀ’s result (1985). The calculation of an optimal folding becomes
an expansion in ISs of increasingly higher order. Our formalization incorporates
all current dynamic programming RNA folding algorithms in addition to our
pseudoknot algorithm. It also establishes the limitations of each approximation
by determining at which order the expansion is truncated.

As for the thermodynamic implementation presented in this paper, one of
our major problems is the almost complete lack of thermodynamic information
about pseudoknot conﬁgurations. The thermodynamic algorithm is also sen-
sitive to the accuracy of the existing thermodynamic parameters. We expect
to improve this aspect by implementing the more complete set of parameters
provided by the Turner group (Matthews et al., 1998).

The principal drawback is the time and memory constraints imposed by
the computational complexity of the algorithm. At this early stage, we cannot
analyze sequences much larger than 130-140 bases. For now the program is
adequate for folding small RNAs. A 100 nucleotide RNA takes about 4 hours
and 22.5 MB to fold on an SGI R10K Origin200.

Due to practical limitations, at a given point in the recursion we only allow
the incorporation of two gap matrices. However, since each of those gap matrices
can in turn be assembled by other two of those matrices, it implies that the
algorithm includes in its conﬁguration space a large variety of knotted motifs.
The limitations of this truncation appeared when we considered applying this
approach to describe pairwise residue interactions in protein folding. A parallel

17

β-sheet conﬁguration provides an example of a complicated knotted folding
that cannot be handled by the pseudoknot algorithm presented in this paper.
However, all known RNA pseudoknots can be handled by the algorithm, which
makes the approximation useful enough for RNA secondary structure.

Although we implemented the algorithm for energy minimization, extending
MFOLD to pseudoknotted structures, the algorithm is not limited to energy
minimization. Our algorithm can be converted into a probabilistic model for
pseudoknot-containing RNA folding. Probabilistic models of RNA secondary
structure based on “stochastic context free grammar” (SCFG) formalisms (Eddy
et al., 1994; Sakakibara et al., 1994; Lefebvre, 1996) have been introduced both
for RNA single-sequence folding and for RNA structural alignment and struc-
tural similarity searches. The Inside and CYK dynamic programming algo-
rithms used for SCFG-based structural alignment are fundamentally similar to
the Zuker algorithm (Durbin et al., 1998), and have consequently also been
unable to deal with pseudoknots. Heuristic approaches to applying SCFG-like
structural alignment models to pseudoknots have been introduced (Brown, 1996;
Notredame et al., 1997). An SCFG-like probabilistic version of our pseudo-
knot algorithm could be designed to obtain optimal structural alignment of
pseudoknot-containing RNAs.

5 METHODS

5.1 Implementation

The algorithm was implemented on a Silicon Graphics Origin200. The algorithm
has a theoretical worst-case complexity of O(N 6) in time and O(N 4) in storage.
At its present stage, the program is empirically observed to run O(N 6.8) in
time and O(N 3.8) in memory. For instance, a tRNA of 75 nucleotides takes
24 minutes and uses 6.6 Mb of memory. The 3′ end of tobacco mosaic virus
has 105 nucleotides and takes 246 minutes and uses 22.5 Mb. The program
empirically scales above the theoretical complexity in time of the algorithm.
This eﬀect seems to have to do with the way the machine allocates memory for
larger RNAs. The software and parameter sets are available by request from E.
Rivas (elena@genetics.wustl.edu).

5.2 Complete set of diagrams for the pseudoknot algo-

rithm

In this section we provide the complete recursion relations for all the matrices
used in the pseudoknot algorithm.

The recursion for the non-gap matrix wx is given by (cf. ﬁg. 13):

18











wx(i, j) = optimal

i+1,j−1 + P + vx(i + 1, j − 1)

P + vx(i, j)
i+1,j−1 + Rj
Li
Li
i+1,j + P + vx(i + 1, j)
Rj
i,j−1 + P + vx(i, j − 1)

Q + wx(i + 1, j)
Q + wx(i, j − i)

wx(i, k) + wx(k + 1, j)
C(k, i : k + 1, j) + vx(i, k) + vx(k + 1, j)

Gw + whx(i, r : k, l) + whx(k + 1, j : l − 1, r + 1)
2 ∗ P + Gw + C(l − 1, r + 1 : l, k)

+yhx(i, r : k, l) + yhx(k + 1, j : l − 1, r + 1) 


(cid:3)





(cid:21)

(cid:21)

paired

dangles

single
stranded

nested
bifurcations

non-nested
bifurcations

(8)
Here Gw denotes a score for introducing a pseudoknot, and C(l, r : l + 1, k) is a
special score for a coaxial stacking of pairs (l, r) and (l + 1, k).

We should also remember that the algorithm uses two diﬀerent wx matrices
depending on whether the subset i...j is free-standing (wx) or appears inside a
multiloop (in which case we use wxI ). Both recursions are identical apart from
having diﬀerent coeﬃcients as described in table 2.

The recursion for the non-gap matrix vx is given by (cf. ﬁg. 14):

IS1(i, j)
IS2(i, j : k, l) + vx(k, l)

PI + M + wxI (i + 1, k) + wxI (k + 1, j − 1)
2 ∗ PI + C(i, j : i + 1, k) + M + vx(i + 1, k) + wxI (k + 1, j − 1)
2 ∗ PI + C(j − 1, k + 1 : j, i) + M + wxI (i + 1, k) + vx(k + 1, j − 1)
3 ∗ PI + C(k, i′ : k + 1, j′) + M + vx(i′, k) + vx(k + 1, j′)

vx(i, j) = optimal

PI +

M + GwI + whx(i + 1, r : k, l)
+whx(k + 1, j − 1 : l − 1, r + 1)
M + GwI + C(i, j, : i + 1, r)

2 ∗ PI +
f

+zhx(i + 1, r : k, l) + whx(k + 1, j − 1 : l − 1, r + 1)

2 ∗ PI +

M + GwI + C(j − 1, k + 1 : j, i)
f

+whx(i + 1, r : k, l) + zhx(k + 1, j − 1 : l − 1, r + 1)

3 ∗ PI +

M + GwI + C(l − 1, r + 1 : l, k)
f

+yhx(i + 1, r : k, l) + yhx(k + 1, j − 1 : l − 1, r + 1)

f

′

[∀i, i

, k, l, r, j

, j

′

i ≤ i

′ ≤ k ≤ l ≤ r ≤ j

′ ≤ j]

Parameters PI ,

M , and GwI are deﬁned in table 2.

The initialization conditions are

f

wx(i, i) = 0,
vx(i, i) = +∞.

19

(9)

(10)

IS(1)

IS(2)

nested
multiloops

non-nested
multiloops

(cid:3)

(cid:3)






















i

i

i

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

j

j-1

i+1

i

i

j

j

j

=

i

i

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

j

i+1

j-1

i+1

i

k k+1

j

i

k k+1

j

(cid:12)
(cid:12)
(cid:12)

i

j

i

(cid:12)
(cid:12)
(cid:12)

Figure 13: Recursion for the wx matrix.

20

j

j

j-1

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

j

i

=

j

i

i

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

j

i

k

l

j

i+1

k

j

j-1

i

i

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

i+1

k

j

j-1

i

i+1

k

j

j-1

i′

k

j′

j

i

i

j

(cid:12)
(cid:12)
(cid:12)

j

j

i

(cid:12)
(cid:12)
(cid:12)

j

i

(cid:12)
(cid:12)
(cid:12)

21

Figure 14: Recursion for the vx matrix.

[∀i 1 ≤ i ≤ N ]

The recursion for the vhx matrix in the pseudoknot algorithm is given by

(cf. ﬁg. 15):

vhx(i, j : k, l) = optimal

IS

(i, j : k, l)

2

2

2



IS
f
IS
f
2 ∗
f



[∀i, r, k, l, s, j
e

(i, j : r, s) + vhx(r, s : k, l)

(r, s : k, l) + vhx(i, j : r, s)
P +

M + whx(i + 1, j − 1 : k − 1, l + 1)

(11)

i ≤ r ≤ k ≤ l ≤ s ≤ j]

f

f

M correspond to the score given to a multiloop in a vhx gap matrix. It
Here
could be equal to M , the score deﬁned for multiloops in the vx matrix, but it
2
does not have to be. Similarly, the score for an irreducible surface of O(2),
,
could be the same as the one given for nested structures, IS2, but again, it does
not have to be. We found the best ﬁts by giving them values diﬀerent to the
ones used for nested foldings (cf. table 2 and table 3).

IS

f

The recursions for the gap matrices zhx and yhx in the pseudoknot algorithm

are complementary and given by (cf. ﬁg. 16 and ﬁg. 17):

zhx(i, j : k, l) = optimal

P + vhx(i, j : k, l)






e

P + vhx(i, j : k − 1, l + 1)

R +
P + vhx(i, j : k − 1, l)
e
P + vhx(i, j : k, l + 1)
e
e

L +
e
R +
e
L +
e
Q + zhx(i, j : k − 1, l)
e
Q + zhx(i, j : k, l + 1)
e
zhx(i, j : r, l) + wxI (r + 1, k)
e
2 ∗
zhx(i, j : k, s) + wxI (l, s − 1)
P + C(s − 1, l : s, k) + vhx(i, j : k, s) + vx(l, s − 1)
2 ∗
e
2

P + C(r, l : r + 1, k) + vhx(i, j : r, l) + vx(r + 1, k)

(i, j : r, s) + zhx(r, s : k, l)
IS
e
M + whx(i + 1, j − 1 : k, l)
P +
f
e

f

(12)

i






#












paired

dangles

single
stranded

nested
bifurcations

22

yhx(i, j : k, l) = optimal

P + C(r, i : r + 1, j) + vx(i, r) + vhx(r + 1, j : k, l)

e
P + C(s, i : s + 1, j)) + vhx(i, s : k, l) + vx(s + 1, j)

nested
bifurcations

P + vhx(i, j : k, l)

P + vhx(i + 1, j − 1 : k, l)

e

R +
P + vhx(i + 1, j : k, l)
e
P + vhx(i, j − 1 : k, l)
e
e

L +
e
L +
e
R +
e
Q + yhx(i + 1, j : k, l)
e
Q + yhx(i, j − 1 : k, l)
e
wxI (i, r) + yhx(r + 1, j : k, l)
e
2 ∗
yhx(i, s : k, l) + wxI (s + 1, j)
2 ∗

2

IS
yhx(i, j : r, s) +
e
M + whx(i, j : k − 1, l + 1)
P +
f

(r, s : k, l)

e

f






paired

dangles

single
stranded

i






#












[∀i, r, k, l, s, j

i ≤ r ≤ k ≤ l ≤ s ≤ j]

(13)

Finally, the recursion for the gap matrix whx appears in ﬁg. 18, and is given

by:

23

whx(i, j : k, l) = optimal

P + +vhx(i + 1, j − 1 : k − 1, l + 1)

e

P + vhx(i, j : k, l)

P + vhx(i + 1, j − 1 : k − 1, l)
P + vhx(i + 1, j : k − 1, l + 1)
e
P + vhx(i + 1, j − 1 : k, l + 1)
e
P + vhx(i, j − 1 : k − 1, l + 1)
e
R + 2 ∗
e

2 ∗
P + zhx(i, j : k, l)
P + yhx(i, j : k, l)
e
P + vhx(i + 1, j : k − 1, l)
R + 2 ∗
L +
e
P + vhx(i, j − 1 : k, l + 1)
R + 2 ∗
L +
e
e
e
L + 2 ∗
2 ∗
P + vhx(i + 1, j : k, l + 1)
e
e
e
P + vhx(i, j − 1 : k − 1, l)
R + 2 ∗
2 ∗
e
e
R + 2 ∗
L + 2 ∗
e
e
R + 2 ∗
2 ∗
L +
e
e
R + 2 ∗
2 ∗
L +
e
e
R + 2 ∗
L + 2 ∗
e
e
L + 2 ∗
2 ∗
e
e
P + zhx(i + 1, j − 1 : k, l)
R +
L +
e
P + zhx(i + 1, j : k, l)
L +
e
e
P + zhx(i, j − 1 : k, l)
R +
e
e
R +
L +
e
e
P + yhx(i, j : k − 1, l)
R +
e
e
P + yhx(i, j : k, l + 1)
L +
e
e
Q + whx(i + 1, j : k, l)
e
e
Q + whx(i, j − 1 : k, l)
e
Q + whx(i, j : k − 1, l)
e
Q + whx(i, j : k, l + 1)
e
e

e
P + yhx(i, j : k − 1, l + 1)

e

e

e






(14)
(cont.)

paired

dangles

single
stranded












































24

whx(i, j : k, l) = optimal

P + C(r, i : r + 1, j) + vx(i, r) + zhx(r + 1, j : k, l)

wxI (i, k) + wxI (l, j)
wxI (i, r) + whx(r + 1, j : k, l)
2 ∗
whx(i, j : r, l) + wxI (r + 1, k)
2 ∗
whx(i, s : k, l) + wxI (s + 1, j)
2 ∗
whx(i, j : k, s + 1) + wxI (l, s)
2 ∗
yhx(i, j : r, s) + zhx(r, s : k, l)
M + whx(i, j : r, s) + whx(r + 1, s − 1 : k, l)

e

e
P + C(r, l : r + 1, k) + yhx(i, j : r, l) + vx(r + 1, k)

e
P + C(s, i : s + 1, j) + zhx(i, s : k, l) + vx(s + 1, j)

e
P + C(s, l : s + 1, k) + yhx(i, j : k, s + 1) + vx(l, s)

Gwh + whx(i, s : r, l) + whx(r + 1, j : k, s + 1)
f
Gwh + whx(i, s′ : k, s) + whx(l, j : s − 1, s′ + 1)
2 ∗

P + Gwh + C(s′, i : s′ + 1, s − 1)

+zhx(i, s′ : k, s) + yhx(l, j : s − 1, s′ + 1)
P + Gwh + C(s − 1, s′ + 1 : s, k)
e
+yhx(i, s′ : k, s) + yhx(l, j : s − 1, s′ + 1)
Gwh + whx(r, j : r′, l) + whx(i, k : r − 1, r′ + 1)
e
P + Gwh + C(r − 1, r′ + 1 : r, j)
2 ∗

2 ∗

2 ∗

+zhx(r, j : r′, l) + yhx(i, k : r − 1, r′ + 1)
P + Gwh + C(r′, l : r′ + 1, r − 1)
e
+yhx(r, j : r′, l) + yhx(i, k : r − 1, r′ + 1)
e
i ≤ r ≤ r

′ ≤ k ≤ l ≤ s ≤ s

′ ≤ j]

(15)
















































nested
bifurcations

non-nested
bifurcations

[∀i, r, r

′

′
, k, l, s, s

, j

Here Gwh stands for the score given for ﬁnding overlapping pseudoknots,

that is pseudoknots that appear within already existing pseudoknots.

The initialization conditions are

whx(i, j : i, j) = +∞,
vhx(i, j : k, k) = +∞,
yhx(i, j : k, k) = +∞,
whx(i, j : k, k) = whx(i, j : k, k + 1) = wx(i, j),

zhx(i, j : k, k) = zhx(i, j : k, k + 1) = vx(i, j).

[∀i, k, j

1 ≤ i ≤ k ≤ j ≤ N ]

(16)

Acknowledgments

This work was supported by NIH grant HG01363 and by a gift from Eli
Lilly. The idea for the algorithm came from a discussion with Gary Stormo at
a meeting at the Aspen Center for Physics. Tim Hubbard suggested parallel
β-strands in proteins as an example of a set of pairwise interactions that the
algorithm cannot handle.

25

i

k

l

j

=

i

k

l

j

i

r

k

l

s

j

i

r

k

l

s

j

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

i

k

l

j

Figure 15: Recursion for the vhx matrix.

26

i

k

l

j

=

i

i

k

l

j

k

l

j

i

i

k

k

l

l

j

j

k

k

l

l

j

j

i

r

k

l

j

i

r

k

l

j

k

l

s

j

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

i

k

l

s

j

i

r k

l s

j

k

l

j

Figure 16: Recursion for the zhx matrix.

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

i

i

i

i

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

27

i

k

l

j

=

i

i

k

l

j

k

l

j

i

i

k

k

l

l

j

j

i

i

k

k

l

l

j

j

i

r

k

l

j

i

r

k

l

j

i

k

l s

j

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

i

k

l s

j

i

r k

l s

j

i

k

l

j

Figure 17: Recursion for the yhx matrix.

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

28

References
Abrahams, J.P., van der Berg, M., van Batenburg, E. & Pleij, C.W.A. (1990).
Prediction of RNA secondary structure, including pseudoknotting, by computer
simulation. Nucl. Acids Res. 18, 3035–44.

Ahlquist, P., Dasgupta, R. & Kaesberg, P. (1981). Near identity of 3′ RNA sec-
ondary structure in bromoviruses and cucumber mosaic virus. Cell 23, 183-9.
Bjorken, J.D. & Drell, S.D. (1965). Relativistic Quantum Fields, McGraw-Hill,

New York, NY.

Bonhoeﬀer, S., McCaskill, J.S, Stadler, P.F. & Schuster, P. (1993). Statistics of

RNA secondary structure. Eur. Biophys. J. (EHU) 22, 13–24.

Brown, M. (1996). RNA pseudoknot modeling using intersections of stochastic
context free grammars with applications to database search. Paciﬁc Symposium
on Biocomputing 1996.

Cary, R.B. & Stormo, G.D. (1995). Graph-theoretic approach to RNA modeling
using comparative data. ISBM-95, Eds.: C. Rawlings & others. AAAI Press.
75–80.

Chomsky, D. (1959). On certain formal properties of grammars. Information and

Control 2, 137–76.

Dumas, P., Moras, D., Florentz, C., Gieg´e, R., Verlaan, P., van Belkum, A. &
Pleij, C.W.A. (1987). 3-D graphics modeling of the tRNA-like 3′ end of turnip
yellow mosaic virus RNA: structural and functional implications. J. Biomol.
Sruct. Dyn. 4, 707-28.

Durbin, R., Eddy, S.R., Krogh, A. & Mitchison, G.J. (1998). Biological Sequence
Analysis: Probabilistic Models of Proteins and Nucleic Acids, Cambridge Uni-
versity Press, Cambridge UK.

Eddy, S.R. & Durbin, R. (1994). RNA sequence analysis using covariance models.

Edmonds, J. (1965). Maximum matching and polyhedron with 0, 1-vertices. J.

Nucl. Acids Res. 22, 2079–88.

Res. Nat. Bur. Stand. 69B, 125-30.

Florentz, C., Briand, J.P., Romboy, P., Hirth, L., Ebel, J.P. & Giege, R. (1982). The
tRNA-like structure of turnip yellow mosaic virus RNA: structural organization
of the last 159 nucleotides from the 3′ OH terminus. EMBO J. 1, 269-76.
Freier, S., Kierzek, R., Jaeger, J.A., Sugimoto, N., Caruthers, M.H., Neilson, T. &
Turner, D.H. (1986). Improved free-energy parameters for predictions of RNA
duplex stability. Proc. Natl. Acad. Sci. USA, 83, 9373–7.

Gabow, H.N. (1976). An eﬃcient implementation of Edmonds’ algorithm for max-

imum matching on graphs. J. Asc. Com. Mach. 23, 221-34.

Gluick, T.C. & Draper, D.E. (1994). Thermodynamics of folding a pseudoknotted

mRNA fragment. J. Mol. Biol. 241, 246-262.

Guilley, H., Jonard, G., Kukla, B. & Richards, K.E. (1979). Sequence of 1000
nucleotides at the 3′ end of tobacco mosaic virus RNA. Nucl. Acids Res. 6,
1287-308.

Gultyaev A.P., van Batenburg F.H. & Pleij C.W.A. (1995). The computer simu-
lation of RNA folding pathways using a genetic algorithm. J. Mol. Biol. 250,
37-51.

Huynen, M., Gutell, R., & Konings, D. (1997). Assessing the reliability of RNA

folding using statistical mechanics. J. Mol. Biol. 267, 1104-12.

Kolk, M.H., van der Graﬀ, M., Wijmenga, S.S., Pleij, C.W.A., Heus, H.A. &
interplay of

Hilbers, C.W. (1998). NMR structure of a classical pseudoknot:
single- and double-stranded RNA. Science 280, 434-8.

29

Lefebvre, F. (1996). A grammar-based uniﬁcation of several alignments and folding

algorithms. ISBM-96, Eds.: C. Rawlings & others. AAAI Press. 143–54.

Matthews, D.H., Andre, T.C., Kim, J., Turner, D.H. & Zuker, M. (1998). An
updated recursive algorithm for RNA secondary structure prediction with im-
proved free energy parameters. Molecular Modeling of Nucleic Acids. Eds.:
N. B. Leontis & J. SantaLucia Jr. American Chemical Society.

McCaskill J.S (1990). The equilibrium partition function and base pair bindings
probabilities for RNA secondary structure. Biopolymers (A5Z) 29, 1105–19.
Notredame, C., O’Brien, E.A., & Higgins, D.G. (1997). RAGA: RNA sequence

alignment by genetic algorithm. Nucl. Acids Res. 25, 4570–80.

Nussinov, R., Pieczenik, G., Griggs, J.R., & Kleitman, D.J. (1978). Algorithms for

loop matchings. SIAM J. Appl. Math. 35, 68–82.

Sakakibara, Y., Brown, M., Hughey, R., Mian, I.S., Sj¨olander, K., Underwood, R.C.
& Hussler, D. (1994). Stochastic context-free grammars for tRNA modeling.
Nucl. Acids Res. 22, 5112–20.

Sankoﬀ, D. (1985). Simultaneous solution of the RNA folding alignment and pro-

tosequence problems. SIAM J. Appl. Math. 45, 810–25.

Schuster, P., Fontana, W., Stadler, P.F. & Hofacker, I.L. (1994). From sequences
to shapes and back: a case study in RNA secondary structure. Proc. R. Soc.
Lond. B. Biol. Sci. 255, 279–84. http://www.itc.univie.ac.at∼ivo/RNA

Schuster, P., Fontana, W., Stadler, P.F. & Renner, A. (1997). RNA structures and
folding: from conventional to new issues in structure predictions. Curr. Opin.
Struct. Biol. 7, 229–35.

Serra, M.J. & Turner, D.H. (1995). Predicting the thermodynamic properties of

RNA. Meth. Enzymol. 259, 242–61.

Steinberg, S., Misch, A. & Sprinzl, M. (1993). Compilation of RNA sequences and

sequences of tRNA genes. Nucl. Acids Res. 21, 3011–15.

ten Dam E., Pleij, K. & Draper, D. (1992). Structural and functional aspects of

RNA pseudoknots. Biochemistry 31, 11665-11676.

Tuerk, C., MacDougal, S. & Gold, L. (1992). RNA pseudoknots that inhibit human
immunodeﬁciency virus type 1 reverse transcriptase. Proc. Natl. Acad. Sci.
USA, 89, 6988–92.

van Batenburg, F.H.D., Gultyaev, A.P. & Pleij, C.W.A. (1995). An APL-programmed
genetic algorithm for the prediction of RNA secondary structure. J. Theor.
Biol. 174, 269–80.

Van Belkum, A., Abrahams, J.P., Pleij, C.W.A. & Bosch, L. (1985). Five pseudo-
knots are present at the 204 nucleotides long 3′ non coding region of tobacco
mosaic virus RNA. Nucl. Acids Res. 13, 7673–86.

Van Belkum, A., Bingkun, J., Pleij, C.W.A. & Bosch, L. (1987). Structural sim-
ilarities among valine-accepting tRNA-like structures in tymoviral RNAs and
elongator tRNAs. Biochemistry 26, 1144-51.

Walter, A., Turner, D., Kim, J., Lyttle, M., M¨uller, P., Matthews, D. & Zuker, M.
(1994). Coaxial stacking of helixes enhances binding of oligoribonucleotides
and improves predictions of RNA folding. Proc. Natl. Acad. Sci. USA, 91,
9218–22.

Woese C.R. & Pace N.R. (1993). Probing RNA structure, function, and history by
comparative analysis. The RNA World. Eds.: R. F. Gesteland & J. F. Atkins.
Cold Spring Harbor Laboratory Press. New York NY. 91-117.

Wyatt, J.R., Puglisi, J.D. & Tinoco, I.Jr. (1990). RNA pseudoknots: stability and

loop size requirements. J. Mol. Biol. 214, 455-70.

30

Zuker, M. & Stiegler, P. (1981). Optimal computer folding of large RNA sequences
using thermodynamics and auxiliary information. Nucl. Acids Res. 9, 133–48.
Zuker, M. & Sankoﬀ, D. (1984). RNA secondary structure and their prediction.

Bull. Math. Biol. 46, 591–621.

Zuker, M. (1989). Computer prediction of RNA structure. Meth. Enzymol. 180,

262-88.

244, 48–52.

Zuker, M. (1989). On ﬁnding all suboptimal foldings of an RNA molecule. Science

Zuker, M. (1995). “Well-determined” regions in RNA secondary structure predic-
tion: analysis of small subunit ribosomal RNA. Nucl. Acids Res. 23, 2791–8.

31

i

k

l

j

=

k

l

j

i

k

l

j

k

l

j

i

i

i

i

i

i

k

k

k

k

k

l

l

l

l

l

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

j

j

j

j

j

i

i

i

i

i

i

i

i

i

i

i

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

j

j

j

j

j

k

k

k

k

k

l

l

l

l

l

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

j

j

j

j

j

k

k

k

k

k

l

l

l

l

l

32

i

i

i

i

k

k

l

l

j

j

i

i

k

l

i

k

l

k

l

i

r

k

i

r

k

l

j

i

r

k

l

j

i

r

k

k

l s

j

i

k

l s

j

i

k l s

j

k l s

j

i

r k

l s

j

i

r k

l

s

j

j

j

j

l

l

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

j

j

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

33

i

i

i

k l

k

l

j

k

l

j

i

i

j

j

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

i

i

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

k

l

k l

j

k l

j

k l

j

Figure 18: Recursion for the whx matrix.

34

