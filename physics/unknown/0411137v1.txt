Electrodynamics on the Möbius Strip

Technische Universität Wien

DIPLOMARBEIT

Ausgeführt am Institut für

Theoretische Physik

der Technischen Universität Wien

unter der Anleitung von

Ao. Univ. Prof. Dr. Karl Svozil

durch

Gernot Pauschenwein

Ing. J. Raab–Gasse 10, 7203 WIESEN

25. 08. 2004

Gernot Pauschenwein e.h.

II

Preface

III

The idea of taking a closer look at the Möbius strip in electrodynamics originated
from my colleague and diploma–guide Karl Svozil, who I have already worked
together over years, giving lectures about methods of theoretical physics.

I thank him for letting me spread the diploma work in whatever way my ideas led
me and on the other hand leading me to a meaningful end. This is what emerged
from our collaboration.

IV

Contents

1

Introduction

2 The Möbius Strip

3 Static charged Areas

1

3

5

5

7

7

8

15

. 16

. 17

21

. 21

. 24

. 24

. 33

41

43

.

.

.

.

.

.

.

.

.

.

3.1 Total Charge . .

.

.

. .

3.2 Electrostatic Potential .

.

.

.

.

. .

. .

.

.

. .

. .

3.2.1

Potential on the z–Axis .

. .

3.2.2

Potential in 3D .

.

. .

.

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

4 Metallic Surfaces

4.1 Finding the Equilibrium .

4.2 Numerical Approach .

.

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

5 Radiation

5.1 Fundamentals .

.

.

. .

.

5.2 Application to Rotation .

. .

. .

. .

. .

. .

. .

. .

. .

5.2.1 Rotation of an Ensemble of Point Charges .

5.2.2 Rotation of a given Area . .

.

.

. .

.

. .

.

. .

. .

. .

. .

. .

. .

. .

. .

6 Conclusion

A Programming Mathematica Functions in C

.

.

.

.

.

.

.

.

V

VI

CONTENTS

B Mathematica Packages

B.1 AreaPotential.m .

.

. .

B.2 AreaConductor.m .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

C.1 potential.tm . .

C.2 conductor.tm .

.

.

.

.

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

C .tm Files

D C Programs

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

47

. 47

. 56

63

. 63

. 63

65

. 65

. 68

.

.

.

.

.

.

D.1 potential.template .

. .

D.2 conductor.template . .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

Chapter 1

Introduction

In this diploma work electrostatics and electrodynamics on two–dimensional struc-
tures is performed.

As a consequence of the original idea, which was to ﬁnd out whether a Möbius
strip could be used to build some new motor or other device, the Möbius strip will
be taken as an example–structure throughout this paper. It is used to show the way
the programmed Mathematica–packages work. Therefore the Möbius strip and
its parametrisation are introduced in the second chapter.

In the third chapter, how to calculate the total charge of a two–dimensional charged
structure and all about the Mathematica–package AreaPotential.m is ex-
plained. With help of this, the electrostatic (and even any other kind of) potential
of arbitrary charged surfaces can be calculated and visualized.

If a conductor is present one cannot choose how a given charge spreads over the
surface of the conductor. To calculate the partition of a given charge AreaCon-
ductor.m devides the total charge into an arbitrary number of point–charges and
searches an equilibrium of their positions while being restricted to the conductor–
surface. This numerical process is exported from Mathematica to C. All this is
done in detail in chapter four.

For applications the radiation of a rotating structure is of interest. This is discussed
in the ﬁfth chapter up to electric quadrupole–radiation.

All the mentioned ﬁles (the Mathematica–packages AreaPotential.m and
AreaConductor.m, the C–ﬁles potential.template and conductor.
template and the corresponding .tm–ﬁles) are given in the appendix or can be
downloaded at http://k3.itp.tuwien.ac.at/~gernot.

The Mathematica commands used throughout this work can also be found in

1

2

CHAPTER1. INTRODUCTION

the notebooks session1.nb (potential of given charge distributions, chapter
3), session2.nb (distribution of charges on a conductor and the resulting po-
tential, chapter 4), session3.nb and session4.nb (radiation of both types
under rotation, chapter 5).

Chapter 2

The Möbius Strip

In this paper the well known parametrisation of the Möbius strip in 3 dimensions
(only basic analysis will be necessary, any lecture notes about analysis for physi-
cians will do, e.g. [6]) is used:

m(j, t) =

sin(j) + t (cid:215) cos

(cid:215) sin(j)

,

(2.1)

(cid:230)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)

Ł

cos(j) + t (cid:215) cos

(cid:215) cos(j)

j
2
j
2

I
j
2
I

M

M

t (cid:215) sin

(cid:246)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)

ł

M =

xe R3

I
x = m(j, t), 0 £ j < 2p, -l £ t £ l

M

.

(2.2)

For the following calculations one will need the normal vector on every point of
the Möbius strip in this parametrisation:

=

9

˜˜˜˜

n = mj · mt =
j
- 1
2 (cid:215) sin
2
1
4 (cid:215) t (cid:215) cos
I
M

=

(cid:215)

=

1
4 (cid:215)

I
j
1
2 (cid:215) sin
2
t + 2 cos
I

I

Ł

(cid:230)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)
(cid:230)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)

Ł

4 (cid:215) cos
j
2
I

j
2
+ cos(j) + 3
I
M
1
2 (cid:215) t (cid:215) cos
j
-t cos
2
I

j
2

M
(cid:215)
j
2
I
- cos
M

M

I

j
2

+ t (cid:215) (2 + 3 cos(j)

4 (cid:215) t (cid:215) cos

3j
2

(cid:246)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)

(cid:230)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)

·

M

cos

cos

cos(j)

sin(j)
j
2

(cid:246)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)

ł

j
2
j
2
I
M
sin
M
I

=

ł
I
+ 2 cos(j) + t (cid:215) cos
M
+ 2t (cid:215) cos(j) - 2 cos
M

Ł
3j
2
- t (cid:215) cos(2j)

3j
2

MM

I

M

I

(cid:215)

1 + t (cid:215) cos

M

I

(cid:246)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)

ł

M

(2.3)

and its length for the inﬁnitesimal area-element dA.

I

M

I

j
2
I

M

I

MM

3

4

CHAPTER2. THEMÖBIUSSTRIP

Figure 2.1: Möbius strip for l = 1/ 2.

Chapter 3

Static charged Areas

The point of interest is not only how to calculate and visualise the electrostatic
potential of the desired charged areas, but also to compare their potential with that
of well known structures. Therefore it is important to know the total charge of a
given area–charge–density.

3.1 Total Charge

The general formula for the total charge of an area is simply the integral of the
scalar area–charge–density s over the area A (see [1, 5]):

Qtot =

s dA .

A

(3.1)

Now one takes the Möbius strip as an example. To calculate the integral we take
(cid:224)
the parametrisation of the previous chapter for the area of the Möbius strip:

Q(l) =

s dO =

s|n| dt dj =

strip

0

-l

2p

l

=

1
(cid:224)
2

2p

l

0

-l

s

(cid:224)

(cid:224)
4 + 3t 2 + 8t (cid:215) cos
2

j
2

J

N

+ 2t 2 (cid:215) cos(j) dt dj .

(3.2)

(cid:224)

(cid:224)

Unfortunately, even if the charge is equally distributed over the area (s = const.),
only the t–integration is (trusting Mathematica) analytically possible and results
in a rather nasty thing:

5

6

CHAPTER3. STATICCHARGEDAREAS

In[1]:= Integrate

1 + t Cos

t2, {f, 0, 2 p}, {t, -l, l}

f
2

2

+

1
4

A

EN

Out[1]=

2 p

0

(cid:224)

A

2
1
J
4 (3 + 2 Cos[f])3/2
(cid:230)(cid:231)(cid:231)(cid:231)(cid:231)

3 l

Ł

2

(3 + 2 Cos[f])

4 + 3 l2 - 8 l Cos

+ 2 l2 Cos[f]

+

3 l

(3 + 2 Cos[f])

4 + 3 l2 + 8 l Cos

+ 2 l2 Cos[f]

+

f
2

A

E

f
2

A

E

E

N

N

f
2

J

J

2

f
2

(cid:230)(cid:231)(cid:231)(cid:231)(cid:231)

Ł

2

4 Cos

-

(3 + 2 Cos[f])

4 + 3 l2 - 8 l Cos

+ 2 l2 Cos[f]

+

E
(3 + 2 Cos[f])

J
4 + 3 l2 + 8 l Cos

A

E
+ 2 l2 Cos[f]

N

2 l Cos[f]

(3 + 2 Cos[f])

4 + 3 l2 - 8 l Cos

J

A

E

N
+ 2 l2 Cos[f]

+

(3 + 2 Cos[f])

4 + 3 l2 + 8 l Cos

+ 2 l2 Cos[f]

J

f
2

f
2

f
2

A

E

+

(cid:246)(cid:247)(cid:247)(cid:247)(cid:247)

ł

(cid:246)(cid:247)(cid:247)(cid:247)(cid:247)

-

ł
2 Cos[ f
N
2 ]
3 + 2 Cos[f]

8 Log[2] - 4 Log

1 -

2 Cos[ f
J
3 + 2 Cos[f]

2 ]

E
A
- 4 Log

1 +

4 Log

A

1
3 + 2 Cos[f]

0
3 l - 4 Cos

0
A
+ 2 l Cos[f]+

(3 + 2 Cos[f])

A

E
4 + 3 l2 - 8 l Cos

+ 2 l2 Cos[f]

+

4 Log

1
3 + 2 Cos[f]

J
3 l + 4 Cos

A
+ 2 l Cos[f]+

E

(3 + 2 Cos[f])

A

E
4 + 3 l2 + 8 l Cos

+ 2 l2 Cos[f]

(cid:226)f .

E

f
2

f
2

f
2

f
2

A

2

2

(cid:230)(cid:231)(cid:231)(cid:231)(cid:231)
Ł2

A

0

2

A

0

2

N

+

E

(cid:246)(cid:247)(cid:247)(cid:247)(cid:247)

ł

N

E

(cid:246)(cid:247)(cid:247)(cid:247)(cid:247)

ł

(cid:246)(cid:247)(cid:247)(cid:247)(cid:247)

ł

N

E

(cid:230)(cid:231)(cid:231)(cid:231)(cid:231)

Ł

(cid:230)(cid:231)(cid:231)(cid:231)(cid:231)

Ł

j
2

J

N

A numerical integration on the other hand is no problem. Taking the total width
of the Möbius strip to be 1 (l = 0, 5) one gets

A

E

J

Q(0, 5) =

s
2

2p

0,5

0

-0,5 2

(cid:224)

(cid:224)

4 + 3t 2 + 8t (cid:215) cos

+ 2t 2 (cid:215) cos(j) dt dj = 6, 35327 (cid:215) s

(3.3)

which is, due to distortions because of the parametrisation, more than 6, 28319 (cid:215) s,

3.2. ELECTROSTATICPOTENTIAL

7

the charge of a ﬂat strip of area 2p · 1.

3.2 Electrostatic Potential

The potential F(r) can be calculatet by using the Green’s–function

G(r, r¢) = -

1
4p

1
|r - r¢|

(3.4)

for the Laplace–equation (cid:243)F = -4pr (see again [1, 5]). Applied to an area–charge
and especially to the one of the Möbius strip one gets

s
|r - r¢|

dA¢ =

F(x, y, z) =

=

2p

l

0

-l

(cid:215)

(cid:224)

(cid:224)

strip

(cid:224)
s(t, j)

2

j
2

1

J

N

2

4 + 3t 2 + 8t (cid:215) cos

+ 2t 2 (cid:215) cos(j) (cid:215)

x - cos(j) - t (cid:215) cos

cos(j)

+

y - sin(j) - t (cid:215) cos

sin(j)

+

z - t (cid:215) sin

j
2

2

j
2

1

I

If s is constant it can be pulled out of the integral, but the remaining integration
is still quite challenging. Therefore one ﬁrst takes a look at the

I

M

M

I

I

M

M

I

(3.5)

dt dj .

2

j
2

I

MM

3.2.1 Potential on the z–Axis

F(z) = F(0, 0, z) =

s
|zez - r¢|

strip

dO¢ =

4 + 3t 2 + 8t (cid:215) cos

+ 2t 2 (cid:215) cos(j)

j
2

0

-l

cos(j) + t (cid:215) cos

1

j
2

cos(j)

2

+

sin(j) + t (cid:215) cos
I

M

j
2

2

sin(j)

+

z - t (cid:215) sin

2

j
2

2p

l

(cid:224)

= s

(cid:224)

(cid:224)

1

I

A numerical calcuation and comparison with the potential of a spherically sym-
metric charge (total charge equal) sitting in the origin, looks as shown in ﬁgure
(3.1).

I

M

M

I

I

M

M

I

I

MM

(3.6)

dt dj

8

CHAPTER3. STATICCHARGEDAREAS

8

6

4

2

-4

-2

2

4

Figure 3.1: Potential on the z–axis of the Möbius strip (continuous line) and a
spherically symmetric charge with the same total charge (dashed line)

3.2.2 Potential in 3D

To visualize the electrostatic Potential of a two–dimensional structure the Math-
ematica–package AreaPotential.m was programmed. The Mathematica
commands of the following explanation can be found in the ﬁle session1.nb.

As usual the package is loaded typing

In[2]:= << AreaPotential.m .

To get a short description of what is included in this package, one just has to type

In[3]:= ?AreaPotential

contains :
SetArea
SetDistribution
SetPotentialLaw
GridV alues
Potential
V iew Potential
AnimatePotential

and you get a list of the functions provided by AreaPotential.m. For details

3.2. ELECTROSTATICPOTENTIAL

9

of any of the functions listed above, again one enters a question mark and the
name of the function.

Using the function SetArea one can deﬁne the area of interest for the package,
its parametrisation. For convenience in programming the two parameters
i.e.
describing the surface are ﬁxed to be a and b. Their range has also to be speciﬁed
in the function SetArea. This rectangular area in parameter–space has to be split
into small sub–rectangles doing the numerical calculation. The number of pieces
per length can also be set by the user, it’s the last argument of this function (its
square is the total number of sub–rectangles). The default–value of this optional
argument is 30.

A possible command to set the Möbius strip is therefore

In[4]:= SetArea[

{Cos[b] + a Cos[b/2] Cos[b], Sin[b] + a Cos[b/2] Sin[b], a Sin[b/2]},
{a, -0.5, 0.5}, {b, 0., 2. p}, 40] .

SetDistribution provides the possibility to set the area–charge–density, in
dependence of the two area–parameters a and b. If one chooses a constant density
it would be useful to set it in such a way, that the total charge is equal to 1. In the
case of the Möbius strip this would be

In[5]:= SetDistribution

1
6.35327

A

(see eq. 3.3). For generality the package allows the user to specify the potential
E
law, e.g. 1/ r for electrostatics (which is default) or - g0
r e-mr for strong interaction.
Doing this by using SetPotentialLaw, it is important to construct a formu-
lation in cartesian coordinates with variables x, y and z. To clearify this the input
for the 1/ r–law is given, although it’s not necessary to enter it, for it’s the default
law:

In[6]:= SetPotentialLaw

1.
x2 + y2 + z2

.

A

0

Now nearly everything necessary is speciﬁed, the only remaining information for
a numeric calculation is, in which point one wants to know the potential. If the
aim is to visualize the potential graphically, one has to know the potential on a
more or less dense grid of points. For this purpose the function GridValues
can be used.

E

To specify the points on which the potential should be calculated, GridValues
expects ranges for x, y and z and the number of intervals into which each of the
ranges will be split to construct a grid of points. The last necessary argument is the
maximum amount of the potential which is needed because of numerical reasons
(see appendix B.1).

10

CHAPTER3. STATICCHARGEDAREAS

In[7]:= Grid = GridValues[{-1.8, 1.8}, {-1.8, 1.8}, {-1.8, 1.8}, 29, 1.2];

The back–value is a list of lists of lists of potential values. With this one can get
the potential on the point

x
y
z

(cid:230)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)

Ł

(cid:246)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)

ł

=

(cid:230)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)(cid:231)

Ł

-1, 8 + (i - 1) (cid:215) 0, 0965517
-1, 8 + ( j - 1) (cid:215) 0, 0965517
-1, 8 + (k - 1) (cid:215) 0, 0965517

(cid:246)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)(cid:247)

ł

(see the arguments of GridValues) typing

In[8]:= Grid[[i, j, k]] .

Instead of working with this grid directly the package AreaPotential.m pro-
vides some more convenient functions.

For getting the potential on a point (x, y, z)T use the function Potential, just
give the coordinate–vector as argument. The function will only return a value, if
the point lies within the ashlar speciﬁed when calling GridValues. The advan-
tage of this function compared to the list of grid–values is, that it automatically
interpolates for points other than grid points (see appendix B.1).

For the visualisation of the potential the function ViewPotential can be used.
The speciﬁed ashlar was devided into small intervals which means that the ash-
lar is also sliced into planes. For these planes the potential can be showed in a
3D–graphic. ViewPotential does so, expecting the index of the plane as an
argument. It has also the option plane which can be set to one of the values
xy, xz or yz to specify to which coordinate–axes the plane of interest shall be
parallel.

The great advantage of this package–function is the additional graphic which ap-
pears to the right. It shows the charged area and the plane for which the potential is
shown in the main picture. For the Möbius strip see the outputs of the commands

In[9]:= ViewPotential[14, Grid, plane ﬁ xy] ,

In[10]:= ViewPotential[15, Grid, plane ﬁ xz]

and

In[11]:= ViewPotential[15, Grid, plane ﬁ yz]

shown in ﬁg. 3.2 to 3.4.

Of course the graphical description of the potential can, if one isn’t interested in
the corresponding position of the “viewing plane”, be easily produced by

In[12]:= Plot3D[Potential[{x, y, 0.}], {x, -1.8, 1.8}, {y, -1.8, 1.8}] ,

3.2. ELECTROSTATICPOTENTIAL

11

Figure 3.2: xy–graphic

its output can be seen in ﬁg. 3.5.

There is another function provided by AreaPotential.m which visualises the
potential by animating a sequence of potential surfaces and their corresponding
“viewing planes”. Naturally this cannot be shown in a printed form and its de-
scription is therefore left out, see the notebook session1.nb for its usage.

12

CHAPTER3. STATICCHARGEDAREAS

Figure 3.3: xz–graphic

Figure 3.4: yz–graphic

3.2. ELECTROSTATICPOTENTIAL

13

Figure 3.5: Potential of the Möbius strip

14

CHAPTER3. STATICCHARGEDAREAS

Chapter 4

Metallic Surfaces

If metallic surfaces are present, a charge put on this surface will distribute itself in
a way that the total ﬁeld–energy becomes a minimum. Equivalently one can say,
the net–force on a single electron cannot have a component lying in the surface
(i.e. its tangent plane) if the equilibrium is reached, which again is equivalent to
“all positions are kept”. This is also guaranteed by demanding the electric ﬁeld
(force per unit charge) always to be orthogonal to the surface (see [5, 2]).

It is the aim of this chapter to explain how the Mathematica–package AreaCon-
ductor.m can be used to ﬁnd and display this conﬁguration for a given surface
and total charge.

Again the package can be loaded into the kernel by entering

In[1]:= << AreaConductor.m

and a list of the contained functions is accesible as usual through

In[2]:= ?AreaConductor

contains :
SetArea
SetPotentialLaw
ChargePositions
Potential
SetCharges .

The ﬁrst two commands are equivalent to those of AreaPotential.m (see
3.2.2 and B.1), the only difference in SetPotentialLaw being that now the
variable has to be r instead of the triple (x,y,z). ChargePositions is the
main command of this package, it does the charge–distribution–calculation nu-
merically. To achieve this as fast as possible the numerical calculations are again

15

16

CHAPTER4. METALLICSURFACES

exported from Mathematica to a plain C–program (see appendices B.2, C.2 and
D.2). The main idea of how to calculate the equilibrium shall be given here, al-
though it was implemented in the C–code and is not necessary for understandig
the usage of AreaConductor.m.

4.1 Finding the Equilibrium

It is of course possible to simulate the movement of a number of point charges
on a conducting surface by calculating the force and through this the acceleration
of each particle at any time step. One can then give the starting positions and
velocities and see how the system evolves.

The problem by doing so is, the particles will only stay in the equilibrium conﬁg-
uration if their momentary velocity is 0, otherwise they move on and start a kind
of oscillation. Even if one implements some damping or friction it will take a lot
of calculation–time–steps to reach the desired equilibrium.

Therefore a simulation of the “real” movement of the point charges is not the
proper way if one is only interested in the static equilibrium conﬁguration. A
quite simple possibility to achieve the goal is to stop the particles after each time–
step.

It goes like this:

1. From one conﬁguration (3D–positions of the particles) calculate the force

on each of the particles.

2. Move each particle as if it were under inﬂuence of a constant force (the
previously calculated), which means a distance proportional to the absolute
value of the force ( 1
2t 2/ m is the proportionality factor which can numerically
be set to some convenient value) into the direction of the momentary force–
vector.

For this movement, make sure the particle doesn’t leave the surface doing
two things:

(a) Take only the force–component lying in the tangent plane of the sur-
face and perform the shift of positions in parameter space, which means
the particle is moved along the surface the determined distance.

(b) If the particle moves outside the rectangular parameter range move it
backwards to the edge it passed. (The method doesn’t consider edges
glued together, which is no problem because the particles can still

4.2. NUMERICALAPPROACH

17

reach any place on the surface, it only probably takes a little longer
to get there.)

3. Knowing the new parameter–values use the parametrisation to get the cor-

responding 3D–positions.

4. Start from beginning.

This procedure was programmed in C, the code can be seen in appendix D.2.

4.2 Numerical Approach

As promised the Möbius strip will be used for demonstration. The function
ChargePositions can be used in two ways, distinguished by the given ar-
guments. Two arguments are always mandatory, either one has to specify the
number of point particles and the number of steps (see explanation above), or the
arguments have to be a list of (guessed) positions in parameter–space and again
the number of steps.

In either usages one can add the optional argument of a numerical (real) factor,
which is a measure for the factor used to calculate the distance a particle is moved
in one step (see above).

It is a good idea to use the possibility of choosing the force–distance–factor, one
can then move the particles relatively “fast” from the initial positions (which are
usually far away from equilibrium) and then gradually “slow down” the movement
to prevent “jumping around” the equilibrium.

Using Mathematica’s clearity one can make a list of the number of steps and the
corresponding movement–factors

In[3]:= parameters = {{3, 1.}, {10, 1.}, {10, 0.9}, {10, 0.8}, {10, 0.7},

{10, 0.5}, {10, 0.1}, {10, 0.05}, {10, 0.03}, {10, 0.02}, {10, 0.01}} .

The ﬁrst element with the 3 steps is only for a better visualisation of the movement
and not useful if one is only interested in the ﬁnal result.

The return–value of ChargePositions is a list of (ﬁrst) the particle–positions
in 3D–space (cartesian coordinates) and (second) the particle–positions in 2D–
parameter–space. For a recursive application of ChargePositions one has to
deﬁne the following function:

In[4]:= f[L_, {n_, q_}] := ChargePositions[L[[2]], n, q] .

18

CHAPTER4. METALLICSURFACES

Now one can use FoldList to produce a list of charge positions resulting from
a successive application of f on the last result, taking successive elements of
parameters as parameters. The initial positions are left to the program, it is
told to distribute 2500 particles over the surface.

In[5]:= l = FoldList[f, ChargePositions[2500, 0], parameters];

The result is now best visualised by

In[6]:= AnimateGraphics[(Show[Graphics3D[Point /@ #[[1]]]])& /@ l]

which, in this case, produces an animation based on the graphics seen in ﬁg. 4.1.

It is often useful to save the results, so that one doesn’t have to re calculate a quite
time consuming distribution. In this case the “.dat” extension of the Mathematica
command Export is quite easy to handle:

In[7]:= Export["pos2500 - 3D.dat", Last[l][[1]]] ,

In[8]:= Export["pos2500 - 2D.dat", Last[l][[2]]] .

The saved data can be retrieved for instance by

In[9]:= l2D = Import["pos2500 - 2D.dat"]

or

In[10]:= l3D = Import["pos2500 - 3D.dat"] .

Any imported 3D–list of data can be loaded into the Potential–function (the last
output of ChargePositions is automatically loaded):

In[11]:= SetCharges[l3D] .

One can then get the potential just typing e.g.

In[12]:= Potential[{5, 2, 3}]

Out[12]= 0.162799 .

There is, as one can see, no restriction on the point–vector, for the potential of a
sum of point charges is of course extrapolatable to an arbitrary position. To com-
pare the potential of the charged metallic Möbius strip with the homogeneously
charged one we visualise the potential in a similar way:

In[13]:= Plot3D[Potential[{x, y, 0.}], {x, -1.8, 1.8}, {y, -1.8, 1.8}] ,

the output can be seen in ﬁg. 4.2.

A comparison with ﬁg. 3.5 shows that the maximum value of the potential of the
metallic strip is slightly smaller in the chosen plane (z = 0), because the charges
are driven to the rim of the strip. This is also the reason why the potential in the

4.2. NUMERICALAPPROACH

19

Figure 4.1: Distributions of point–particles on the Möbius strip .

20

CHAPTER4. METALLICSURFACES

Figure 4.2: Potential of a metallic, charged Möbius strip

section where the strip is parallel to the x–y–plane is ﬂatter (the metallic strip is
an equipotential–area).

Chapter 5

Radiation

5.1 Fundamentals

The following considerations can be learned in more detail in e.g. [2] or [5].

For localised charges and currents the vectorpotential Ai can be calculated with
the appropriate Green’s function:

Ai

r j, t

=

d3r¢

1
c

|r j-r¢
j|
c

ji

r¢
j, t -
r j - r¢

j

K

.

O

˜˜˜˜˜
Being only interested in the ﬁelds far away from their sources (r¢ (cid:134) r) the mag-
netic ﬁeld can (using Bi = ¶i jk¶ jAk) be written as

(cid:224)

˜˜˜˜˜

I

M

Bi = -¶i jk

r j
c2r2

d3r¢ Œ
(cid:213)k

r¢
l , t -

r
c

+

rlr¢
l
cr

+ O

1
r2

where the short notation

Œ
(cid:213) = ¶ j

(cid:224)

¶t is used. If one also introduces

K

O

K

O

Œ
qi

r j, t

=

d3r¢ ji

r¢
j, t -

r
c

+

r jr¢
j
cr

,

the so called radiation part of the magnetic ﬁeld is

(cid:224)

I

M

K

O

(5.1)

(5.2)

¶i jk

Œ Œq jrk
c2r2

Br i

r j, t

=

I

M

21

22

CHAPTER5. RADIATION

and, using the Maxwell–equation in the (source free) radiation region

the radiation part of the electric ﬁeld can be expressed as

1
c

¶E j
¶t

= ¶i jk¶ jBk

Er i

r j, t

=

¶i jk(¶ jlm

Œ Œqlrm)rk

.

c2r3

(5.3)

(5.4)

(5.5)

(5.6)

Now the radiation part of the Poynting vector can be deﬁned:
I

M

Sr i

r j, t

=

¶i jkEr j

r j, t

Br k

r j, t

.

c
4p

Inserting eq. 5.2 and eq. 5.3 one gets (er
vector in radial direction)

I

M

I

M

I

M

i is the ith cartesian component of the unit

Sr i

r j, t

=

c
4p

1
c4r2

2

Œ Œq

-

2

er
j

Œ Œq j

er
i

or, in vector notation

I

M

J

I

M

N

Sr (r, t) =

c
4p

1
c4r2

Œ Œq · er

2

er .

The quantity of interest is the radiation power with respect to the (radial) direction,
i.e. the radiation power per inﬁnitesimal area–element of the unit sphere. Using
dP = S (cid:215) d2f one easily gets

I

M

dP
dW

=

1
4pc3

2

Œ Œq · er

which is a quite easy formula if one only knows q. The standard way for calcu-
I
lating q uses the following considerations.
The function q (r, t) can also be seen as a function of the direction er = r
retarded time tr = t - r
“time” and “space” arguments). In the resulting integral

r and the
(mark the exchange of order of

c, it’s written as q

tr, er

M

Œ
q

tr, er

=

d3r¢ j

I

M
r¢, tr +

r¢ (cid:215) er
c

I

M

(cid:224)

K

O

5.1. FUNDAMENTALS

23

one takes the ﬁrst two elements of the Taylor expansion around tr (zero and ﬁrst
order) of the integrand j:

Œ
q

tr, er

=

d3r¢ j

r¢, tr

+

d3r¢ Œ
(cid:213)

r¢, tr

r¢ (cid:215) er
c

.

Œ
I
(cid:224)
r + ¶i ji = 0 and the fact that
Using ji = ¶ j j jri - (¶ j j j)ri, the continuity equation
the sources are localised, one can simplify the ﬁrst integrand to r¢ Œ
r

(cid:224)

M

I

M

I

M

.

r¢, tr

A little more tricky is the transformation of the second integrand. Firstly, similar
to the transformation of the ﬁrst integrand one wants a total derivative, which will
vanish due to locality. The corresponding equality would be

I

M

¶¢
i jir jr¢

jr¢
k =

r jr¢

jr¢
k + jirir¢

k + jkr jr¢
j .

(5.7)

¶¢
i ji
«‹‹‹›‹‹‹ﬁ
-˙r

I

M

Now one realizes that the last two terms are also obtained by

¶k ji¶ jlmr¢

l jmri = r¢

i jkri - r¢

k jiri .

(5.8)

Adding eq. 5.7, eq. 5.8 and
factors. Therefore an equivalent formula for the q–vector is

jr¢
k results in the desired integrand, up to some

Œ
r r jr¢

q

tr, er

=

d3r¢ r¢ r

r¢, tr

+

d3r¢

r¢ · j

r¢, tr

·

+

1
2c

r
r

I

M

1
2cr

+
(cid:224)

d3r¢ Œ
r
I

r¢, tr
M

r (cid:215) r¢
(cid:224)

r¢ .

I

I

MM

(5.9)

With the deﬁnitions

(cid:224)

I

M I

M

p(tr) =

d3r¢ r¢r

r¢, tr

,

m(tr) =

d3r¢ r¢ · j
M
I

r¢, tr

and

1
(cid:224)
2c

Qi j(tr) = 3

d3r¢ r¢

i r¢
jr

(cid:224)

r¢, tr
I

M

(5.10)

(5.11)

(5.12)

I
of the electric dipole momentum (5.10), the magnetic dipole momentum (5.11)
Œ Œq can, in this approximation, be
and the electric quadrupole momentum (5.12),
expressed as

(cid:224)

M

24

CHAPTER5. RADIATION

Œ Œq

tr, er

= Œ Œp(tr) + Œ Œm(tr) · er +

1
6c

eT
r

Œ Œ Œ
Q(tr) .

(5.13)

M

For the validity of this approximation the charge density (or the current density)
I
must not vary signiﬁcantly in the time r(cid:215)r¢
c , where d is the
characteristic diameter of the charge and current distribution. If the characteristic
time for a change of r or j is T , the necessary condition is

cr . This term is of order d

Another way for formulating this condition is to set the magnitude of the velocity
of the moved charges to v, which can be compared with d
T and therefore one gets

This shows that the approximation describes a nonrelativistic movement.

5.2 Application to Rotation

To guarantee the validity of eq. 5.10 to eq. 5.13 for a rotating system one has to
fulﬁl

or

d
c

(cid:134) T .

v (cid:134) c .

d (cid:134) l

f (cid:134)

,

c
d

l » cT being the characteristic wavelength and f = 1/ T the characteristic fre-
quency.

5.2.1 Rotation of an Ensemble of Point Charges

To use the outcome of section 4.2 for further calculations some ideas about treat-
ing rotations are given now, inﬂuenced by [7] (see also [1]).

5.2. APPLICATIONTOROTATION

25

A rotating vector r(t) can in general be described as

r(t) = B(t)r0 ,

r0 being the initial position and B(t) the transformation matrix in dependency of
time, the rotation matrix (B(0) = (cid:0) ). The well kown matrices for rotation around
the z– and y–axis will be needed. With j being the rotation angle they are

In[1]:= Bz[j_] :=

Cos[j] - Sin[j] 0
Sin[j]
0
1
0

Cos[j]
0

(cid:230)(cid:231)(cid:231)(cid:231)(cid:231)

Ł

and

In[2]:= By[j_] :=

Cos[j]
0

0 Sin[j]
1
- Sin[j] 0 Cos[j]

0

(cid:230)(cid:231)(cid:231)(cid:231)(cid:231)

Ł

.

(cid:246)(cid:247)(cid:247)(cid:247)(cid:247)

ł

(cid:246)(cid:247)(cid:247)(cid:247)(cid:247)

ł

The most general problem for an ensemble of point charges would be a list of
charge positions and an arbitrary rotation axis with angular velocity w.

Usually the axis will include the origin of the coordinate system. If not this can
easily be made so by subtracting a vector from the origin to an in general arbitrary
point of the axis (the new origin) from all position vectors of the point charges.

Now the rotation axis still has an arbitrary direction, described by the angles qw
and jw. For an easy description of radiation it would be most convenient to have
e.g.
the z–axis as rotation axis. This can be achieved by using a new coordi-
nate system which exactly fulﬁls this. To get the initial positions of the charges
in this coordinate system one has to multiply each position–vector by a simple
transformation matrix given by

In[3]:= B[qomega_, jomega_] := By[-qomega].Bz[-jomega] .

To take the conducting Möbius strip as an example one can use the saved data
(see 4.2) and e.g. the z–axis of the standard parametrisation as rotation axis, the
positions are then

In[4]:= positions =

B

0, 0

.#

& /@Import["pos2500 - 3D.dat"] .

Before calculating the electro–magnetic momenta of interest one can make these
J
calculations easier by some more considerations.

E

A

N

When using eq. 5.10 on point charges one gets

p(tr) =

d3r¢ r¢

qnd

r¢ - rn(tr)

.

(cid:224)

I

M

N

n=1

(cid:226)

26

CHAPTER5. RADIATION

N is the total number of point–particles, rn(tr) are their positions at time tr. The
qn are the charges that are from now on taken to be equal and for simplicity set to
1/ N, which sets the total charge to 1.

The positions rn(tr) can be expressed from the initial positions rn0 and the rotation
matrix around z with argument wtr. Due to the linearity of the integral the sum
can be pulled out which yields

p(tr) =

d3r¢ r¢d

r¢ - Bz(wtr)rn0

=

Bz(wtr)rn0 =

1
N

N

n=1

1
N

N

n=1

(cid:226)

1
(cid:226)
(cid:224)
= Bz(wtr)
N

I

rn0 = Bz(wtr)p0

M

N

n=1

(cid:226)

with p0 being the initial electric dipole momentum. This can now be calculated
for the example positions:

In[5]:= pZero =

Apply[Plus, positions]

1
Length[positions]

Out[5]= {0.00530198, 0.00202618, 0.00111019} .

Of main interest is the mean radiation power per dW, which means the average
over one periode 2p/ w will be taken. As a consequence one can just type t instead
of tr, the shift of r/ c being of no inﬂuence. The electric dipole momentum is
therefore

In[6]:= p = Bz[w t].pZero
Out[6]= {0.00530198 Cos[tw]-0.00202618 Sin[tw], 0.00202618 Cos[tw]+
0.00530198 Sin[t w], 0.00111019} .

For later comparison the radiation of just this contribution will be visualised. To
do so this vector has to be differentiated twice with respect to time, then the outer
product with the vector er has to be calculated and the square of the result has to
be taken. In the result the average over one periode can be calculated by using

1
2
3
8

sin2(wt)

cos2(wt)

=

,

sin4(wt)
Y

]

]

sin2(wt) cos2(wt)
Y
sin(wt) cosi(wt)
]
sino(wt)

Y

,

,

]

=

cos4(wt)
Y
1
Y
]
8
sini(wt) cos(wt)
coso(wt)
= 0 ,

Y

X

]
\

Y
X

]

\

=

=

=

=
=

= 0 and

5.2. APPLICATIONTOROTATION

27

where i is an arbitrary integer and o an arbitrary odd integer. In Mathematica
code one has

In[7]:= meandPdW1[q_, j_, w_, c_] :=

Evaluate

Collect
A

Simplify

A
Expand
A

1

A

4 p c3 Apply[Plus, Cross[D[p, {t, 2}],

{Sin[q] Cos[j], Sin[q] Sin[j],

Cos[q]}]ˆ2]

/.

x_?NoT Sin[y_ t]4 ﬁ x

3
8

/.
E

x_?NoT Sin[y_ t]2 ﬁ x

/.

1
2

3
8

x_?NoT Cos[y_ t]4 ﬁ x

/. x_?NoT Cos[y_ t]2 ﬁ

x

1
2

/. x_?NoT Sin[y_ t]2 Cos[y_ t]2 ﬁ x

/.

1
8

x_?NoT Sin[y_ t] Cos[y_ t]_Integer ﬁ 0 /.

x_?NoT Cos[y_ t] Sin[y_ t]_Integer ﬁ 0 /.

x_?NoT Sin[y_ t]n_?OddQ ﬁ 0 /.

x_?NoT Cos[y_ t]n_?OddQ ﬁ 0 /. x_?NoT Sin[y_ t] ﬁ 0 /.

x_?NoT Cos[y_ t] ﬁ 0 /. x_ Sin[j]2 ﬁ x

x_ Sin[q]2 ﬁ x

1 - Cos[q]2

/. 0. x_ ﬁ 0., c
I

1 - Cos[j]2
.

/.

M

NoT is just a function which checks that its argument doesn’t contain the symbol
t:

ME

EE

I

In[8]:= NoT[x_] := FreeQ[x, t] .

To clearify this long function:

In[9]:= meandPdW1[q, j, w, c]

Out[9]=

1.28185 · 10-6 w4 + 1.28185 · 10-6 w4 Cos[q]2
c3

.

Now the following numerical values are taken: c = 3 (cid:215) 1010 and w = 3000. Units
are left out in this Mathematica–session (it would be cm/s and s-1 for these quan-
tities). To get easily readable and easily visualisable values the function g (for
“graphical”) is introduced:

In[10]:= g[q_, j_, w_, c_] := 1024 meandPdW1[q, j, w, c] .

One gets for example

In[11]:= g

0, 0, 3000, 3 1010

A

E

28

CHAPTER5. RADIATION

Out[11]= 7.69109 .

Now the radiation power dependent of direction can be visualised. A quite reveal-
ing method is to plot the points the following way: Take a direction (q, j) and
multiply the unit vector in this direction with the corresponding radiated power.

The result is an area which contains exactly the desired information. If one takes
a point on the area the radiated power in this direction (from the origin) is the
distance from the origin.

In[12]:= ParametricPlot3D

Sin[q] Cos[j],

g
q, j, 3000, 3 1010
A
q, j, 3000, 3 1010

A9

q, j, 3000, 3 1010
Sin[q] Sin[j],
E

Cos[q]

, {q, 0, p}, {j, 0, 2 p}

E

E

=

E

g

g

A

A

As expected the radiation shows no j–dependence because j is the angle from
the x–axis around the z–axis, which is the rotation axis. The average power is
therefore independent of this angle. As a consequence it also makes sense only to
do a 2D–plot in the x–z–plane (j = 0):

5.2. APPLICATIONTOROTATION

In[13]:= ParametricPlot

g

g

q, 0, 3000, 3 1010

A9

A

q, 0, 3000, 3 1010
Cos[q]

, {q, 0, 2 p},

Sin[q],

E

PlotRange ﬁ {{-8, 8}, {-8, 8}}, AspectRatio ﬁ Automatic

A

E

=

29

E

-8

-6

-4

-2

2

4

6

8

8

6

4

2

-2

-4

-6

-8

Now the magnetic dipole and electric quadrupole momenta shall be considered.
The ﬁrst steps are again simpliﬁcations of the integrals, for which rn(t) = Bz(wt)rn0,
vn(t) = ˙Bz(wt)rn0 and (for each charge) j = vr are needed. The following term
occurs under the integral for m and can be transformed:

r · v = (Br0) · ( _Br0) = B

r0 · (BT _Br0)

.

Considering (BT _Br0) = W · r0, W = BTw = w (w lies in the rotation axis) and
w = wez one can make the simpliﬁcations (index 0 for initial is dropped)

I

M

¶i jk¶klmr jez

l rm =

dild jm - dimd jl

r jez

l rm = r jez

i r j - r jez

jri = ez

i r2 - rirz .

I

M

B(t) rotates around the z–axis, therefore B(t)ez = ez. As a consequence the ﬁrst
term of m(t) doesn’t depend on time and is irrelevant for the (ﬁnal) power calcu-
lation, where m(t) only appears two times differentiated w.r.t. time. For the sake
of completeness it shall still be given here:

30

CHAPTER5. RADIATION

m(t) =

w
2cN

(cid:230)(cid:231)(cid:231)(cid:231)(cid:231)
ez
Ł

N

n=1

r2
n - Bz(wt)

rz
nrn

,

N

n=1

(cid:246)(cid:247)(cid:247)(cid:247)(cid:247)

ł

In[14]:= m =

w
(cid:226)
2 c Length[positions]
({0, 0, 1} Plus @@ (Norm /@ positions)-

(cid:226)

Bz[w t].(Plus @@ Map[(#[[3]] * #)&, positions]))

Out[14]=

w (1.07295 Cos[t w] + 205.004 Sin[t w])
5000 c

,

9

w (-205.004 Cos[t w] + 1.07295 Sin[t w])
5000 c

,

0.530487 w
c

.

For later calculations the symbol m¢ is introduced which represents mainly the
second term of m, but leaves out the rotation matrix and includes on the other
side the prefactor 1/ N, which makes it a simple numeric quantity:

=

In[15]:= mPrime =

(Plus@@Map[(#[[3]]*#)&, positions])

1
Length[positions]

Out[15]= {-0.000429178, 0.0820015, 0.0665318} .

The electric quadrupole can similarly be simpliﬁed:

Qi j(t) =

rn i(t)rn j(t) = Bz ik(wt)

BT

z lj(wt) ,

3
N

N

n=1

(cid:226)

N

(cid:230)(cid:231)(cid:231)(cid:231)(cid:231)

(cid:246)(cid:247)(cid:247)(cid:247)(cid:247)

3
rn krn l
N
Ł
ł
«‹‹‹‹‹‹‹‹‹‹‹‹›‹‹‹‹‹‹‹‹‹‹‹‹ﬁ
(cid:226)
=Q0 kl

n=1

In[16]:= Qzero =

3
Length[positions]

Apply[Plus, Map[(Outer[Times, #, #])&, positions]]

Out[16]= {{1.84205, -0.00466737, -0.00128754},

{-0.00466737, 1.91751, 0.246004}, {-0.00128754, 0.246004, 0.199595}} .

With the deﬁnitions

In[17]:= Bdot = D[Bz[w t], t];
Bdotdot = D[Bdot, t];
Bdotdotdot = D[Bdotdot, t];

and the introduction of a short form for transposition

In[18]:= T[q_] := Transpose[q]
Œ Œq can be calculated:

5.2. APPLICATIONTOROTATION

31

In[19]:= qDoubleDot =

Bdotdot.pZero-

w
2 c
1
6 c

Cross[Bdotdot.mStrich, {Sin[q] Cos[j], Sin[q] Sin[j], Cos[q]}]+

{Sin[q] Cos[j], Sin[q] Sin[j], Cos[q]}.

(Bdotdotdot.Q.Bz[-w t] + 3 Bdotdot.Q.T[Bdot] + 3 Bdot.Q.T[Bdotdot]+

Bz[w t].Q.T[Bdotdotdot]) .

And from that we can build

In[20]:= meandPdW2[q_, j_, w_, c_] :=

Evaluate

Collect
A

Simplify

A
Expand

1
A
4 p c3

A

I

Plus @@ (Cross[qDoubleDot, {Sin[q] Cos[j], )

Sin[q] Sin[j], Cos[q]}]2

/.

x_?NoT Sin[w_ t]4 ﬁ x

/.

3
8

x_?NoT Sin[w_ t]2 ﬁ x

/.

ME

x_?NoT Cos[w_ t]4 ﬁ x

/.

x_?NoT Cos[w_ t]2 ﬁ x

/.

1
2

3
8

1
2

x_?NoT Sin[w_ t]2 Cos[w_ t]2 ﬁ x

/.

x_?NoT Sin[w_ t] Cos[w_ t]_Integer ﬁ 0 /.

x_?NoT Cos[w_ t] Sin[w_ t]_Integer ﬁ 0 /.

1
8

x_?NoT Sin[w_ t]n_?OddQ ﬁ 0 /.

x_?NoT Cos[w_ t]n_?OddQ ﬁ 0 /. x_?NoT Sin[w_ t] ﬁ 0 /.

x_?NoT Cos[w_ t] ﬁ 0/. Sin[j]2 ﬁ

1 - Cos[j]2

/.

Sin[q]2 ﬁ

1 - Cos[q]2

/.

Cos[j] Sin[j]3 ﬁ Cos[j] Sin[j]

I
1 - Cos[j]2

/.

M

Sin[j]4 ﬁ

1 - Cos[j]2

//. z_ (0. x_ + y_) ﬁ y z//.

I

M

2

M
,

1
c

(0. + 0. (cid:228)) x_ + y_ ﬁ y

.

I

M

E

E

This function is quite illustrating, because it is ordered in powers of 1/ c:

I

E

In[21]:= meandPdW2[q, j, w, c]

32

CHAPTER5. RADIATION

Out[21]=

1.28185 · 10-6 w4 + 1.28185 · 10-6 w4 Cos[q]2
c3

+

-0.0000346671 w5 Cos[q] - 0.0000346671 w5 Cos[q]3
c4
1
c5 (0.000523188 w6 Cos[q]2 + 0.0000119254 w6 Cos[q]4+

+

0.0000534376 w6 Sin[q]4 + 0.000595024 w6 Cos[j]2 Sin[q]4-
0.000595024 w6 Cos[j]4 Sin[q]4 + 0.000074745 w6 Cos[j] Sin[q]4 Sin[j]-
0.00014949 w6 Cos[j]3 Sin[q]4 Sin[j]) .

The terms of order 1/ c3 are exactly the same as if one had simply a rotating dipole,
as one should have expected. The 1/ c4–terms are “mixed” terms of the electric
dipole on one side and the magnetic dipole or the electric quadrupole on the other
side, due to the square in the formula of dP/ dW. Terms of order 1/ c5 originate
qualitatively from “m2”, “Q2” and “m (cid:215) Q”.

It is clear that, as long as there is a dipole–contribution and the approximation
w (cid:134) c (which is the nonrelativistic–condition in the case d » 1) holds, only the
dipole is of interest. All terms of higher order in 1/ c (i.e. w/ c) are negligible.

This fact can also be visualised. (One again has to use an “inteface–function”.)

In[22]:= f[q_, j_] = Evaluate

1024TrigReduce

meandPdW2

q, j, 3000, 31010

In[23]:= ParametricPlot3D[{f[q, j] Sin[q] Cos[j], f[q, j] Sin[q] Sin[j],

A

A

A

EEE

f[q, j] Cos[q]}, {q, 0, p}, {j, 0, 2 p}]

5.2. APPLICATIONTOROTATION

33

This looks exactly equal to the plot of only the dipole–contribution.

It should also be mentioned, that the j–dependent terms originate from the electric
quadrupole–momentum (and its mixed terms).

If one just looks at a rotating quadrupole (of the same value as the corresponding
contribution of the Möbius strip used above), the radiation characteristics would
be

but with a scaling factor of 10-12 relatively to the graphics above.

5.2.2 Rotation of a given Area

For the calculation of the non–conductive Möbius strip with constant area–charge
(see 3.2) one again simpliﬁes equations 5.10 to 5.12 for the special case of rota-
tion, using the same ideas as in the previous section.

If one point on the rotation axis is A, one introduces a coordinate system with
origin in this point. This simply results in a shift in the parametrisation vector,
which is in this case taken as

In[1]:= A = { 0, 0, 0} .

To make the rotation–axis the z–axis the resulting vector(s) have to be transformed
with the same matrix as in 5.2.1, in this case of course again the unit matrix:

34

CHAPTER5. RADIATION

In[2]:= ParamVector =

B[0, 0].

(-A + {Cos[j] + t Cos[j/2] Cos[j], Sin[j] + t Cos[j/2] Sin[j],

Out[2]=

Cos[j]+t Cos

Cos[j], Sin[j]+t Cos

Sin[j], t Sin

.

j
2

j
2

t Sin[j/2]})
j
2

The total charge is taken to be 1 which results in the (constant) area–charge
A

A

E

9

E

A

E=

In[3]:= s =

1
6.35327

.

In[4]:= pZeroX =

For a numerical integration of p0 (the argument for pulling the rotation matrix
out of the integral goes like in 5.2.1) its three components have to be calculated
separately.

j
2

j
2

s
2 2

s
2 2

j
2

j
2

NIntegrate

4 + 3 t2 + 8 t Cos

+ 2 t2 Cos[j]

A
Cos[j] + t Cos

Cos[j]

A
, {j, 0, 2 p}, {t, -0.5, 0.5}

E

Out[4]= 0.020587

J

A

E

N

E

Doing the corresponding calculation for the y–component there arise some failure
notices:

In[5]:= pZeroY =

NIntegrate

4 + 3 t2 + 8 t Cos

+ 2 t2 Cos[j]

A
Sin[j] + t Cos

Sin[j]

A
, {j, 0, 2 p}, {t, -0.5, 0.5}

E

NIntegrate :: ncvb : NIntegrate failed to converge to prescribed accuracy after

A

E

N

J

E

1 recursive bisections in t near {j, t} = {j, t}.

NIntegrate :: tmap :

NIntegrate is unable to achieve the tolerances specified by the

PrecisionGoal and AccuracyGoal options because the working precision is
insufficient. Try increasing the setting of the WorkingPrecision option.

NIntegrate :: ploss :

Numerical integration stopping due to loss of precision. Achieved

neither the requested PrecisionGoal nor AccuracyGoal;

suspect one of the following : highly oscillatory integrand or the true value of the

integral is 0. If your integrand is oscillatory try using the option Method- >

Oscillatory in NIntegrate.

Out[5]= 3.00457 · 10-15 .

5.2. APPLICATIONTOROTATION

35

For symmetry reasons it’s clear that the result has to be zero, as well as the z–
component (where the same messages emerge). The resulting time–dependent
dipole–momentum is with

In[6]:= pZero = {pZeroX, 0, 0}

In[7]:= p = Bz[w t].pZero

Out[7]= {0.020587 Cos[t w], 0.020587 Sin[t w], 0} .

The dipole radiation power is from that

In[8]:= meandPdW1[q, j, w, c]

Out[8]=

0.0000168634 w4 + 0.0000168634 w4 Cos[q]2
c3

,

the characteristic plot looks as follows

which shows that it is about 10 times higher radiative than the conducting Möbius
strip but of equal shape.

36

CHAPTER5. RADIATION

It is clear that the corrections of the higher order terms (magnetic dipole, electric
quadrupole) are negligible, for completeness they are also calculated:

In[9]:= mPrimeX = NIntegrate

rz rx

4 + 3 t2 + 8 t Cos

+ 2 t2 Cos[j],

{j, 0, 2 p}, {t, -0.5, 0.5}

A

s
2 2

E

j
2

A

E

NIntegrate :: ncvb : NIntegrate failed to converge to prescribed accuracy after

6 recursive bisections in j near {j, t} = {j, t}.

NIntegrate :: tmap :

NIntegrate is unable to achieve the tolerances specified by the

PrecisionGoal and AccuracyGoal options because the working precision is
insufficient. Try increasing the setting of the WorkingPrecision option.

NIntegrate :: ploss :

Numerical integration stopping due to loss of precision. Achieved

neither the requested PrecisionGoal nor AccuracyGoal;

suspect one of the following : highly oscillatory integrand or the true value of the

integral is 0. If your integrand is oscillatory try using the option Method- >

Oscillatory in NIntegrate.

Out[9]= -1.5992 · 10-17

In[10]:= mPrimeY = NIntegrate

rz ry

4 + 3 t2 + 8 t Cos

+ 2 t2 Cos[j],

{j, 0, 2 p}, {t, -0.5, 0.5}

A

A

E

Out[10]= 0.041217

In[11]:= mPrimeZ = NIntegrate

rz rz

4 + 3 t2 + 8 t Cos

+ 2 t2 Cos[j],

{j, 0, 2 p}, {t, -0.5, 0.5}

A

A

E

Out[11]= 0.0420065

j
2

j
2

s
2 2

E

s
2 2

E

In[12]:= mPrime = {0, mPrimeY, mPrimeZ}

Out[12]= {0, 0.041217, 0.0420065}

In[13]:= QzeroXX =

3 NIntegrate

rx rx

4 + 3 t2 + 8 t Cos

+ 2 t2 Cos[j],

s
2 2

j
2

A

E

{j, 0, 2 p}, {t, -0.5, 0.5}

A

Out[13]= 1.68418

E

5.2. APPLICATIONTOROTATION

37

In[14]:= QzeroXY =

3 NIntegrate

rx ry

4 + 3 t2 + 8 t Cos

+ 2 t2 Cos[j],

s
2 2

{j, 0, 2 p}, {t, -0.5, 0.5}

A

j
2

A

E

NIntegrate :: ncvb : NIntegrate failed to converge to prescribed accuracy after

E

6 recursive bisections in j near {j, t} = {j, t}.

NIntegrate :: tmap :

NIntegrate is unable to achieve the tolerances specified by the

PrecisionGoal and AccuracyGoal options because the working precision is
insufficient. Try increasing the setting of the WorkingPrecision option.

NIntegrate :: ploss :

Numerical integration stopping due to loss of precision. Achieved

neither the requested PrecisionGoal nor AccuracyGoal;

suspect one of the following : highly oscillatory integrand or the true value of the

integral is 0. If your integrand is oscillatory try using the option Method- >

Oscillatory in NIntegrate.

Out[14]= 4.14319 · 10-16

In[15]:= QzeroXZ =

3 NIntegrate

rx rz

4 + 3 t2 + 8 t Cos

+ 2 t2 Cos[j],

s
2 2

{j, 0, 2 p}, {t, -0.5, 0.5}

A

j
2

A

E

NIntegrate :: ncvb : NIntegrate failed to converge to prescribed accuracy after

E

6 recursive bisections in j near {j, t} = {j, t}.

NIntegrate :: tmap :

NIntegrate is unable to achieve the tolerances specified by the

PrecisionGoal and AccuracyGoal options because the working precision is
insufficient. Try increasing the setting of the WorkingPrecision option.

NIntegrate :: ploss :

Numerical integration stopping due to loss of precision. Achieved

neither the requested PrecisionGoal nor AccuracyGoal;

suspect one of the following : highly oscillatory integrand or the true value of the

integral is 0. If your integrand is oscillatory try using the option Method- >

Oscillatory in NIntegrate.

Out[15]= -4.79759 · 10-17

38

CHAPTER5. RADIATION

In[16]:= QzeroYY =

Out[16]= 1.68418

In[17]:= QzeroYZ =

Out[17]= 0.123651

In[18]:= QzeroZZ =

3 NIntegrate

ry ry

4 + 3 t2 + 8 t Cos

+ 2 t2 Cos[j],

{j, 0, 2 p}, {t, -0.5, 0.5}

A

A

E

3 NIntegrate

ry rz

4 + 3 t2 + 8 t Cos

+ 2 t2 Cos[j],

{j, 0, 2 p}, {t, -0.5, 0.5}

A

A

E

s
2 2

s
2 2

s
2 2

E

E

j
2

j
2

j
2

3 NIntegrate

rz rz

4 + 3 t2 + 8 t Cos

+ 2 t2 Cos[j],

Out[18]= 0.126019

{j, 0, 2 p}, {t, -0.5, 0.5}

A

A

E

E
In[19]:= Qzero = {{QzeroXX, 0, 0}, {0, QzeroYY, QzeroYZ}, {0, QzeroYZ, QzeroZZ}};

Out[19]=

MatrixForm[Qzero]

1.68418
0
0

(cid:230)(cid:231)(cid:231)(cid:231)(cid:231)

Ł

0
0
0.123651
1.68418
0.123651 0.126019

(cid:246)(cid:247)(cid:247)(cid:247)(cid:247)

ł

In[20]:= qDoubleDot =

Bdotdot.pZero-

w
2 c
1
6 c

Cross[Bdotdot.mPrime, {Sin[q] Cos[j], Sin[q] Sin[j], Cos[q]}]+

{Sin[q] Cos[j], Sin[q] Sin[j], Cos[q]}.

(Bdotdotdot.Qzero.Bz[-w t] + 3 Bdotdot.Qzero.T[Bdot]+

3 Bdot.Qzero.T[Bdotdot] + Bz[w t].Qzero.T[Bdotdotdot])

In[21]:= meandPdW[q, j, w, c]

Out[21]=

0.0000168634 w4 + 0.0000168634 w4 Cos[q]2
c3

+

-0.0000675242 w5 Cos[q] - 0.0000675242 w5 Cos[q]3
c4
1
c5 (-8.44935 · 10-6 w6 + 0.0000844935 w6 Cos[q]2+

+

1.08377 · 10-14 w6 Cos[j]2 - 2.16754 · 10-14 w6 Cos[q]2 Cos[j]2+
2.16754 · 10-14 w6 Cos[q]2 Cos[j]4 + w6 Cos[q]4

(0.0000591455 + 1.08377 · 10-14 Cos[j]2 - 1.08377 · 10-14 Cos[j]4)+

8.44935 · 10-6 w6 Sin[q]4 + 1.54824 · 10-15 w6 Cos[j]2 Sin[q]4+
w6 Cos[j]4 (-1.08377 · 10-14 - 1.54824 · 10-15 Sin[q]4))

5.2. APPLICATIONTOROTATION

39

The shape of the total radiation power remains unchanged, but the quadrupole–
part has a quite interesting form:

It is obvious that the rotation symmetry results from the block–diagonal form of
the Q–matrix.

40

CHAPTER5. RADIATION

Chapter 6

Conclusion

It is out of question that the Möbius strip is a quite interesting two–dimensional
structure which was also worthwile to consider in an electro–dynamic discussion.

The idea of sending a current around the Möbius strip to drive a dipole (elec-
tric or magnetic) in the middle of the strip was not discussed, because it is clear
that this would not result in effects not realisable with an ordinary wire. Instead
it was described how the Möbius strip behaves in electrostatics, conducting or
non–conducting, and electrodynamics, taking a closer look at rotating charged
structures.

As was seen in this work, the Möbius strip behaved quite interesting but not unex-
pected. Especially for rotation there cannot be any peak in the radiation scheme,
because one can always do the calculation of the leading term which will then
dominate and therefore determine the radiation. This can vary in magnitude but
not in shape.

The beneﬁt of this diploma work are the two programmed Mathematica–packages,
used and described in chapters three and four. The printout of these packages in
notebook–form is given in the appendix, together with the necessary C–code for
the needed functions. One can also ﬁnd a more detailed description of how to
combine Mathematica and C in appendix A.

These packages can not only be used for gaining more insight in basic lectures
about electrostatics. They are also applicable for visualising potentials other than
the Coulomb one.

41

42

CHAPTER6. CONCLUSION

Appendix A

Programming Mathematica
Functions in C

This appendix will describe the basic commands necessary to combine Math-
ematica– and C–programs. A more detailed explanation can be found in the
Mathematica book, section 2.13.3 and references, available in [4].

The C–ﬁle itself has not to be modiﬁed very much. For a basic function there are
only two things:

(cid:15) The library mathlink.h has to be included

(cid:15) The deﬁnition– and return–lines of the main function have to be

int main(int argc, char *argv[]) {

return MLMain(argc, argv);

} .

In the C–ﬁle set up in this way there can be programmed functions in any way
one can imagine — and program in C. It can also take nearly any arguments from
within Mathematica, which will be described immediately.

To enable Mathematica to use the programmed C–function a so called MathLink
template (.tm–ﬁle) has to be written. A simple one looks as follows:

:Begin:
c_function
:Function:
mma_function[x_Integer, y_Integer]
:Pattern:
:Arguments:
{x, y,x*y}
:ArgumentTypes: {Integer, Integer, Integer}

43

44

APPENDIXA. PROGRAMMING MATHEMATICA FUNCTIONSINC

:ReturnType:
:End:

Integer

It has the obligatorial :Begin: and :End: clauses and the lines

(cid:15) :Function:

name of the C–function

(cid:15) :Pattern:

(cid:15) :Arguments:

name of the Mathematica–function and its argu-
ments

actual arguments given to the C–function, con-
tained in curly brackets

(cid:15) :ArgumentTypes: the variable types of the C–arguments, again in

(cid:15) :ReturnType:

return type of the C–function

brackets

One can also add an arbitrary number of :Evaluate:
that are evaluated once when the function is installed (see below).

<mma-code> lines

The simplest argument types are

Argument type C–code in function deﬁnition
Integer
Real
String
Symbol
IntegerList
RealList
Manual

int
double
char *
char*
int *, long
double *, long
void

Mark that for lists not only a pointer of appropriate type has to be declared but
also a long variable to pass the length of the list.

Manual can be speciﬁed if one either cannot say which return–type the function
will give or if the returned arguments are not of simple type (Integer, Real; not
IntegerList, RealList). The C–function then has to contain one of the commands

MLPutDouble, MLPutFunction, MLPutIntegerList, MLPutRealArray,
MLPutSymbol, ...

or similar commands, all of the form MLPut<something> (see [4]), which
constitute the return value.

If the C–ﬁle and MathLink template are ﬁnished the Mathematica compiler com-
mand can be given:

mcc -o <installFile> <MLtemplatefile.tm> <c_code_file.c> .

45

The programmed C–function can now be used from a Mathematica notebook by
entering

In[1]:= link = Install[" < installFile > "]

and calling the function speciﬁed in the .tm–line :Pattern:.

The packages AreaPotential.m and AreaConductor.m use one more
special feature of Mathematica, the command Splice.

If one wants to give the C–function not only values (single or in lists, arrays)
but also arbitrary functions this cannot be done by simple function–arguments.
In the case of the “Area–packages” this is the case for the (completely arbitrary)
parametrisation of the area and the potential function.

The way to solve this problem is, to program only a template C–ﬁle, leaving out
the explicit deﬁnitions of the functions mentioned above.
Instead, one has to
specify a “placeholder” to let mathematica ﬁll in the missing parts. It goes like
this:

Assume one has a Mathematica–function which one wants to use in a C–program,

In[2]:= f[x_] :=

x
1 + x2 .

Then one programs a template C–ﬁle file.template which includes the func-
tion

double f(double a) {
return <*f[a]*> ;

} .

Now one runs the Splice–command

In[3]:= Splice["file.template", "file.c", FormatType ﬁ CForm] .

This command searches the ﬁle file.template for clauses delimited by <*
and *>, executes them as if they were common Mathematica expressions and
creates the ﬁle file.c with the clauses replaced by the result of the correspond-
ing evaluation.

If this ﬁle also includes an external function one can now use

In[4]:= Run["mcc - o installFile file.tm file.c"]

(file.tm already has to exist) and

In[5]:= Install["installFile"]

46

APPENDIXA. PROGRAMMING MATHEMATICA FUNCTIONSINC

to make the external function available, which now depends (in general) on the
previously deﬁned Mathematica–function f.

This principle is also used in the packages listed below.

Appendix B

Mathematica Packages

B.1 AreaPotential.m

In[1]:= BeginPackage["‘AreaPotential‘"]

Usage

In[2]:= AreaPotential :: usage =
"contains :
n SetArea

n GridValues

n Potential

n ViewPotential

n AnimatePotential"

n SetDistribution

n SetPotentialLaw

In[3]:= SetArea :: usage =

(cid:148)

(cid:148)

(cid:148)

(cid:148)

(cid:148)

(cid:148)

(cid:148)

"SetArea[ParamVector, aRange, bRange, accuracy]

n Sets new
nParamVector is a List of

n

Area through parametrisation
three Elements that have to depend on two parameters
which have to be the symbols ¢a¢ and ¢b¢
nxRange is a
List of one Symbol (¢a¢ or ¢b¢) and two Real values (lower
and upper parameter - bound)
naccuarcy specifys the density
of the calculation - grid on the area, its default - value is 30"
(cid:148)

(cid:148)

(cid:148)

(cid:148)

(cid:148)

(cid:148)

(cid:148)

n

n

In[4]:= SetDistribution :: usage =

"SetDistribution[chargeFunction]

n Sets the charge distribution

function on the surface
(cid:148)
which may only consist of a and b"

n

nchargeFunction is an expression

(cid:148)

(cid:148)

47

48

APPENDIXB. MATHEMATICA PACKAGES

In[5]:= SetPotentialLaw :: usage =

"SetPotentialLaw[PotLaw]

n Changes the potential law of ¢

point charges¢, default is the Coulomb - law
an expression that must only contain the symbols ¢x¢, ¢y¢
and ¢z¢ (the cartesian coordinates, respectively)"

nPotLaw is

(cid:148)

(cid:148)

(cid:148)

n

In[6]:= GridValues :: usage =

"GridValues[xRange, yRange, zRange, accuracy, maxPotential]

n

Returns a grid of potential - values
of two values, lower and upper bound to specify the ashlar
(cid:148)
naccuracy specifies the density of the grid
of interest

n_Range is a list

(cid:148)

n

n

(cid:148)

n

nWith no arguments specified GridValues returns the

(cid:148)
grid of the last calculation"
(cid:148)
In[7]:= Potential :: usage =

(cid:148)

(cid:148)

"Potential[{x, y, z}]

n Returns the electrostatic potential

at the point (x, y, z) based on the previous grid - calculation"

(cid:148)
In[8]:= ViewPotential :: usage =

"ViewPotential[planeNumber, opt___] OR

nViewPotential[
planeNumber, Grid, opt___]
n Returns a graphics object
showing the surface cut by the plane of interest and the
(cid:148)
nIf ¢Grid¢ is left out the grid
potential on this plane.
n¢opt___¢ stands for an
of the last calculation is taken;
(cid:148)
optional argument describing to which axes the plane of
(cid:148)
interest should be parallel, e.g. ¢plane ﬁ xy¢ (which is default)"

(cid:148)

(cid:148)

n

In[9]:= AnimatePotential :: usage =

"PotentialAnimation[opt___]

n Returns a bunch of graphics

which are animated when double - clicked on the first one."

(cid:148)

Debugging

In[10]:= Parameters :: usage = ""

In[11]:= Begin["‘Private‘"]

In[12]:= Off[General :: "spell1"]

Setting default values for variables needed in computation (all
unknown to user)

Charge distribution on the surface

In[13]:= chargeDist = 1.

B.1. AREAPOTENTIAL.M

49

Parametrisation-vector of the area, parameters are (always) a and b, set to Möbius strip:

In[14]:= ParamVector = {Cos[b] + a Cos[b/2] Cos[b], Sin[b] + a Cos[b/2] Sin[b],

a Sin[b/2]}

Tangent-vector in the direction of the a-parametrisation-curve:

In[15]:= av = Simplify[D[ParamVector, a]]

Tangent-vector in the direction of the b-parametrisation-curve:

In[16]:= bv = D[ParamVector, b]

Normal-vector to the area:

In[17]:= nv = Simplify[Cross[av, bv]]

Inﬁnitesimal area-element:

In[18]:= dO = Simplify[chargeDist Sqrt[nv.nv]]

Split parametrisation-vector into 3 functions

In[19]:= xParam[a_, b_] := Evaluate[ParamVector[[1]]]

In[20]:= yParam[a_, b_] := Evaluate[ParamVector[[2]]]

In[21]:= zParam[a_, b_] := Evaluate[ParamVector[[3]]]

Parameter for the accuracy of the integral-calculation:

In[22]:= acc = 30

1/distance is default for the (electrostatic) potential law:

In[23]:= PotentialLaw = 1./Sqrt[x * x + y * y + z * z]

Boundaries for the parameters a/b and the ashlar of interest:

In[24]:= aLower = -0.5; aUpper = 0.5;

bLower = 0.; bUpper = 2 N[p];

xLower = -3.; xUpper = 3.;

yLower = -3.; yUpper = 3.;

zLower = -3.;
zUpper = 3.;

The three lengths of the ashlar are divided into ’accuracy’ parts to constitute the grid:

In[25]:= accuracy = 25

50

APPENDIXB. MATHEMATICA PACKAGES

The upper boundary for the potential, necessary because of the incontinuous calculation,
is

In[26]:= maxPotential = 8.

Variable to store the outcome of the potential calculation (especially if user doesn’t store
it for himself):

In[27]:= InternalGridDefault = "Not yet calculated, use ¢GridValues¢."

Internal Functions

The function, that writes the parameters into the C-ﬁle:

In[28]:= mySettings[chDist_, ParamVec_, al_, au_, bl_, bu_, accuracy_,

PotLaw_] :=

(ParamVector = ParamVec; chargeDist = chDist;

xParam[x_, y_] := Evaluate[ParamVec[[1]]/. a ﬁ x /. b ﬁ y];
yParam[x_, y_] := Evaluate[ParamVec[[2]] /. a ﬁ x /. b ﬁ y];
zParam[x_, y_] := Evaluate[ParamVec[[3]] /. a ﬁ x /. b ﬁ y];
av = Simplify[D[ParamVector, a]]; bv = D[ParamVector, b];
nv = Simplify[Cross[av, bv]]; dO = Simplify[chargeDist Sqrt[nv.nv]];
aLower = al; aUpper = au; bLower = bl; bUpper = bu;
acc = accuracy; PotentialLaw = PotLaw;
InternalGrid = InternalGridDefault; )

Find out, whether a vector is a valid parametrisation-vector (3-dim., only
depends on a and b):

In[29]:= ParamQ[{xv_, yv_, zv_}] :=

Module[{var}, var = xv + yv + zv /. Global‘a ﬁ 1. /. Global‘b ﬁ 1.;

MachineNumberQ[var]]

Find out, whether an expression is a valid charge distribution function (only
depends on a and b):

In[30]:= distQ[expression_] :=

Module[{var}, var = expression /. Global‘a ﬁ 1. /. Global‘b ﬁ 1.;

MachineNumberQ[var]]

B.1. AREAPOTENTIAL.M

51

Find out, whether an expression is a valid potential law (depends only on x, y
and z):

In[31]:= LawQ[arg_] :=

Module[{var}, var = arg/. Global‘x ﬁ 1. /. Global‘y ﬁ 1. /. Global‘z ﬁ 1.;

MachineNumberQ[var]]

Find out, whether an expression is a valid range-list for the arguments of
GridValues:

In[32]:= RangeQ[arg_] := Module[{argument}, argument = Map[N, arg];

If[Length[argument] == 2, VectorQ[argument, NumberQ], False]]

Messages:

In[33]:= GridValues :: "CProgram" =

User-Functions

"Compilation and installation successful, starting calculation."

User-function for setting (only) the area of the charged thing:

In[34]:= SetArea[ParamVec_?ParamQ, {Global‘a, al_Real, au_Real},

{Global‘b, bl_Real, bu_Real}, accuracy_Integer :30] :=

mySettings[chargeDist, ParamVec/. Global‘a ﬁ a/.Global‘b ﬁ b,

al, au, bl, bu, accuracy, PotentialLaw]

User-function for setting (only) the charge distribution function:

In[35]:= SetDistribution[expression_] :=

mySettings[expression/. Global‘a ﬁ a/.Global‘b ﬁ b, ParamVector,

aLower, aUpper, bLower, bUpper, acc, PotentialLaw]

User-function for setting (only) the potential law:

In[36]:= SetPotentialLaw[PotLaw_?LawQ] :=

mySettings[chargeDist, ParamVector, aLower, aUpper, bLower,

bUpper, acc, PotLaw]

52

APPENDIXB. MATHEMATICA PACKAGES

User-function to get the potential-values on the speciﬁed grid:

In[37]:= GridValues[xRange_?RangeQ, yRange_?RangeQ, zRange_?RangeQ,

gotAccuracy_Integer :accuracy, gotMaxPotential_Real :maxPotential] :=

(If[xRange[[1]] < xRange[[2]],

xLower = xRange[[1]]; xUpper = xRange[[2]],
xLower = xRange[[2]]; xUpper = xRange[[1]]];

If[yRange[[1]] < yRange[[2]],

yLower = yRange[[1]]; yUpper = yRange[[2]],
yLower = yRange[[2]]; yUpper = yRange[[1]]];

If[zRange[[1]] < zRange[[2]],

zLower = zRange[[1]]; zUpper = zRange[[2]],
zLower = zRange[[2]]; zUpper = zRange[[1]]];

accuracy = gotAccuracy; maxPotential = gotMaxPotential;

Uninstall[link];
Splice["potential.template", "potential.c", FormatType ﬁ CForm];
Run["mcc - o potential potential.tm potential.c"];
link = Install["potential"];
Message[GridValues :: "CProgram"];

InternalGrid = Global‘GridVals[xRange, yRange, zRange, accuracy,

maxPotential])

In[38]:= GridValues[] := InternalGrid

User-function to get the potential at an arbitrary position based on previous
GridValues

In[39]:= Potential :: "position" = "‘1‘ = ‘2‘ out of range (‘3‘, ‘4‘)."

In[40]:= ValidX[x_] := If[x < xLower||x > xUpper,

Message[Potential :: "position", "x", x, xLower, xUpper], True]

In[41]:= ValidY[y_] := If[y < yLower||y > yUpper,

Message[Potential :: "position", "y", y, yLower, yUpper], True]

In[42]:= ValidZ[z_] := If[z < zLower||z > zUpper,

Message[Potential :: "position", "z", z, zLower, zUpper], True]

B.1. AREAPOTENTIAL.M

53

In[43]:= Potential[{x_?ValidX, y_?ValidY, z_?ValidZ}] :=

Module

Dx =

xUpper - xLower
accuracy

, Dy =

yUpper - yLower
accuracy

, Dz =

zUpper - zLower
accuracy

,

x, yi, zi, dx, dy, dz

A9

, x = IntegerPart

x - xLower
Dx

+ 1;

yi = IntegerPart

+ 1; zi = IntegerPart
A

y - yLower
=
Dy

z - zLower
E
Dz

+ 1;

dx = x - xLower - (x - 1) Dx; dy = y - yLower - (yi - 1) Dy;
dz = z - zLower - (zi - 1) Dz;

A

A

E

E

InternalGrid[[x, yi, zi]]

Dx - dx
Dx

InternalGrid[[x + 1, yi, zi]]

InternalGrid[[x, yi + 1, zi]]

InternalGrid[[x + 1, yi + 1, zi]]

InternalGrid[[x, yi, zi + 1]]

InternalGrid[[x + 1, yi, zi + 1]]

InternalGrid[[x, yi + 1, zi + 1]]

InternalGrid[[x + 1, yi + 1, zi + 1]]

Dy - dy
Dy
Dy - dy
Dy

dx
Dx
Dx - dx
Dx

dy
Dy

+

Dz - dz
Dz
Dz - dz
Dz
Dz - dz
Dz

+

+

dx
Dx

+

dy
Dy

Dz - dz
Dz
Dy - dy
Dy

dz
Dz

+

Dx - dx
Dx

Dy - dy
Dy

dx
Dx
Dx - dx
Dx

dy
Dy

dz
Dz
dz
Dz

+

+

dx
Dx

dy
Dy

dz
Dz

E

Initialisation

Write the default-values to C-ﬁle, compile it and link the executable into
Mathematica:

In[44]:= mySettings[chargeDist, ParamVector, aLower, aUpper, bLower,

bUpper, acc, PotentialLaw];

Splice["potential.template", "potential.c", FormatType ﬁ CForm];

Run["mcc - o potential potential.tm potential.c"];

link = Install["potential"]

54

APPENDIXB. MATHEMATICA PACKAGES

Graphical Functions

Extraction of desired elements of a grid

In[45]:= XYPlane[g_, zi_] := Map[Map[Part[#, zi]&, #]&, g]

In[46]:= XZPlane[g_, yi_] := Map[Part[#, yi]&, g]

In[47]:= YZPlane[g_, xi_] := Part[g, x]

Plotting of the slicing plane

In[48]:= PlaneXY[zi_] :=

In[49]:= PlaneXZ[yi_] :=

In[50]:= PlaneYZ[xi_] :=

ParametricPlot3D[{x, y, zLower + (zi - 1)(zUpper - zLower)/accuracy},

{x, xLower, xUpper}, {y, yLower, yUpper}, DisplayFunction ﬁ Identity];

ParametricPlot3D[{x, yLower + (yi - 1)(yUpper - yLower)/accuracy, z},

{x, xLower, xUpper}, {z, zLower, zUpper}, DisplayFunction ﬁ Identity];

ParametricPlot3D[{xLower + (x - 1)(xUpper - xLower)/accuracy, y, z},

{y, yLower, yUpper}, {z, zLower, zUpper}, DisplayFunction ﬁ Identity];

Viewing slicing plane and parametrized area from speciﬁed viewing point

pool for viewing-point-options

In[51]:= views = {{{-2.4, 1.3, -2}, {0, 0, -1}}, {{-2.4, 2, 1.3}, {0, 1, 0}},

{{-2, -2.4, 1.3}, {-1, 0, 0}}}

In[52]:= viewPlane[i_, plane_] :=

Show[ParametricPlot3D[{xParam[t, j], yParam[t, j], zParam[t, j]},

{t, aLower, aUpper}, {j, bLower, bUpper},
AxesLabel ﬁ {Global‘x, Global‘y, Global‘z}, Boxed ﬁ False,
SphericalRegion ﬁ True,
PlotRange ﬁ {zLower + zLower/100, zUpper + zUpper/100},
DisplayFunction ﬁ Identity,
ViewPoint ﬁ

views[[First[First[Position[PlaneXY PlaneXZ PlaneYZ, plane]]]]][[

1]],

ViewVertical ﬁ

2]]], plane[i]];

views[[First[First[Position[PlaneXY PlaneXZ PlaneYZ, plane]]]]][[

B.1. AREAPOTENTIAL.M

55

Main user-function for viewing the Potential

In[53]:= PlaneRangeQ[number_] := number > 0 && number < accuracy + 2

In[54]:= optQ[opt_] := Switch[Global‘plane /. {opt},

Global‘xy, True,
Global‘xz, True,
Global‘yz, True,
_, False]

In[55]:= Options[ViewPotential] = {Global‘plane ﬁ Global‘xy}

In[56]:= ViewPotential[planeNumber_Integer?PlaneRangeQ, myGrid_List,

intermediate[Global‘plane/.{opt}/.Options[ViewPotential],

opt___?optQ] :=

planeNumber, myGrid]

In[57]:= ViewPotential[planeNumber_Integer?PlaneRangeQ, opt___?optQ] :=

intermediate[Global‘plane/.{opt}/.Options[ViewPotential],

planeNumber, InternalGrid]

In[58]:= intermediate[plane_, n_, myGrid_] := Switch[plane,

Global‘xy, myGraph[XYPlane, PlaneXY, n, myGrid],
Global‘xz, myGraph[XZPlane, PlaneXZ, n, myGrid],
Global‘yz, myGraph[YZPlane, PlaneYZ, n, myGrid]]

In[59]:= myGraph[gridPlane_, plane_, n_, myGrid_] :=

Show[

Graphics[

{Rectangle[{0, 0}, {4, 4}, ListPlot3D[gridPlane[myGrid, n],

Axes ﬁ False, Boxed ﬁ False, SphericalRegion ﬁ True,
PlotRange ﬁ {0, maxPotential}, DisplayFunction ﬁ Identity]],

Rectangle[{3.8, 1.8}, {6, 4},

viewPlane[accuracy + 1 - Abs[n - accuracy - 1], plane]]},

ImageSize ﬁ 700]];

Animation of Potential

In[60]:= AnimatePotential[opt___?optQ] := ShowAnimation[

Table[

]]

ViewPotential[accuracy + 1 - Abs[n - accuracy - 1], opt],
{n, 1, 2 accuracy - 1, 1}

56

APPENDIXB. MATHEMATICA PACKAGES

Debugging

In[61]:= Parameters := Sequence["chargeDist = ", chargeDist, "

nParamVector = ",

nPotentialLaw = ",

ndO = ", dO, "

nacc = ", acc, "

naLower = ", aLower, ", aUpper = ", aUpper,
nxLower = ",

(cid:148)
nbLower = ", bLower, ", bUpper = ", bUpper, "

ParamVector, "
PotentialLaw, "
(cid:148)
"
(cid:148)
xLower, ", xUpper = ", xUpper, "
yUpper, "
accuracy, ", maxPotential = ", maxPotential, "
InternalGrid]

nzLower = ", zLower, ", zUpper = ", zUpper, "
(cid:148)

(cid:148)

(cid:148)

(cid:148)

(cid:148)

(cid:148)

(cid:148)

nyLower = ", yLower, ", yUpper = ",

naccuracy = ",

nInternalGrid = ",

(cid:148)

End of Package

In[62]:= End[]

In[63]:= EndPackage[]

B.2 AreaConductor.m

In[1]:= BeginPackage["‘AreaConductor‘"]

Usage

In[2]:= AreaConductor :: usage =
"contains :
n SetArea

n SetPotentialLaw

n ChargePositions

n Potential

n SetCharges"

(cid:148)

(cid:148)

(cid:148)

In[3]:= SetArea :: usage =

(cid:148)

(cid:148)

"SetArea[ParamVector, aRange, bRange]

n Sets new Area through
nParamVector is a List of three Elements

parametrisation
that have to depend on two parameters which have to be
(cid:148)
the symbols ¢a¢ and ¢b¢
a¢ or ¢b¢) and two Real values (lower and upper parameter - bound)"

nxRange is a List of one Symbol (¢

(cid:148)

(cid:148)

n

n

(cid:148)
In[4]:= SetPotentialLaw :: usage =

(cid:148)

"SetPotentialLaw[PotLaw]

n Changes the potential law of ¢

point charges¢, default is the Coulomb - law
an expression that must only contain the symbol ¢r¢ (the
(cid:148)
distance from a point charge, respectively)"

(cid:148)

(cid:148)

n

nPotLaw is

B.2. AREACONDUCTOR.M

57

In[5]:= ChargePositions :: usage =

"ChargePositions[number, steps, [speed]]

n Returns the positions

of ¢number¢ point - charges after ¢steps¢ movements towards
equilibrium position; ¢speed¢ is an optional Real number.
nChargePositions[pos2D, steps, [speed]]
to above, but the first argument is the list of positions
(cid:148)
of point - charges on the surface"

nOR

(cid:148)

(cid:148)

(cid:148)

(cid:148)

n

n similar

In[6]:= Potential :: usage =

"Potential[{x, y, z}]

nReturns the Potential at position (x, y, z)"

In[7]:= SetCharges :: usage =
"SetCharges[list]

(cid:148)

nSets the charges on the points specified

in ¢list¢ for potential - calculations"

(cid:148)

Debugging

In[8]:= Parameters :: usage = ""

In[9]:= Begin["‘Private‘"]

In[10]:= Off[General :: "spell1"]

Setting default values for variables needed in computation (all
unknown to user)

Parametrisation-vector of the area, parameters are (always) a and b, set to Möbius strip:

In[11]:= ParamVector = {Cos[b] + a Cos[b/2] Cos[b], Sin[b] + a Cos[b/2] Sin[b],

a Sin[b/2]}

Tangent-vector in the direction of the a-parametrisation-curve:

In[12]:= av = Simplify[D[ParamVector, a]]

Tangent-vector in the direction of the b-parametrisation-curve:

In[13]:= bv = D[ParamVector, b]

Split parametrisation-vector into 3 functions

In[14]:= xParam[a_, b_] := Evaluate[ParamVector[[1]]]

In[15]:= yParam[a_, b_] := Evaluate[ParamVector[[2]]]

In[16]:= zParam[a_, b_] := Evaluate[ParamVector[[3]]]

1/distance is default for the (electrostatic) potential law:

58

APPENDIXB. MATHEMATICA PACKAGES

In[17]:= PotentialLaw = 1./r;

ForceLaw = D[-PotentialLaw, r];

Law[0.] := ¥; Law[p_] := 1./p;

cartesianLaw[{x_, y_, z_}] := Law

Sqrt

x2 + y2 + z2

;

Boundaries for the parameters a/b and the ashlar of interest:

A

A

EE

In[18]:= aLower = -0.5; aUpper = 0.5;

bLower = 0.; bUpper = 2 N[p];

The total charge is devided at maximum into ’MaxCharges’ point charges that can move
on the surface:

In[19]:= MaxCharges = 5000

Variable to store the outcome of the potential calculation (especially if user doesn’t store
it for himself):

In[20]:= InternalChargesDefault = "Notyetcalculated, use¢ChargePositions¢."

Internal Functions

The function, that writes the parameters into the C-ﬁle:

In[21]:= mySettings[ParamVec_, al_, au_, bl_, bu_, PotLaw_] :=

(ParamVector = ParamVec;

xParam[x_, y_] := Evaluate[ParamVec[[1]]/. a ﬁ x /. b ﬁ y];
yParam[x_, y_] := Evaluate[ParamVec[[2]] /. a ﬁ x /. b ﬁ y];
zParam[x_, y_] := Evaluate[ParamVec[[3]] /. a ﬁ x /. b ﬁ y];
av = Simplify[D[ParamVector, a]]; bv = D[ParamVector, b];
nv = Simplify[Cross[av, bv]];
aLower = al; aUpper = au; bLower = bl; bUpper = bu;
PotentialLaw = PotLaw; ForceLaw = D[-PotentialLaw, r];
Law[p_] := Evaluate[PotLaw /. r ﬁ p];
InternalCharges = InternalChargesDefault;
Splice["conductor.template", "conductor.c", FormatType ﬁ CForm])

B.2. AREACONDUCTOR.M

59

Find out, whether a vector is a valid parametrisation-vector (3-dim., only
depends on a and b):

In[22]:= ParamQ[{xv_, yv_, zv_}] :=

Module[{var}, var = xv + yv + zv /. Global‘a ﬁ 1. /. Global‘b ﬁ 1.;

MachineNumberQ[var]]

Find out, whether an expression is a valid potential law (depends only on x, y
and z):

In[23]:= LawQ[arg_] := Module[{var}, var = arg/. Global‘r ﬁ 1. ;

MachineNumberQ[var]]

Partition of the charges on the parameter-area:

In[24]:= partition :: "overflow" =

"Number of charges (‘1‘) too high, replaced by ‘2‘."

In[25]:= partition [zahl_Integer] :=

Sequence @@

Module[{z, a, b, c},

z = If[zahl > MaxCharges, Message[partition :: "overflow", zahl,
MaxCharges]; MaxCharges, zahl]; a = IntegerPart[Sqrt[z]];

c = z - aˆ2; If[c £ a, b = a, b = a + 1; c = c - a]; {a, b, c}]

In[26]:= ChargePositions :: "now" =

"positions calculated, generating potential function"

Messages:

User-Functions

User-function for setting (only) the area of the charged thing:

In[27]:= SetArea[ParamVec_?ParamQ, {Global‘a, al_Real, au_Real},

{Global‘b, bl_Real, bu_Real}] :=

mySettings[ParamVec/. Global‘a ﬁ a/.Global‘b ﬁ b, al, au, bl,

bu, PotentialLaw]

60

APPENDIXB. MATHEMATICA PACKAGES

User-function for setting (only) the potential law:

In[28]:= SetPotentialLaw[PotLaw_?LawQ] := (Clear[Law];

mySettings[ParamVector, aLower, aUpper, bLower, bUpper, PotLaw])

In[29]:= SetPotentialLaw[PotLaw_?LawQ, ZeroValue_] := (Clear[Law];

mySettings[ParamVector, aLower, aUpper, bLower, bUpper, PotLaw];
Law[0.] := Evaluate[ZeroValue])

User-function to get the positions of the point-charges:

In[30]:= ChargePositions[number_Integer, steps_Integer :20, factor_Real :0.5] :=

(Uninstall[link];

Run["mcc - o conductor conductor.tm conductor.c"];
link = Install["conductor"];

temp = Global‘PosFromNumber[partition[Abs[number]], Abs[steps],

factor];

InternalCharges = temp[[1]];

CalculatedPotential[{x_, y_, z_}] := Evaluate[

1/Length[InternalCharges]

Plus@@( (cartesianLaw[# - {x, y, z}])& /@ InternalCharges)];

In[31]:= ChargePositions[pos2D_List, steps_Integer :20, factor_Real :0.5] :=

temp)

(Uninstall[link];

Run["mcc - o conductor conductor.tm conductor.c"];
link = Install["conductor"];

temp = Global‘PosFromArray[Flatten[pos2D], Abs[steps], factor];
InternalCharges = temp[[1]];

CalculatedPotential[{x_, y_, z_}] := Evaluate[

1/Length[InternalCharges]

Plus@@( (cartesianLaw[# - {x, y, z}])& /@ InternalCharges)];

temp)

In[32]:= ChargePositions[] := InternalCharges

B.2. AREACONDUCTOR.M

61

User-function to set the 3D-positions of the point-charges:

In[33]:= SetCharges[list_] :=

(InternalCharges = list;

CalculatedPotential[{x_, y_, z_}] :=

Evaluate[

1/Length[list] Plus@@( (cartesianLaw[# - {x, y, z}])& /@ list)])

In[34]:= Potential[point_] := CalculatedPotential[point]

Potential at one point:

Initialisation

Write the default-values to C-ﬁle, compile it and link the executable into
Mathematica:

In[35]:= mySettings[ParamVector, aLower, aUpper, bLower, bUpper, PotentialLaw];

Run["mcc - o conductor conductor.tm conductor.c"];

link = Install["conductor"]

Debugging

In[36]:= Parameters := Sequence["ParamVector = ", ParamVector, "

nPotentialLaw = ", PotentialLaw, "

dO, "
", aUpper = ", aUpper, "
(cid:148)
bUpper, "

nInternalCharges = ", InternalCharges]

nbLower = ", bLower, ", bUpper = ",
(cid:148)

(cid:148)

ndO = ",
naLower = ", aLower,

(cid:148)

(cid:148)

End of Package

In[37]:= End[]

In[38]:= EndPackage[]

62

APPENDIXB. MATHEMATICA PACKAGES

Appendix C

.tm Files

For the printout of the following ﬁles the verbatim–environment was used (see
[3]).

C.1 potential.tm

:Begin:
:Function:
:Pattern:
:Arguments:
:ArgumentTypes: {RealList,RealList,RealList,Integer,Real}
:ReturnType:
:End:

GridVals
GridVals[x_List, y_List, z_List, i_Integer, max_Real]
{x, y, z, i, max}

Manual

C.2 conductor.tm

:Begin:
:Function: PosFromNumber
:Pattern:

PosFromNumber[numberA_Integer,numberB_Integer,

numberLast_Integer,steps_Integer,factor_Real]

Manual

{numberA,numberB,numberLast,steps,factor}

:Arguments:
:ArgumentTypes: {Integer,Integer,Integer,Integer,Real}
:ReturnType:
:End:
:Begin:
:Function: PosFromArray
:Pattern: PosFromArray[pos2D_List,steps_Integer,factor_Real]
:Arguments: {pos2D,steps,factor}
:ArgumentTypes: {RealList,Integer,Real}

63

64

APPENDIXC. .TMFILES

:ReturnType: Manual
:End:

Appendix D

C Programs

D.1 potential.template

#include "mathlink.h"
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include <bits/nan.h>
#define E exp(1)
#define Power pow
#define Cos cos
#define Sin sin
#define Tan tan
#define Sqrt sqrt
#define Log log

float a0, a1, da, b0, b1, db;
float *grid;
int AreaGrid;

/**************************************
Parametrisierung der Fläche:
**************************************/

float xParam(float a,float b)
{ return <*Global‘AreaPotential‘Private‘ParamVector[[1]]

/. Global‘AreaPotential‘Private‘b->b /. Global‘AreaPotential‘Private‘a->a*>; }

float yParam(float a, float b)
{ return <*Global‘AreaPotential‘Private‘ParamVector[[2]]

/. Global‘AreaPotential‘Private‘b->b /. Global‘AreaPotential‘Private‘a->a*>; }

65

66

APPENDIXD. CPROGRAMS

float zParam(float a, float b)
{ return <*Global‘AreaPotential‘Private‘ParamVector[[3]]

/. Global‘AreaPotential‘Private‘b->b /. Global‘AreaPotential‘Private‘a->a*>; }

/**************************************
Betrag des Normalvektors:
**************************************/

float dO(float a, float b)
{

return <*Global‘AreaPotential‘Private‘dO

/. Global‘AreaPotential‘Private‘b->b /. Global‘AreaPotential‘Private‘a->a*>;

}

{

}

}

}

/**************************************
Parameterbereich festlegen:
**************************************/

void SetParams(float *a_lower, float *a_upper,

float *b_lower, float *b_upper, int *accuracy)

*a_lower=<*Global‘AreaPotential‘Private‘aLower*>;
*a_upper=<*Global‘AreaPotential‘Private‘aUpper*>;
*b_lower=<*Global‘AreaPotential‘Private‘bLower*>;
*b_upper=<*Global‘AreaPotential‘Private‘bUpper*>;
*accuracy=<*Global‘AreaPotential‘Private‘acc*>;

/**************************************
Potentialgesetz:
**************************************/

float law(float x, float y, float z)
{

return <*Global‘AreaPotential‘Private‘PotentialLaw

/. Global‘AreaPotential‘Private‘x->x /. Global‘AreaPotential‘Private‘y->y
/. Global‘AreaPotential‘Private‘z->z*>;

///////////////////////////////////////////////////////////////////////////

float Integrand(float a, float b, float x, float y, float z)
{

return dO(a,b)*law(x-xParam(a,b),y-yParam(a,b),z-zParam(a,b));

///////////////////////////////////////////////////////////////////////////

D.1. POTENTIAL.TEMPLATE

67

double Potential(float x, float y, float z)
{

float val=0.;
int i, j;
for(i=0;i<AreaGrid+1;i++)
{

for (j=0;j<AreaGrid+1;j++)
{

val+=Integrand(a0+(float)i*da,b0+(float)j*db,x,y,z);

}
val=val*(a1-a0)*(b1-b0)/(float)((AreaGrid+1)*(AreaGrid+1));
return (double)val;

///////////////////////////////////////////////////////////////////////////

void GridVals(double *xrange, long xlen, double *yrange, long ylen,

double *zrange, long zlen, int MainGrid, double MAX)

}

}

{

float xmin,xmax,dx,ymin,ymax,dy,zmin,zmax,dz;
double vals[MainGrid+1][MainGrid+1][MainGrid+1], *dummy;
int i,j,k;
long dims[]={MainGrid+1,MainGrid+1,MainGrid+1};

if ((xlen != 2) || (ylen!=2) || (zlen!=2))
{

MLEvaluateString(stdlink,

return;

}
if((xmin=(float)xrange[0])>(xmax=(float)xrange[1]))
{xmin=(float)xrange[1];xmax=(float)xrange[0];}
if((ymin=(float)yrange[0])>(ymax=(float)yrange[1]))
{ymin=(float)yrange[1];ymax=(float)yrange[0];}
if((zmin=(float)zrange[0])>(zmax=(float)zrange[1]))
{zmin=(float)zrange[1];zmax=(float)zrange[0];}

dx=(xmax-xmin)/(float)MainGrid;
dy=(ymax-ymin)/(float)MainGrid;
dz=(zmax-zmin)/(float)MainGrid;
for (i=0;i<=MainGrid;i++)
{

for (j=0;j<=MainGrid;j++)
{

for (k=0;k<=MainGrid;k++)
{

"Print[\"Pattern: {x_min,x_max},{y_min,y_max},{z_min,z_max},stepNumber\"]");

vals[i][j][k]=Potential(xmin+(float)i*dx,ymin+(float)j*dy,zmin+(float)k*dz);

if ((vals[i][j][k]>MAX) || (vals[i][j][k]==NAN)) {vals[i][j][k]=MAX;}
else if (vals[i][j][k]<-1*MAX) {vals[i][j][k]=-1*MAX;}

APPENDIXD. CPROGRAMS

68

}

}

}

}

}
dummy=(double*)vals;

// MLPutRealArray(stdlink, vals, dims, NULL, 3);
MLPutRealArray(stdlink, dummy, dims, NULL, 3);
return;

///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////

int main(int argc, char *argv[])
{

SetParams(&a0, &a1, &b0, &b1, &AreaGrid);
da=(a1-a0)/(float)AreaGrid; db=(b1-b0)/(float)AreaGrid;
return MLMain(argc, argv);

D.2 conductor.template

#include "mathlink.h"
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include <bits/nan.h>
#define E exp(1)
#define Power pow
#define Cos cos
#define Sin sin
#define Tan tan
#define Sqrt sqrt
#define Log log

float a0, a1, da, b0, b1, db, multiplicator;
float pos3D[10000][3], pos2D[10000][2];
double *charges_pointer;

/**************************************
Parametrisierung der Fläche:
**************************************/

float xParam(float a,float b)
{ return <*Global‘AreaConductor‘Private‘ParamVector[[1]]

/. Global‘AreaConductor‘Private‘b->b /. Global‘AreaConductor‘Private‘a->a*>; }

D.2. CONDUCTOR.TEMPLATE

69

float yParam(float a, float b)
{ return <*Global‘AreaConductor‘Private‘ParamVector[[2]]

/. Global‘AreaConductor‘Private‘b->b /. Global‘AreaConductor‘Private‘a->a*>; }

float zParam(float a, float b)
{ return <*Global‘AreaConductor‘Private‘ParamVector[[3]]

/. Global‘AreaConductor‘Private‘b->b /. Global‘AreaConductor‘Private‘a->a*>; }

/**************************************
Tangentialvektoren der Fläche:
**************************************/

void get_tangent_vectors(float *aVector, float *bVector, float a, float b){

aVector[0]=<*Global‘AreaConductor‘Private‘av[[1]]

/. Global‘AreaConductor‘Private‘b->b /. Global‘AreaConductor‘Private‘a->a*>;

aVector[1]=<*Global‘AreaConductor‘Private‘av[[2]]

/. Global‘AreaConductor‘Private‘b->b /. Global‘AreaConductor‘Private‘a->a*>;

aVector[2]=<*Global‘AreaConductor‘Private‘av[[3]]

/. Global‘AreaConductor‘Private‘b->b /. Global‘AreaConductor‘Private‘a->a*>;

bVector[0]=<*Global‘AreaConductor‘Private‘bv[[1]]

/. Global‘AreaConductor‘Private‘b->b /. Global‘AreaConductor‘Private‘a->a*>;

bVector[1]=<*Global‘AreaConductor‘Private‘bv[[2]]

/. Global‘AreaConductor‘Private‘b->b /. Global‘AreaConductor‘Private‘a->a*>;

bVector[2]=<*Global‘AreaConductor‘Private‘bv[[3]]

/. Global‘AreaConductor‘Private‘b->b /. Global‘AreaConductor‘Private‘a->a*>;

/**************************************
Parameterbereich festlegen:
**************************************/

void SetParams(float *a_lower, float *a_upper, float *b_lower, float *b_upper)
{

*a_lower=<*Global‘AreaConductor‘Private‘aLower*>;
*a_upper=<*Global‘AreaConductor‘Private‘aUpper*>;
*b_lower=<*Global‘AreaConductor‘Private‘bLower*>;
*b_upper=<*Global‘AreaConductor‘Private‘bUpper*>;

}

}

/**************************************
Potentialgesetz:
**************************************/

float law(float r)
{

return <*Global‘AreaConductor‘Private‘ForceLaw

/. Global‘AreaConductor‘Private‘r->r*>;

APPENDIXD. CPROGRAMS

70

}

}

}

}

///////////////////////////////////////////////////////////////////////////

void Force(int max_index, int selection, float *f) {

float F, r[3], R;
float current[3];
int i=1-(selection>0), j;

for(j=0;j<3;j++){ current[j]=pos3D[selection][j]; }
f[0]=f[1]=f[2]=0.;
for(;i<max_index;i++){

for(j=0;j<3;j++){ r[j]=current[j]-pos3D[i][j]; }
R=sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);
F=law(R);
for(j=0;j<3;j++){f[j]+=F*r[j]/R;}
if((i+1)==selection) { i++; }

}

///////////////////////////////////////////////////////////////////////////

void Norm(float *vector){

int i=0;
float length=sqrt(vector[0]*vector[0]+vector[1]*vector[1]+vector[2]*vector[2]);
for(;i<3;i++){vector[i]/=length;}

///////////////////////////////////////////////////////////////////////////

float Scalar(float *a, float *b){

return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];

///////////////////////////////////////////////////////////////////////////

void Move (int max_index, int number_of_steps, int step){

int i=0, j;
float Factor=multiplicator*( 1.-0.5/(float)number_of_steps *

(float)step )/sqrt(sqrt((float)max_index)) ;

float av[3], bv[3], F[3], a, b, shorten, dummy;

for(;i<max_index;i++){

a=pos2D[i][0];b=pos2D[i][1];
Force(max_index, i, F);
get_tangent_vectors(av, bv, pos2D[i][0], pos2D[i][1]);
Norm(av);Norm(bv);shorten=1.;

D.2. CONDUCTOR.TEMPLATE

71

//restrict to parameter-area:
a=Scalar(av, F);
if
( (pos2D[i][0]+a) > a1 ){shorten=(a1-pos2D[i][0])/a;}
else if( (pos2D[i][0]+a) < a0 ){shorten=(a0-pos2D[i][0])/a;}
b=Scalar(bv, F);
if( (pos2D[i][1]+b) > b1 ){

dummy=(b1-pos2D[i][1])/b;
if(dummy<shorten){shorten=dummy;}

}
else if( (pos2D[i][1]+b) < b0 ){
dummy=(b0-pos2D[i][1])/b;
if(dummy<shorten){shorten=dummy;}

}

}

}

pos2D[i][0]+=a*shorten*Factor;
pos2D[i][1]+=b*shorten*Factor;

///////////////////////////////////////////////////////////////////////////

void ChargePos(int index_max, int number_of_steps)
{

int charge_index=0, i,j;
double dummy3D[index_max][3],
long

dims3D[]={index_max,3}, dims2D[]={index_max,2};

dummy2D[index_max][2];

//iterate equilibrium:

for(i=0;i<number_of_steps;i++){

Move(index_max, number_of_steps, i);
for(charge_index=0;charge_index<index_max;charge_index++){

pos3D[charge_index][0]=xParam(pos2D[charge_index][0], pos2D[charge_index][1]);
pos3D[charge_index][1]=yParam(pos2D[charge_index][0], pos2D[charge_index][1]);
pos3D[charge_index][2]=zParam(pos2D[charge_index][0], pos2D[charge_index][1]);

}

}

}

//check positions on area:

for(charge_index=0;charge_index<index_max;charge_index++){

if(pos2D[charge_index][0]<a0){pos2D[charge_index][0]=a0;}
if(pos2D[charge_index][0]>a1){pos2D[charge_index][0]=a1;}
if(pos2D[charge_index][1]<b0){pos2D[charge_index][1]=b0;}
if(pos2D[charge_index][1]>b1){pos2D[charge_index][1]=b1;}
pos3D[charge_index][0]=xParam(pos2D[charge_index][0], pos2D[charge_index][1]);
pos3D[charge_index][1]=yParam(pos2D[charge_index][0], pos2D[charge_index][1]);
pos3D[charge_index][2]=zParam(pos2D[charge_index][0], pos2D[charge_index][1]);

72

APPENDIXD. CPROGRAMS

//Create List for the 3D- and 2D-positions:

MLPutFunction(stdlink, "List",2);

//"konvert" 3D-list to double for Mathematica-interface and "send" it:

for(i=0;i<index_max;i++){

dummy3D[i][0]=(double)pos3D[i][0];
dummy3D[i][1]=(double)pos3D[i][1];
dummy3D[i][2]=(double)pos3D[i][2];

}
charges_pointer=(double*)dummy3D;
MLPutRealArray(stdlink, charges_pointer, dims3D, NULL, 2);

//"konvert" 2D-list to double for Mathematica-interface and "send" it:

for(i=0;i<index_max;i++){

dummy2D[i][0]=(double)pos2D[i][0];
dummy2D[i][1]=(double)pos2D[i][1];

}
charges_pointer=(double*)dummy2D;
MLPutRealArray(stdlink, charges_pointer, dims2D, NULL, 2);

return;

}

///////////////////////////////////////////////////////////////////////////

void PosFromArray(double *RealList, long listLength,

int number_of_steps, double multipl){

int i=0, charge_index, max_index=listLength/2;

multiplicator=multipl;
for(charge_index=0;charge_index<max_index;charge_index++){

pos2D[charge_index][0]=RealList[i];
i++;
pos2D[charge_index][1]=RealList[i];
i++;
pos3D[charge_index][0]=xParam(pos2D[charge_index][0], pos2D[charge_index][1]);
pos3D[charge_index][1]=yParam(pos2D[charge_index][0], pos2D[charge_index][1]);
pos3D[charge_index][2]=zParam(pos2D[charge_index][0], pos2D[charge_index][1]);

}

}

ChargePos(max_index, number_of_steps);

///////////////////////////////////////////////////////////////////////////

void PosFromNumber(int number_of_charges_one, int number_of_charges_two,

int number_of_charges_last, int number_of_steps, double multipl){

D.2. CONDUCTOR.TEMPLATE

73

int index_max=number_of_charges_one*number_of_charges_two+number_of_charges_last;
int charge_index=0, i, j;

multiplicator=multipl;

da=(a1-a0)/(float)(number_of_charges_one+(number_of_charges_last>0));
db=(b1-b0)/(float)number_of_charges_two;

//initialise charge-positions:

for(i=0;i<number_of_charges_one;i++){

for(j=0;j<number_of_charges_two;j++){
pos2D[charge_index][0]=a0+da/2.+(float)i*da;
pos2D[charge_index][1]=b0+db/2.+(float)j*db;
pos3D[charge_index][0]=xParam(pos2D[charge_index][0], pos2D[charge_index][1]);
pos3D[charge_index][1]=yParam(pos2D[charge_index][0], pos2D[charge_index][1]);
pos3D[charge_index][2]=zParam(pos2D[charge_index][0], pos2D[charge_index][1]);
charge_index++;

}

}
for(i=0;i<number_of_charges_last;i++){

pos2D[charge_index][0]=a0+da/2.+(float)number_of_charges_one*da;
pos2D[charge_index][1]=b0+db/2.+(float)i*db;
pos3D[charge_index][0]=xParam(pos2D[charge_index][0], pos2D[charge_index][1]);
pos3D[charge_index][1]=yParam(pos2D[charge_index][0], pos2D[charge_index][1]);
pos3D[charge_index][2]=zParam(pos2D[charge_index][0], pos2D[charge_index][1]);
charge_index++;

}

}

ChargePos(index_max, number_of_steps);

///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////

int main(int argc, char *argv[])
{

SetParams(&a0, &a1, &b0, &b1);

return MLMain(argc, argv);

}

// da=(a1-a0)/(float)AreaGrid; db=(b1-b0)/(float)AreaGrid;

74

APPENDIXD. CPROGRAMS

Bibliography

[1] H. Goldstein. Classical Mechanics. 2nd Edition. Addison–Wesley Publishing

Company, Inc., Reading, MA, 1950, 1980.

[2] J. D. Jackson. Classical Electrodynamics. 3rd Edition. John Wiley & Sons,

New York, 1999.

[3] H. Kopka. LATEX. Band 1 – Einführung. 3. überarbeitete Auﬂage. Addison–
Wesley Verlag, ein Imprint der Pearson Education Company GmbH, Deutsch-
land, 2000.

[4] Help–Browser of Mathematica 5.0.0.0.

c(cid:13)1988-2003 Wolfram Research,

http://www.wolfram.com.

[5] H. Nowotny. Elektrodynamik und Relativittstheorie. Vorlesung für Studenten
der Technischen Physik. 5. Auﬂage. Institut für Theoretische Physik, Tech-
nische Universität Wien, 2002.

[6] P. Szmolyan. Analysis 2 für Technische Physiker. Institut für Angewandte

und Numerische Mathematik, Technische Universität Wien, 1999.

[7] H. Troger. Vorlesungsunterlagen Mechanik für Technische Physiker. Institut

für Mechanik, Technische Universität Wien, 1999.

75

