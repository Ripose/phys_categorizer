Neighbor List Collision-Driven Molecular Dynamics Simulation

for Nonspherical Hard Particles.

I. Algorithmic Details

Aleksandar Donev,1, 2 Salvatore Torquato,1, 2, 3, (cid:3) and Frank H. Stillinger3

1Program in Applied and Computational Mathematics,

Princeton University, Princeton NJ 08544
2Materials Institute, Princeton University, Princeton NJ 08544
3Department of Chemistry, Princeton University, Princeton NJ 08544

Abstract

In this (cid:12)rst part of a series of two papers, we present in considerable detail a collision-driven

molecular dynamics algorithm for a system of nonspherical particles, within a parallelepiped sim-

ulation domain, under both periodic or hard-wall boundary conditions. The algorithm extends

previous event-driven molecular dynamics algorithms for spheres, and is most e(cid:14)cient when ap-

plied to systems of particles with relatively small aspect ratios and with small variations in size.

We present a novel partial-update near-neighbor list (NNL) algorithm that is superior to previ-

ous algorithms at high densities, without compromising the correctness of the algorithm. This

e(cid:14)ciency of the algorithm is further increased for systems of very aspherical particles by using

bounding sphere complexes (BSC). These techniques will be useful in any particle-based simula-

tion, including Monte Carlo and time-driven molecular dynamics. Additionally, we allow for a

nonvanishing rate of deformation of the boundary, which can be used to model macroscopic strain

and also alleviate boundary e(cid:11)ects for small systems. In the second part of this series of papers we

specialize the algorithm to systems of ellipses and ellipsoids and present performance results for

our implementation, demonstrating the practical utility of the algorithm.

(cid:3) Electronic address: torquato@electron.princeton.edu

1

I.

INTRODUCTION

Classical molecular dynamics (MD) simulations have been used to study the properties

of particle systems for many decades. The (cid:12)rst MD studies used the simplest multi-particle

system, the hard-sphere (cid:13)uid/solid [1], which is very rich in behavior. Subsequently, methods

were developed to follow the dynamics of a system of soft spheres, i.e., particles interacting

with a spherically symmetric and continuous interparticle potential, usually with a hard

cuto(cid:11) on the range of the interaction. The algorithms needed to simulate the two types

of systems are rather di(cid:11)erent, and di(cid:14)cult to combine [12]. For soft particles, one needs

to integrate a system of ordinary di(cid:11)erential equations given by Newtonâ€™s law of motion.

However, for hard particles the interaction potential is singular and the task of integrating

the equations of motion becomes a problem of processing a sequence of binary collisions

between the particles1, or collisions of the particles with the hard walls of a container, if any.

In other words, for hard particles, one needs to predict and process a sequence of discrete

events of vanishing duration.

The algorithm for hard particles therefore becomes event-driven, as opposed to the time-

driven algorithm for soft-particle MD in which time changes in small steps and the equations

of motion are integrated. Event-driven algorithms have the task of scheduling a sequence

of events predicted to happen in the future. The simulation is advanced to the time of

the event with the smallest scheduled time (the impending event) and that event is pro-

cessed. The schedule of events is updated if necessary and the same process is repeated.

In molecular dynamics, the primary kind of event are binary collisions, so the simulation

becomes collision-driven. This kind of collision-driven approach was used for the very (cid:12)rst

MD simulation of the hard-disk system [1], and has since been extended and improved in a

variety of ways, most importantly, to increase the e(cid:14)ciency of the algorithm. All of these

improvements, namely, delayed particle updates, the cell method, the use of a heap for the

event queue, etc., appear in almost any e(cid:14)cient hard-particle MD algorithm. Systems of

many thousands of hard disks or spheres can be studied on a modern personal computer

using such algorithms, and in the past decade the method has been extended to handle more

complex simulations, such as particles in a velocity (cid:12)eld [30].

1 Multi-particle collisions have zero probability of occurring and will not be considered here.

2

However, we are aware of only one collision-driven simulation in the literature for non-

spherical particles, namely, one for very thin rods (needles) [8]. Other molecular dynamics

simulations for hard nonspherical particles have used a time-driven approach [2], which is

simpler to implement than the event-driven approach but inferior in both accuracy and

e(cid:14)ciency (at high densities). Two kinds of smooth shapes are used frequently to model as-

pherical particles: spherocylinders (a cylinder with two spherical caps), and ellipsoids. Both

can become spheres in a suitable limit. Spherocylinders are analytically much simpler then

ellipsoids; however, they are always axisymmetric and cannot be oblate.

The primary reason event-driven algorithms have not yet been used for nonspherical

particles is that a high-accuracy collision-driven scheme for nontrivial particle shapes and

su(cid:14)ciently large systems is very demanding. Computers have only recently reached the nec-

essary speeds, and a proper implementation involves a signi(cid:12)cant level of code complexity.

In this paper, we present in detail a collision-driven molecular dynamics algorithm for a

system of hard nonspherical particles. The algorithm is based on previous event-driven MD

approaches for spheres, and in particular the algorithms of Lubachevsky [19] and Sigurgeirs-

son et al. [2]. While in principle the algorithm is applicable to any particle shape, we have

speci(cid:12)cally tailored it for smooth particles for which it is possible to introduce and easily

evaluate continuously di(cid:11)erentiable overlap potentials. Additionally, it is assumed that the

particles have a spherically symmetric moment of inertia, so that in-between collisions their

angular velocities are constant. Furthermore, the algorithm is most e(cid:14)cient when applied to

relatively dense and homogeneous systems of particles which do not di(cid:11)er widely in size (i.e.,

the degree of polydispersity is small). We focus in this work on systems with lattice-based

boundaries, under both periodic or hard-wall boundary conditions. The main innovations

and strengths of the proposed algorithm are:

(cid:15) It speci(cid:12)cally allows for non-axially symmetric particles by using quaternions in the

representation of orientational degrees of freedom, unlike previous hard-particle algo-

rithms which have been restricted just to needles, spherocylinders or spheroids;

(cid:15) The particle-shape-dependent components of the algorithm are clearly separated from

general concepts, so that it is (at least in principle) easy to adapt the algorithm to

di(cid:11)erent particle shapes. In the second part of this series of papers we present in detail

the implementation of these components for ellipses and ellipsoids;

3

(cid:15) It explicitly allows for time-dependent particle shapes and for time-dependent shape

of the boundary cell, which enables a range of nonequilibrium applications and also

Parinello-Rahman-like [26] constant-pressure molecular dynamics;

(cid:15) It corrects some assumptions in traditional hard-sphere algorithms that are not cor-

rect for nonspherical particles or when boundary deformation is included, such as the

nearest image convention in periodic systems and the claim that there must be an

intervening collision between successive collisions of a given pair of particles;

(cid:15) It is the (cid:12)rst rigorous event-driven MD algorithm to incorporate near-neighbor lists, by

using the concept of bounding neighborhoods. This is a very signi(cid:12)cant improvement

for very aspherical particles and/or at high densities, and has some advantages over

the traditional cell method even for hard spheres because it allows a close monitoring

of the collision history of the algorithm;

(cid:15) It is the (cid:12)rst algorithm to speci(cid:12)cally address the problem of e(cid:14)cient near-neighbor

search for very elongated or very (cid:13)at particles by introducing the concept of bounding

sphere complexes. The algorithm also clearly separates neighbor-search in a static

environment (where particle positions are (cid:12)xed) from its use in a dynamic environment

(where particles move continuously), thus enabling one to easily incorporate additional

neighbor search techniques. We emphasize that the developed near neighbor search

techniques will improve all particle-based simulations, including Monte Carlo and time-

driven molecular dynamics; and

(cid:15) It is documented in detail with pseudo-codes which closely follow the actual Fortran

95 code used to implement it for ellipses and ellipsoids.

One motivation for developing this algorithm has been to extend the Lubachevsky-Stillinger

sphere-packing algorithm [20, 21] to nonspherical particles. We have successfully used our

implementation to obtain many interesting results for random and ordered packings of el-

lipses and ellipsoids [6]. The algorithm can also be used to study equilibrium properties

of hard-ellipse and hard-ellipsoid systems, and we give several illustrative applications in

the second paper of this series. In the second paper we also numerically demonstrate that

our novel neighbor-search techniques can speed the simulation by as much as two orders of

4

magnitude or more at high densities and/or for very aspherical particles, as compared to

direct adaptations of traditional hard-sphere schemes.

We begin by presenting preliminary information and the basic ideas behind the algorithm

in Section.

II. We then focus on the important task of improving the e(cid:14)ciency of the

algorithm by focusing on neighbor search in Section III, and present both the classical cell

method and our adaptation of near-neighbor lists. Detailed pseudocodes for all major steps

in the algorithm for general nonspherical particles are given in Section IV, and these are

continued in the second part of this series of papers for the speci(cid:12)c case of ellipses and

ellipsoids.

II. PRELIMINARIES

In this section we give some background information and a preliminary description of

the algorithm. First, we discuss the impact the shape of the particles has on the algorithm.

Then we brie(cid:13)y describe the two main approaches to hard-particle molecular dynamics,

time-driven and event-driven. Finally, we discuss boundary conditions in our event-driven

molecular dynamics algorithm and also the possibility of performing event-driven MD in

di(cid:11)erent ensembles. Bold symbols are reserved for vectors and matrices, and subscripts

are used to denote their components. Subscripts or superscripts are used heavily to add

speci(cid:12)city to various quantities, for example, r denotes position, while rA denotes the position

of some particle A. We denote the numerical precision with (cid:15) (cid:28) 1, and use subscripted (cid:15)â€™s for

various user-set (small) numerical tolerances. We often omit explicit functional dependencies

when they are clearly implied by the context and it is not important to emphasize them, for

example, f and f (t) will be used interchangeably.

A. Particle Shape

We consider a system of N hard particles whose only interactions are given by impen-

etrability constraints, although it is easy to allow for additional external (cid:12)elds which are

independent of the particles (such as gravity). Many of the techniques developed here are

also used to deal with particles interacting with a soft potential if there is a hard cuto(cid:11) on

the potential. We discuss the special case of orientation-less particles, namely spheres, at

5

length, and we use hard ellipsoids to illustrate the extensions to nonspherical particles. We

will use the terms sphere and ellipsoid in any dimension, but sometimes we will be more

speci(cid:12)c and distinguish between disk and ellipse in two dimensions, and sphere and ellipsoid

in three dimensions.

Spheres are a very important special case not only because of their simplicity, but also

because bounding spheres are a necessary ingredient when dealing with aspherical particles.

A bounding sphere for a particle is centered at the centroid of the particle and has the

minimal possible diameter Dmax = 2Omax so that it fully encloses the particle itself. Here

by centroid we mean a geometrically special point chosen so that the bounding sphere is as

small as possible (i.e., it should be chosen to be as close as possible to the midpoint of the

longest line segment joining two points of the particle). For example, for an ellipsoid, the

bounding sphere has the same center as the ellipsoid and its diameter is equal to the largest

axes of the ellipsoid. The importance of bounding spheres is that they provide a quick and

analytically simple way to test for overlap of two particles: Two particles cannot overlap

if their bounding spheres do not overlap. Occasionally we make use of contained spheres,

which are also centered at the centroid of the particle and have the maximal possible diameter

Dmin = 2Omin so that they are fully within the particle itself. For ellipsoids their diameter

is the smallest axes. Note that two particles must overlap if their contained spheres overlap.

The e(cid:14)ciency of the EDMD algorithm described in this paper is primarily determined by

the aspect ratio (cid:11) = Dmax=Dmin. The greater the deviation of (cid:11) from unity, the worse

the e(cid:14)ciency because the bounding/contained spheres become worse approximations for the

particles and because of the increasing importance of particle orientations. We propose a

novel near-neighbor list technique for dealing with very aspherical particles, in addition to

the standard cell method.

B. Molecular Dynamics

The goal of our algorithm is to simulate the motion of the particles in time as e(cid:14)ciently as

possible, while taking into account the interactions between the particles. For hard-particle

systems, the only interactions occur during binary collisions of the particles. The goal of

hard-particle molecular dynamics (MD) algorithms is to correctly predict the time-ordered

sequence of particle collisions. Additionally, there may be obstacles such as hard walls with

6

which the particles can collide. Next we brie(cid:13)y introduce the main ideas behind the two

main approaches to hard-particle MD, time-driven and event-driven MD. This preliminary

presentation will be helpful in understanding the rest of this section. Further details on the

event-driven algorithm are given in Section IV.

1. Time Driven MD

The Time-Driven Molecular Dynamics (TDMD) approach is inspired by MD simulations

of systems of soft particles (i.e., particles interacting with a continuous interaction potential).

It has been adapted also to the simulation of hard-particle systems, particularly nonspherical

particles [2, 28], mainly because of its simplicity. In this approach, all of the particles are

displaced synchronously in small time steps (cid:1)t and a check for overlap between the particles

is done. If any two particles overlap, time is rolled back until the approximate moment of

initial overlap, i.e., the time of collision, and the collision of the particles is processed (i.e.,

the momenta of the colliding particles are updated), and the simulation continued. The

main disadvantage of this approach is that it is not rigorous, in the sense that collisions may

be missed or the correct ordering of a sequence of successive collisions may be mis-predicted

(particularly in dense systems). To ensure a reasonably correct prediction of the system

dynamics, a very small time step must be used and this is ine(cid:14)cient. Nonetheless, since

only checking for overlap between particles is needed, the simplicity of the method is a very

attractive feature. Additionally, such an approach is parallelizable with the same techniques

as any other MD algorithm (for example, domain decomposition).

2. Event Driven MD

An alternative rigorous approach is to use Event-Driven Molecular Dynamics (EDMD),

based on a rather general model of discrete event-driven simulation. In EDMD, instead of

advancing time independently of the particles as in TDMD, time is advanced from one event

to the next event, where an event is a binary particle collision, or a collision of a particle with

an obstacle (hard wall). Other types of events will be discussed shortly, however, collisions

are the central type of event so we label the approach is more speci(cid:12)cally Collision-Driven

Molecular Dynamics (CDMD). We will however continue to use the abbreviation EDMD

7

since the term event-driven is widely used in the literature.

E(cid:14)cient implementations of EDMD are asynchronous: each particle is at the point in

time when the last event involving it happened. Each particle predicts what its impending

event is and when it is expected to happen. All of these events are entered into a priority

event queue (typically implemented by a heap), which allows for quick extraction of the

next event to happen. The positions and momenta of the particles involved in this event are

updated, the particlesâ€™ next event predicted, the event queue updated, and the simulation

continued with the next event. Sometimes events may be mis-predicted. For example, a

particle i may predict a collision with particle j, but another (third party) particle m may

collide with j before i has time to. A special event called a check needs to be introduced,

and it amounts to simply (re-)predicting the impending event for a given particle. Given

in(cid:12)nite numerical precision, this kind of approach rigorously follows the dynamics of the

system.

The computationally expensive step in EDMD is the prediction of the impending event of

a given particle i (even though asymptotically the event-queue operations dominate). This

typically involves the expensive (especially for nonspherical particles) step of predicting

the time of collision between the particle i and a set of other particles j. In the simplest

approach, one would predict the time of collision between i and all other particles and

choose the smallest one, but a much more e(cid:14)cient approach is described in Section III.

For spheres moving along straight lines, predicting the time of collision merely amounts to

(cid:12)nding the (cid:12)rst positive root (if any) of a quadratic equation, and is very fast. Therefore,

for spherical particles EDMD always outperforms TDMD by orders of magnitude, and it is

rigorous. For nonspherical particles, collision predictions are much more involved, but for

algebraically simple smooth particle shapes it is expected that EDMD will still outperform

TDMD for a wide range of densities. Furthermore, there are systems for which TDMD is

not possible, and one must use EDMD, such as systems of hard line segments [8]. Note

however that the e(cid:14)ciency of the EDMD approach is possible only because the motion of

the particles between events can be predicted a priori, and because binary collisions only

a(cid:11)ect the two colliding particles. In cases when these assumptions are not true, TDMD may

be the only option. Additionally, it is very important to note that the EDMD algorithm

is inherently non-parallelizable due its sequential processing of the events. Some attempts

have been made to parallelize the method [18] by using the locality of the interactions, and

8

very recently actual implementations have appeared [24]. We will defer any discussion of

parallelization to future publications.

C. Boundary Conditions

In this paper we consider MD in a simple bounded simulation domain embedded in a

Euclidean space Ed of dimensionality d. In particular, we focus exclusively on lattice-based

boundaries. This means that the simulation domain, which the particles never leave, is a
parallelepiped de(cid:12)ned by d lattice vectors, (cid:21)1; : : : ; (cid:21)d. The simulation domain, or unit cell,
is a collection of points with d relative coordinates r in the interval [0; 1], and corresponding

Cartesian coordinates

r(E) =

rk(cid:21)k = (cid:3)r;

d

Xk=1

(1)

where (cid:3) is a square invertible matrix representing the lattice, and contains the lattice vec-

tors as columns. The volume of the unit cell is given by the positive determinant j(cid:3)j. As

illustrated in Fig. 1(a), the parameters describing the geometry of a lattice-based bound-

ary separate into components along di(cid:11)erent \dimensions", meaning along di(cid:11)erent lattice

vectors. For example, there are d perpendicular distances Lk between the \left" and \right"
faces of the parallelepiped along (cid:21)k (meaning the two (d (cid:0) 1)-dimensional faces spanned by
all lattice vectors other than (cid:21)k), one for each dimension k = 1; : : : ; d. We assume that in

three dimensions the lattice vectors form a right-handed coordinate system, so each lattice

vector can be identi(cid:12)ed as de(cid:12)ning the x (k = 1), y (k = 2), or z (k = 3) axis.

Additionally, we allow either periodic or hard-wall boundary conditions (BCs) to be

speci(cid:12)ed independently along each dimension, that is, the \left" and \right" faces of the

unit cell along each dimension can either be hard walls or periodic boundaries. The most

commonly used BCs are fully periodic, and one can interpret periodic systems as being on
a topological torus whose distance geometry is determined by the metric tensor G = (cid:3)T (cid:3)

(a \(cid:13)at" torus), or one can interpret periodic systems as being in(cid:12)nite and covering all of

Euclidean space with identical copies of the unit cell and the particles in this unit cell. We

will refer to the particles in the unit cell as original particles and simply identify them with

an integer i = 1; : : : ; N . There are in(cid:12)nitely many image or virtual particles for every original

particle, translated from the original by an integer number of lattice vectors nc 2 Z. We

identify such an image of particle i with a pair of integers (i; v), where the image or virtual

9

identi(cid:12)er v denotes the particular image in question, nc = nc(v). Traditional hard-sphere

algorithms have used the so-called nearest image convention, which assumes that only one

(easy-to-identify) image of a given particle j can overlap particle i and thus nc needs not

be explicitly stored. However, this assumption is wrong for nonspherical particles, where

several images of a given particle j can overlap an original particle i.

One almost never needs to worry about any but the 3d (9 in two, and 27 in three dimen-

sions) images of the unit cell that neighbor the original one ((cid:12)rst neighbors, including the

cell under consideration). We number these images with v = (cid:0)(3d (cid:0) 1)=2; :::; (3d (cid:0) 1)=2,

so that images with opposite ncâ€™s have identi(cid:12)ers of equal magnitude but opposite sign,

nc((cid:0)v) = (cid:0)nc(v), as illustrated in two dimensions in Fig. 1(b). Note that (i; 0) (cid:17) i. When

considering ordered pairs of particles [i; (j; v)], one of the particles, i, is always original, while

the other one, (j; v), can be an image or an original. Due to our choice of image-numbering,

we can alternatively consider every such unordered pair to be composed of particles j and

(i; (cid:0)v), fi; (j; v)g (cid:17) fj; (i; (cid:0)v)g.

1. Boundary Deformation

In our simulations, we use relative coordinates r (i.e., expressed in terms of the lattice

vectors), and likewise relative velocities v, and convert these into their Euclidian representa-

tions r(E) and v(E) when necessary. The relative position of an image particle is r + nc. The

conversion between the two representations adds computational overhead due the matrix-

vector multiplication2 in (1). Some of this overhead can be avoided by only using Euclidean

positions, however, we have chosen to express all positions relative to the lattice. The pri-

mary reason for this choice is that we allow the lattice to deform, that is, we allow for a
lattice velocity _(cid:3). In our algorithms, the lattice can change linearly with time,

even though a more correct approach is to have a constant strain rate

2 Note however that when the lattice is (cid:3) = I, which is the usual choice unless a special unit cell is needed,
all the matrix-vector multiplications become trivial. Our implementation has a special mode for this
simple but important case.

(2)

(cid:1)(cid:3) = _(cid:3)(cid:1)t;

_(cid:15) = _(cid:3)(cid:3)(cid:0)1;

10

that is, to have an exponential time evolution of the lattice,

(cid:3)(t) = exp ( _(cid:15)t) (cid:3)(0):

The identi(cid:12)cation of (cid:15) = ((cid:1)(cid:3)) (cid:3)(cid:0)1 with the macroscopic strain is explained in Ref.
and we choose it to be symmetric, _(cid:15) = _(cid:15)T , to eliminate rotations of the unit cell.

[31],

In our approach, since the positions of the particles are relative to the lattice, the parti-

cles move together with the lattice. This is necessary in order to simulate isotropic systems.

Namely, had the positions of the particles been independent of the lattice and the lattice

deformed, for example, uniformly contracted, the image particles would move with the lat-

tice, but the originals would not, and this would lead to arti(cid:12)cial e(cid:11)ects at the boundary of

the unit cell. However, using relative positions is not without a cost. Consider a particle at

relative position r which moves with constant relative velocity v. Itâ€™s Euclidean position is

a parabola,

r(E)(t) =

(cid:3) + _(cid:3)t

(r + vt) = (cid:3)r +

(cid:3)v + _(cid:3)r

t +

2 _(cid:3)v

(cid:16)

(cid:17)

(cid:16)

(cid:17)

(cid:16)

(cid:17)

t2
2

;

rather than a straight line. We can identify the instantaneous Euclidean position and velocity

as well as the acceleration to be

r(E) = (cid:3)r

v(E) = (cid:3)v + _(cid:3)r

a(E) = 2 _(cid:3)v:

(3)

(4)

(5)

(6)

This complicates, for example, the calculation of the time of collision of two moving spherical

particles. Ordinarily a quadratic equation needs to be solved, but when the lattice deforms,

a quartic equation needs to be solved instead. To our knowledge, our algorithm is the (cid:12)rst

EDMD algorithm to include a deforming boundary.

In our algorithm, the lattice velocity is an externally imposed quantity, and our goal is

to simulate the motion of the particles as the boundary deforms, for example, in order to

study shear banding in systems of ellipsoids [10]. It is the usual case that the boundary

deforms slowly compared to the motion of the particles. As the boundary deforms, the

unit cell becomes less and less orthogonal, and so in long-time simulations some form of

orthogonalization of the unit cell might be necessary (we have not experimented with such

techniques). Previously used constant-shear MD techniques [17] do not have this problem,

11

however, they are also not capable or simulating arbitrary shears and are plagued with

boundary e(cid:11)ects.

Unlike in TDMD, in EDMD it is not possible to couple the motion of the boundary to

all of the particles, as is done in Parinello-Rahman MD [26]. This is because the e(cid:14)ciency

of the method depends critically on the fact that particles move independently between

collisions and that particle collisions only a(cid:11)ect the colliding particles. However, a pseudo-

PRMD approach is possible, in which the lattice velocity is updated after a certain number

of particle collisions, and the simulation is essentially restarted with a new lattice velocity.

We have some preliminary positive experience with such a method. Unit cell dynamics is

also needed to properly study anisotropic liquids, which is very important for nonspherical

particles [15]. A deforming boundary can also be used to model macroscopic strain in

multiscale simulations (for example, to simulate granular (cid:13)ow) in which microscale MD is

used to obtain material properties needed for a macroscopic continuum simulation.

D. EDMD in Di(cid:11)erent Ensembles

Molecular dynamics is often performed in ensembles di(cid:11)erent from the N V E one, and in

particular, constant temperature and constant pressure are often desired. For this purpose,

various thermostats have been developed. However, these are usually designed to be used

with time-driven MD and systems of soft particles. We are in fact aware of no work that

explicitly discusses thermostats for event-driven MD.

Hard particle systems are inherently athermal due to the lack of energy scale, and the

pressure and time scaling are therefore arbitrary. Sophisticated temperature or pressure

thermostats are thus not usually needed.

In particular, simple velocity rescaling can be

used to keep the temperature at the desired value. The average translational kinetic energy

Ek per particle can be calculated and then both the translational and angular velocities

scaled by the factor s =

dkT =2Ek and the simulation essentially restarted3. This kind

of temperature control is needed when, for example, the particles grow or shrink in size,

p

since this leads to nonconservative collision dynamics and an overall heating or cooling of

the system. Although velocity rescaling is simple and convenient, it has serious de(cid:14)ciencies

3 Equipartition of energy is usually maintained by the collision dynamics, and therefore we usually do not

use a di(cid:11)erent scaling for the angular velocities.

12

[11], and a true canonical thermostat may be needed in some applications. For this purpose,

an Andersen thermostat [9] can be included in collision-driven algorithms by considering

the thermostat as a possible collision partner (with an appropriate Poisson distribution

of collision times). We do not include such a stochastic temperature thermostat in our

algorithm explicitly, since we have not used it.

A Parinello-Rahman-like isostress (isopressure) thermostat [26] cannot be directly in-

cluded in collision-driven algorithms, since it implicitly couples the motion of all particles

via the deformation of the unit cell and thus destroys the asynchronous e(cid:14)ciency of collision-

driven approaches. Such a thermostat is often needed, even for hard particles, in simulations

of crystal phases in order to keep the internal stress tensor isotropic and to allow for changes

of the crystal unit cell. We have used constant shear boundary deformations, as described in

Section II C 1, to implement a partial isostress thermostat in which the shear rate is periodi-

cally updated to re(cid:13)ect the asymmetry of the stress tensor. This approach has had a mixed

success and additional work is required to improve it, especially for anisotropic systems of

(aspherical) particles [15].

III. SPEEDING UP THE SEARCH FOR NEIGHBORS

Identifying the near-neighbors of a given particle has the most important impact on

e(cid:14)ciency in almost all simulations of particle systems, particularly when the interparticle

interactions are short-range. In both MC and TDMD algorithms it is important to quickly

identify only the particles that are within the interaction cuto(cid:11) distance lcuto(cid:11) (here distance

is measured in the metric appropriate for the interaction) from a given particle and only

evaluate the force or interaction energy with these particles. Since the number of such near

neighbors is typically a small constant (of the order of 5 (cid:0) 20, strongly increasing with

increasing dimensionality d), this ensures that the computational e(cid:11)ort needed to evaluate

the forces on the particles or potential energy scales linearly with the number of particles

N , as opposed to the quadratic complexity of checking all pairs of particles.

In EDMD

algorithms, it is useless to predict collisions between all pairs of particles since only nearby

particles are actually likely to collide, and in fact N log N scaling can be obtained in EDMD

by only predicting collisions between a given particle and a bounded (small) number of near

neighbors.

13

In this section we describe the traditional cell method for speeding up neighbor search,

and its implementation for lattice-based boundaries. We then propose a novel method based

on the familiar concept of near-neighbor lists, which o(cid:11)ers signi(cid:12)cant computational savings

over the pure cell method for very aspherical particles, as demonstrated numerically in the

second part of this series of papers.

A. The Cell Method

One traditional method for neighbor search in particle systems is the so-called cell method

(see for example Ref. [3]). It consists of partitioning the simulation domain into Nc disjoint

cells and maintaining for each cell a list of all the particles whose centroids are within it.

Then, for a given particle i, only the particles j in the neighboring cells (including periodic

images of cells) of iâ€™s cell are considered neighbors of particle i. The shape of the cells can be

chosen arbitrarily, so long as the union of all cells covers the whole simulation domain, and so

long as for any given cell c one can (easily) identify all neighbor cells cn that contain a point

within Euclidean distance lcuto(cid:11) from a point in c. This enables a rigorous identi(cid:12)cation

of all particles whose centroids are within a given cuto(cid:11) distance from the centroid of a

given particle. The essential aspect of the cell method is that the partitioning into cells

is independent of the motion of the particles, so that even as the particles move one can

continue to rely on using the cells to rigorously identify neighbors in constant time. This is

a unique and necessary strength of the cell method, and all of our simulations use the cell

method in some form, to ensure correctness while maintaining e(cid:14)ciency.

For maximal e(cid:14)ciency, it seems that it is best to choose the cells as small as possible,

but ensuring that only cells which actually share a boundary (i.e., are adjacent) need to

be considered as neighbors. While this is obvious for MC or TDMD simulations, it is not

so obvious for EDMD. For event-driven algorithms, it can be theoretically predicted and

veri(cid:12)ed computationally that it is best to choose the number of cells to be of the order of the

number of particles [30], and computational experiments suggest that there should be about

one particle per cell. For moderately to very dense systems, one should therefore choose the

cells so that the maximal Euclidean distance between two points in the same cell, Lc, is as

close to the largest enclosing sphere diameter Dmax as possible,

Lc = (1 + (cid:15)L) Dmax:

14

We have veri(cid:12)ed this choice to be optimal in our extensive computational experience and

consistently try to maximize the number of cells in all our simulations.

We note that in some simulations the shape of the particles changes. For example, the

Lubachevsky-Stillinger algorithm [20] generates dense packings of particles by performing

an EDMD simulation while the particles expand uniformly (for example, for spheres the

radius O changes linearly with time with a constant expansion rate (cid:13), O(t) = O + (cid:13)t). In

such cases one must ensure that a sphere of diameter Dmax can always enclose any of the

particles in the system. A suitable value for Dmax can be found, for example, by assuming

that the (cid:12)nal packing is the densest possible (or (cid:12)lls space completely if an exact result for

the maximal density is not known). It is also important to note that it is sometimes needed

to (cid:12)nd all particles whose centroids are within a distance larger then Dmax from the centroid

of a given particle. This is not a problem for the cell method, as one can simply include as

many additional cells in the search as needed to guarantee that the search is rigorous. For

example, one may need to include neighbor cells of the neighbor cells (i.e., second-neighbor

cells).

The need to adjust the partitioning of Euclidian space into cells to the shape of the

simulation domain is the most di(cid:14)cult aspect of using the cell-method. Most simulations in

the literature have been done with spherical particles and in cubic simulation domains, and

the partitioning of the simulation domain is a simple Cartesian grid (mesh) of cells, where

each cell is a cube (this is probably an optimal shape of the cells). For other boundary

shapes, one has two options:

1. Continue using a partitioning of Euclidean space that is independent of the shape of

the boundary. This would likely involve enclosing the simulation domain with a cube

and then partitioning the cube into cells (some cells would be outside the domain and

thus wasted). It is even possible to use the cell method with an in(cid:12)nite simulation

domain if hashing techniques are employed [22].

2. Use a cell shape that conforms to the shape of the boundary in some simple way. The

shape of the cells will thus change if the boundary deforms during the simulation.

Both options have their pros and cons.

It may not be possible to use the second one

for very complex boundary shapes. We have used the (cid:12)rst approach to generate packings

of ellipsoids in a spherical container (useful in comparing with experimental results), by

15

enclosing the spherical container in a cube and partitioning that cube into cells. However,

for lattice-based boundaries, we have chosen to use a partitioning of the unit cell into a

possibly non-orthogonal Cartesian grid that conforms to the shape of the unit cell. This
is illustrated in two dimensions in Fig. 3. The unit cell is partitioned into N (c)
k

slabs

along each dimension k = 1; : : : ; d , to obtain a total of Nc =

d

k=1 N (c)

k

identical and

Q

consecutively ((cid:12)rst along dimension 1, then along dimension 2; etc.) numbered parallelepiped
cells. We typically maximize N (c)
k

along each dimension such that the distance between

the two parallel faces of the cells along any dimension is larger then the extent of the

largest particle, Lc = mink Lk > Dmax. Operations in the cell method for lattice-based

boundaries basically remain operations on Cartesian grids, just as if the simulation domain

had been cubic. Note that each cell has 3d neighbors (including itself), which is only 9 in

two, but 27 in three dimensions. As noted earlier, sometimes more then 3 slabs may need

to be checked along certain dimensions, depending on the Euclidean cuto(cid:11) distance for the

neighbor search. For completely periodic boundary conditions, there are other schemes for

partitioning into cells which preserve the orthogonality and compactness of the unit cell

[4], by using alternative choices of the simulation domain. In simulations where the lattice

deforms by large amounts, one can alternatively periodically recompute a well-conditioned

basis for the lattice and restart the simulation with a new choice of lattice vectors.

1. The Cell Method in EDMD

It is useful to brie(cid:13)y sketch the basic ideas of how the cell method is integrated in event-

driven algorithms. The cell partitioning is used to speed up the prediction of the next event

to happen. This event may be a boundary event, which can be a collision of a particle with

a hard-wall, or a particle leaving the unit cell in a periodic system. The event may also be

a binary collision, and each particle predicts collisions only with the particles in the ((cid:12)rst)

neighboring cells of its current cell.

It is clear that a binary collision cannot occur with

a particle not in a neighboring cell until the particle leaves its current cell. Therefore, a

boundary event may be a transfer, where a particleâ€™s centroid leaves its current cell and

goes into another cell. The algorithm predicts and processes transfers in time order with

the other events.

Whenever a particle undergoes a transfer, it must correct its event prediction. In par-

16

ticular, it must predict binary collisions with all the particles in the new neighbor cells. If

one maintains separately the prediction for the next boundary and the next binary collision,

then upon a transfer one can reuse the old binary collision prediction and only calculate

the collision time with particles in the neighbor cells which were not checked earlier [30].
This cuts the number of neighbor cells to process from 3d to 3d(cid:0)1, which can save up to 2=3

in computational e(cid:11)ort in three dimensions. In our algorithm we originally maintained the

binary collision prediction separately and reused it whenever possible, however, since the

neighbor-list method described next is usually superior in practice, we no longer try to reuse

previous binary collisions.

B. The Near-Neighbor List (NNLs) Method

The cell method is the method used in all EDMD algorithms that we are aware of. An

exception is the algorithm of Ref. [14], but this algorithm is rather di(cid:11)erent from the classical

EDMD algorithms (and from our algorithm) in more than this respect. There is a preference

for the cell method in EDMD because it is very easy to incorporate it into the algorithm,

while still maintaining a rigorously provable correct execution of the event sequence, given

su(cid:14)cient numerical precision. For monodispersed (equal) spherical particles, particularly

at moderate densities, the cell method is truly the best approach. However, for aspherical

particles whose aspect ratio is far from 1, the cell method becomes ine(cid:14)cient. This is because

one cannot choose the cells small enough to ensure an average of about 1 particle per cell.

Instead, due to the large Dmax, there need to be very few (large) cells which contain many

particles and so little computational e(cid:11)ort is saved by using the cells. The same is true

even for spheres when large polydispersity is present since the cells need to be at least as

large as the largest sphere in the system, and therefore there can be many small spheres

inside one cell. A more complicated hierarchical cell structure (quadtree or octree) can be

used for very polydisperse packings, but such an approach does not directly generalize to

nonspherical particles.

In TDMD, a more widely used neighbor search method is the method of near-neighbor

lists (NNLs) (see for example Ref. [3]). In this method, each particle has a list of its near

neighbors, i.e., particles which are in close proximity (for example, within the cuto(cid:11) for

the interaction potential). As the particles move around the lists need to be updated, and

17

this is often done heuristically. Since the particles displace little from time step to time

step in TDMD, the lists need to be updated only after many time steps (especially for

dense systems). NNLs are not easy to use within EDMD because of the necessity to ensure

correctness of the algorithm rigorously.

If the order of events is not predicted correctly,

the algorithm will typically fail with error conditions such as endless collision cycles between

several particles. However, it is easily recognized that in order to e(cid:14)ciently treat nonspherical

particles it is necessary to combine neighbor lists with the cell method. We now describe

how this can be accomplished while maintaining a provably correct prediction of the collision

sequence.

The main drawback of the cell method is that the shape of the cells is not adjusted to

the shape of the particles, for example, elongated or squashed particles, but cubic cells.

The main advantage, on the other hand, is that the partitioning into cells is static and

independent of the motion of the particles. To correct for the drawback, we must compro-

mise on the advantage: The partitioning into \cells" must be updated from time to time to

re(cid:13)ect the motion of the particles, if we are to have any hope of having cells which take

into account the shape of the particles. The idea is the following: Surround each particle i

with a bounding neighborhood N (i), so that the particle is completely inside its bounding

neighborhood, and the shape of the neighborhood is in some sense sensitive to the position

and shape of the particle (for example, it should be elongated approximately along the same

direction as the ellipsoid). Then, consider any two particles whose neighborhoods overlap

to be near neighbors, and only calculate interaction potentials or check for collisions be-

tween such pairs. Each particle then stores a list of interactions in its near-neighbor list

NNL(i), which is equivalent to each bounding neighborhood storing a list of neighborhoods

with which it overlaps. This is illustrated for disks by using disks as the bounding neigh-

borhoods in Fig. 4. Note that the cell method, as described earlier, must be used when

(re-)building the NNLs, since overlap between neighborhoods cannot be checked e(cid:14)ciently

otherwise. Building and maintaining the NNLs is expensive and dominates the computation

for very aspherical particles. Finally, we note that the choice of the shape of the bounding

neighborhoods and the exact way one constructs the NNLs is somewhat of a design choice.

The necessary invariant is that each particle be completely contained inside its bounding

neighborhood and that there be an interaction in the NNLs for each pair of overlapping

neighborhoods.

18

In this paper we describe a speci(cid:12)c conceptually simple approach which applies to hard

particles of any shape and has worked well in practice. In our algorithm, the shape of N (i) is

the same as the shape of particle i, but scaled uniformly with some scaling factor (cid:22)neigh > 1.

Additionally, N (i) has the same centroid as i, at least at the instant in time when NNL(i)

is constructed (after which the particle may displace). This is illustrated for ellipses in Fig.

4. One wants to have the bounding neighborhood N (i) as large as possible so that there

is more room for the particle i to move without the need to rebuild its NNL. However, the

larger the neighborhood, the more neighbors there will be to examine. The optimal balance,

as determined by the choice of (cid:22)neigh, is studied numerically in the second part of this series

of papers.

It is important to note that it would most likely be better to consider N (i)

to be the set of all points that are within a given distance from the surface of particle i,

especially for very nonspherical particles. This is because scaling a very elongated particle

by a given factor (cid:22) produces unnecessarily long neighborhoods, which increases the cost of

using the cell method to construct the neighbor lists. However, evaluating point-to-surface

or suface-to-surface distances is quite nontrivial even for ellipsoids, and also the geometrical

reasoning is obscured. On the other hand, using a bounding neighborhood which has the

same shape as the particle is very intuitive and also e(cid:14)cient for ellipsoids, as we show in the

second paper in this series.

1. The NNL Method in EDMD

Once the NNLs are built, one no longer needs to use the cell method, so long as all particles

are still completely contained within their bounding neighborhoods. As time progresses, a

particle may protrude outside its neighborhood, and in this case the NNLs need to be

updated accordingly, using the fail-safe cell method. Details of this update will be given

later. Therefore, when using NNLs, instead of transfers, another kind of event needs to be

included: a \collision" with its bounding neighborhood. When using NNLs, transfers do

not need to be handled at all. Namely, instead of using the cell method for the particles

themselves, it should be used on the bounding neighborhoods. Each cell keeps a list of the

bounding neighborhoods whose centroids it contains. Hard-walls are handled by including

hard walls as neighbors in the NNLs of the particles whose bounding neighborhoods intersect

a hard wall. At present we do not try to reuse any previous binary collisions when rebuilding

19

neighbor lists because dealing with such reuse is rather complicated.

An additional complication when using NNLs arises when the boundary is deforming.

Since in our approach all positional coordinates are expressed in relation to the (possibly de-

forming) lattice, the neighborhoods are not stationary but move together with the boundary.

This may lead to originally disjoint neighborhoods overlapping later on. In order to ensure

correctness of the neighbor search in such cases, one can add a \safety cushion" around each

bounding neighborhood N (i). Speci(cid:12)cally, two particles are to be considered neighbors if

their bounding neighborhoods overlap when scaled by a common scaling factor 1 + (cid:15)N , where

(cid:15)N > 0 is the relative size of the safety cushion. The NNLs need to be rebuilt completely

whenever the boundary deformation becomes too large, because of the possibility of new

neighborhood overlap. In this context, a measure of how much the boundary has deformed

is given by the relative amount that Euclidean distances have changed due to the boundary

deformation.

Consider a periodic system and two points with relative displacement r, measured in
lattice vectors. The Euclidean distance between them is l2 = rT Gr, where G = (cid:3)T (cid:3) is a

metric tensor. At a later time (cid:1)t, the distance changes, and the largest relative contraction

in Euclidean distance between any two points is given by:

2

(l + (cid:1)l)
l

(cid:21)

min

r (cid:20)

= min
rE

E (I + (cid:15)(cid:1)t)T (I + (cid:15)(cid:1)t) rE
rT
ErT
rT
E

= (cid:21)min

(I + (cid:15)(cid:1)t)2
(cid:2)

(cid:3)

;

where rE = (cid:3)r and (cid:21)min denotes the minimal eigenvalue of a symmetric matrix. There-

fore, the Euclidean distance between the centroids of two neighborhoods would not have

contracted by more then a factor of (cid:21)min

(I + (cid:15)(cid:1)t)2

. In light of this observation, a rea-

sonable heuristic approach is to periodically check the magnitude of the smallest eigenvalue
of (I + (cid:15)(cid:1)t)2, and rebuild the NNLs completely whenever it deviates from unity by more

(cid:2)

(cid:3)

then a few (as determined heuristically via experimentation) multiples of (cid:15)N . Since it is

reasonable to assume that the boundary deforms slowly compared to the particles, these

kinds of updates will happen infrequently. This approach seems to work well in practice. In

EDMD a rigorous approach is also possible, by predicting the (cid:12)rst instance in time when

two non-overlapping bounding neighborhoods (cid:12)rst overlap, and including this as a special

event in the event queue. When this event is at the top of the queue, the simulation is

essentially restarted from the current point in time. However, such an approach does not

work in TDMD, and we have not found the practical need for such a complicated scheme

20

either.

C. Very Aspherical Particles

Using the traditional cell method when rebuilding the NNLs is the computational bot-

tleneck for very aspherical particles, as demonstrated in the second paper of this series. To

really obtain a fast yet rigorously correct event-driven algorithm for very aspherical particles

the traditional cell method needs to be either abandoned or modi(cid:12)ed. It is clear that any

neighbor search mechanism which only uses the centroids cannot be e(cid:14)cient. Although in

a sense Ref.

[5] studies the worst case of (cid:11) ! 1 (needles, and similarly for platelets), it

does not mention any additional techniques to handle the fact that as many as 50 needles

can be in one cell in the reported simulations. This is probably because at that time only

small systems (N = 100 (cid:0) 500) could be studied, for which the cell method does not o(cid:11)er

big savings even for spheres.

21

Figure 5: A small periodic packing of ellipses of aspect ratio (cid:11) = 10 illustrating the use of bounding

sphere complexes. Each particle i (darkest shade) is bounded by its neighborhood (lighter shade)

N (i), which is itself bounded by a collection of 10 disks BSC(i). A bounding neighborhood N (j)

may overlap with N (i) if some of the bounding disks of particles j and i overlap. Therefore the

usual cell grid (also shown) can be used in the search for neighbors to add to NNL(i).

Image

particles are shown in a lighter shade.

The approach we have implemented is to use several spheres to bound each particle,

instead of just one large bounding sphere. We will refer to this collection of bounding

spheres as the bounding sphere complex (BSC). For the purposes of neighbor search, we

still continue to use the cell method, however, we use the cell method on the collection

of bounding spheres, not on the particles themselves. That is, we bin all of the bounding

spheres in the cells, and the minimal Euclidian length of a cell is at least as large as the

22

largest diameter of a bounding sphere. By increasing the number of bounding spheres per

particle one can make the cells smaller. When searching for the neighbors of a given particle,

one looks at all of its bounding spheres and their neighboring bounding spheres, and then

checks whether the particles themselves are neighbors. This slightly complicates the search

for neighbors, but the search can be optimized so that a given pair of particles is only checked

once, rather then being checked for every pair of bounding spheres that they may share. It is

hard to maintain the binning of the bounding spheres in cells as particles move. It is therefore

essential to combine using BSCs with using NNLs. Each bounding neighborhood N (i) is

bounded by BSC(i), that is, N (i) is completely contained in the union of the bounding

spheres in BSC(i). The binning of the bounding spheres is only updated when NNL(i) is

updated, and particle i is free to move inside N (i) without possibility of overlapping with a

particle not in NNL(i). Using BSCs in two dimensions is illustrated in Fig. 5.

In our implementation, we use relative positions and radii for the spheres in BSC(i),

expressed in a coordinate system in which particle iâ€™s orientation is aligned with the global

coordinate system and the radius of its bounding sphere is unity. This enables us to not

have to update the above quantities as the particle moves and changes shape, and also to

share them between particles of identical shapes using pointers. When updating N (i), we

can easily calculate the absolute (Euclidian) positions and radii of the bounding spheres

from the relative ones.

In two dimensions, for very elongated objects, it is relatively easy to construct bounding

complexes, however, this is not so easy in three dimensions, even though there are general

methods (taken from computational geometry) for (cid:12)nding a good approximation to a particle

shape with a few spheres [13]. We expect that there will be an optimal number of spheres

NS to use, this number increasing as the aspect ratio increases, however, it is not clear how

to construct optimal BSCs. The approach we have implemented is to (cid:12)rst bound each ellipse

or ellipsoid in an orthogonal parallelepiped (rectangle in two dimensions), and then use a

subset of a simple cubic lattice cover (a collection of identical spheres whose union covers all

of Euclidian space) to bound (cover) the orthogonal parallelepiped. This kind of approach is

far from optimal (for example, the lowest density sphere cover in three dimensions is given

by a body-centered lattice of spheres), but it is very simple and works relatively well for

su(cid:14)ciently aspherical particles. This is illustrated in three dimensions for prolate and oblate

ellipsoids in Fig. 6. As can be seen from the (cid:12)gure, it seems hard, if not impossible, to

23

construct BSCs with few small spheres for (cid:13)at (oblate) particles. Future research is needed

to (cid:12)nd a way to speed neighbor search for very oblate particles, and a promising direction to

investigate is hierarchical bounding sphere complexes. In the second paper in this series we

demonstrate that using BSCs in conjunction with NNLs signi(cid:12)cantly improve the speed of

the EDMD algorithm for very elongated (prolate) particles. Note that using a large number

of small bounding spheres (for very aspherical particles) requires a signi(cid:12)cant increase in the

number of cells, and to save memory hashing may need to be used when manipulating the

cell partitioning [25].

Figure 6: Bounding sphere complexes for spheroids of aspect ratio (cid:11) = 5. The prolate particle has

5 bounding spheres, but the oblate one has 25 bounding spheres.

IV. EDMD ALGORITHM

In this section, we describe our EDMD algorithm in signi(cid:12)cant detail, in the hope that

this will prove very useful to other researchers implementing similar methods. Starting from

a brief history of the main ideas used in the algorithm and a description of the basic notation,

we proceed to give detailed descriptions of each step in the algorithm in the form of pseudo-

codes. We (cid:12)rst explain the top level event loop and its most involved step of predicting the

impending event for a given particle. We then focus on binary collisions and boundary events

separately, and (cid:12)nally describe algorithms for maintaining NNLs in a dynamic environment.

Some of the steps of the algorithm, such as predicting the time of collision of two particles

24

or processing a binary collision, depend on the particular particle shape in question and are

illustrated speci(cid:12)cally for ellipsoids in the second part of this series of papers.

A. History

We brie(cid:13)y summarize some of the previous work on EDMD algorithms. Although this

has been done in other publications, we feel indebted to many authors whose ideas we have

used and combined together to produce our algorithm, and would like to acknowledge them.

The very (cid:12)rst MD simulation used an event-driven algorithm [1], and since those early

attempts the core of an e(cid:14)cient EDMD algorithm for spherical particles, entailing a com-

bination of delayed updates for the particles, the cell method and using a priority queue

for the events, has been developed [7, 27]. Our approach borrows heavily from the EDMD

algorithm developed by Lubachevsky [19]. We do not use a double-bu(cid:11)ering technique as

does Lubachevsky, following Ref. [16], and incorporate additional techniques developed by

other authors.

One of the controversial questions in the history of EDMD is how many event predictions

to retain for each particle i? As Ref. [16] demonstrates, it is best to use a heap (complete

binary search tree) for the priority event queue, and we follow this approach. It seems clear

that only the impending prediction for each particle should be put in the event queue (i.e.,

the size of the heap is equal to N ), but this prediction may be invalidated later (due to

a third-party event, for example). In such cases, it may be possible to reuse some of the

other previously-predicted binary collisions for i, for example, the one scheduled with the

second-smallest time [23, 29]. This requires additional memory for storing more predictions

per particle and adds complexity to the algorithm. We have adapted the conclusion of Ref.

[30] that this complexity is not justi(cid:12)ed from an e(cid:14)ciency standpoint. Ref.

[23] makes

the important observation that after a transfer fewer cells need to be checked for collisions.

The authors of Ref.

[30] thus predict and store separately the next binary collision and

the next transfer for each particle, and only insert the one with the smaller time into the

event heap. More exotic EDMD algorithms, for example, aimed at increased simplicity or

ease of vectorization [14], have been developed. We build on these previous developments

and combine neighbor-list techniques traditionally used in TDMD to develop a novel EDMD

algorithm speci(cid:12)cally tailored to systems of nonspherical particles at relatively high densities.

25

B. Notation

As explained above, the EDMD algorithm consists of processing a sequence of time-

ordered events. Each particle must store some basic information needed to predict and

process the events. An event (te; pe) is speci(cid:12)ed by giving the predicted time of occurrence

te and the partner pe. A special type of an event is a binary collision [tc; (pc; vc)], determined

by specifying the time of collision tc (cid:17) te and the partner in the event (pc (cid:17) pe; vc). The

primary use of the image (virtual) identi(cid:12)er vc is to distinguish between images of a given

particle when periodic boundary conditions are used. Note that the collision schedules must

be kept symmetric at all times, that is, if particle i has an impending event with (j; v), then

particle j must have an impending event with (i; (cid:0)v). Although the cell a particle belongs

to can be determined from the position of its centroid, this is di(cid:14)cult to do exactly when a

particle is near the boundary of a cell due to roundo(cid:11) errors (possible tricks to avoid such

problems include adding a cushion around each cell and not considering a transfer until the

particle is su(cid:14)ciently outside the cell [16]). We have chosen to explicitly store and maintain

the cell that a particle, a bounding neighborhood of a particle, or a bounding sphere, belongs

to (as determined by the corresponding centroid).

In summary, for each particle i = 1; : : : ; N , we store:

1. The predicted impending event (te; pe; vc) along with any other information which can

help process the event or collision more e(cid:14)ciently should it actually happen later.

2. The last update time t.

3. The state of the particle at time t, including:

(a) Its con(cid:12)guration, including the relative position of the centroid r and any addi-

tional con(cid:12)guration (such as orientation) q, as well as the particle shape (such

as radius, semiaxes, etc.) O. Note that O may be shared among many particles

using pointers (for example, all particles have the same shape at all times in a

monodisperse packing) and thus not be updated to time t but still be at time

zero4.

4 We have implemented a di(cid:11)erent approach for systems with a few types of particles (monodisperse,
bidisperse, etc.), for which we store the particle shape information separately from the particles and share
it among them, and polydisperse systems in which each particle has a (potentially) di(cid:11)erent shape, for
which we store the particle shape together with the rest of the particle state.

26

(b) The particle motion, including the relative velocity of the centroid v = _r and
additional (such as angular) velocity ! representing _q. Also included in the

motion is the rate of deformation of the particle shape (cid:0) (possibly shared among

di(cid:11)erent particles).

(c) The particle cell c, to which r belongs, if not using NNLs.

4. Dynamical parameters, such as particle mass or moment of inertia (possible shared

with other particles).

5. If using NNLs, the con(cid:12)guration of the (immobile) bounding neighborhood N (i), rN

and qN , its shape ON , as well as the cell c to which rN belongs.

6. If using BSCs in addition to NNLs:

(a) The relative positions rBS

and relative radii OBS

j

, j = 1; : : : ; NBS, of its NBS

j

bounding spheres, along with the largest BS radius OBS

max = maxj OBS

j

. These are

expressed relative to the position and size of N (i).

(b) The cell cBS

j

that rBS

j

belongs to, j = 1; : : : ; NBS.

For each of these quantities, we will usually explicitly indicate the particle to which they

pertain, for example, t(i) will denote the time of particle i.

1. Event Identi(cid:12)ers

Each particle must predict its impending event, and there are several di(cid:11)erent basic types

of events: binary collisions (the primary type of event), wall collisions (i.e., collisions with

a boundary of the simulation domain), collisions with a bounding neighborhood (i.e., a

particle leaving the interior of its bounding neighborhood), transfers (between cells), and

checks (re-predicting the impending event). Additionally, several di(cid:11)erent types of checks

can be distinguished, depending on why a check was required and whether the motion of the

particle changed (in which case old predictions are invalid) or not (in which old predictions

may be reused). We consider transfers and wall collisions together as boundary events (or

boundary \collisions"), since their prediction and processing is very similar (especially for

periodic BCs). The exact cell wall through which the particle exits the (unit) cell, or the

wall with which the particle collides, is identi(cid:12)ed with an integer w, which is negative if the

event is with a wall of the unit cell (boundary).

27

In our implementation, the type of a predicted event for a particle i is distinguished based

on the event partner p (possibly including an image identi(cid:12)er v):

0 (cid:20) p (cid:20) N A binary collision between particles i and (p; v), where v is the virtual identi(cid:12)er

of the partner.

p = (cid:0)1 A check (update) after an event occured that did not alter the motion of i.

p > 2N Transfer between cells, i.e., \collision" with wall w = p (cid:0) 2N , w > 0.

p < (cid:0)2N Wall collision with wall w = p + 2N , w < 0, which can be a real hard wall or the

boundary of the unit cell.

of particle i has changed).

N < p (cid:20) 2N Check after binary collision with partner (j; (cid:0)v), where j = p (cid:0) N (the motion

p = 0 Check for particle i after an event occured which altered the motion of i.

p = 1 Collision with the bounding neighborhood N (i).

The range (cid:0)2N (cid:20) p < 0 is reserved for future (parallel implementation) uses. Of course,

one can also store the partner as two integers, one indicating the type of event and the other

identifying the partner, however, the above approach saves space.

C. Processing the Current Event

Algorithm 1 represents the main event loop in the EDMD algorithm, which processes

events one after the other in the order they occur and advances the global time t accordingly.

It uses a collection of other auxiliary steps, the algorithms of which are given in what follows.

Note that when processing the collision of particle i with particle (j; v), we also update

particle j, and later, when processing the same collision but as a collision of j and (i; (cid:0)v),

we skip the update. Also, note that when using NNLs, there are two options: Completely

rebuild the NNLs as soon as some particle i collides with its neighborhood, or, rebuild only

the neighbor list NNL(i). We discuss the advantages and disadvantages of each approach

and compare their practical performance in the second paper in this series.

28

Algorithm 1: Process the next event in the event heap.

1. Delete (pop) the top of the event queue (heap) to (cid:12)nd the next particle i to have an event

with pe(i) at te(i).

2. Perform global checks to ensure the validity of the event prediction. For example:

(a) If the boundary is deforming, and if at time te(i) the cell length Lc is not larger then

the largest enclosing sphere diameter Dmax, Lc [te(i)] (cid:20) Dmax [te(i)], then restart the

simulation:

i. Synchronize all particles (Algorithm 2).

ii. Repartition the simulation box to increase the length Lc (for example, for lattice

boundaries, increase the appropriate N (c)

k ).

iii. Re-bin the particles into the new cells based on the positions of their centroids.

(b) If using NNLs and the NNLs are no longer valid (for example, due to boundary defor-

iv. Reset the event schedule (Algorithm 3).

v. Go back to step 1.

mation), then:

i. Synchronize all particles.

ii. Rebuild the NNLs (Algorithm 8).

iii. Reset the event schedule.

iv. Go back to step 1.

3. If the boundary is deforming, update its shape. For example, for lattice-based boundaries,

set (cid:3)   (cid:3) + _(cid:3) [te(i) (cid:0) t].

4. Advance the global simulation time t   te(i).

5. If the event to process is not a check after a binary collision, then update the con(cid:12)guration

of particle i to time t (for example, r(i)   r(i) + [t (cid:0) t(i)] vi), and set t(i)   t.

6. If using NNLs and event is a collision with a bounding neighborhood, then:

(a) If completely rebuilding NNLs, then declare NNLs invalid and execute step 2b.

(b) Else, record a snapshot of the current shape of particle i (recall that this may be shared

with other particles) in Oi and rebuild the NNL of particle i (Algorithm 9).

29

7. If the event is a wall collision or cell transfer, then:

(a) If pe(i) > 0 then set w   pe(i) (cid:0) 2N (transfer).

(b) Else set w   pe(i) + 2N (wall collision).

(c) Process the boundary event with \wall" w (Algorithm 7).

8. If the event is a binary collision, then:

(a) Update the con(cid:12)guration of particle j = pe(i) to time t and set t(j)   t and pe(j)  

(b) Process the binary collision between i and j (see speci(cid:12)c algorithm for ellipsoids in

N + i (mark jâ€™s event as a check).

second paper in this series).

9. Predict the next collision and event for particle i (Algorithm 4).

10. Insert particle i back into the event heap with key te(i).

11. Terminate the simulation or go back to step 1.

Because EDMD is asynchronous, it is often necessary to bring all the particles to the same

point in time (synchronize) and obtain a snapshot of the system at the current time t. This

is done with Algorithm 2. Note that we reset the time to t = 0 after such a synchronization

step. Another step which appears frequently is to reset all the future event predictions and

start afresh, typically after a synchronization.

In particular this needs to be done when

initializing the algorithm. The steps to do this are outlined in Algorithm 3.

Algorithm 2 Synchronize all particles to the current simulation time t.

1. If t = 0 then return.

2. For all particles i = 1; : : : ; N do:

(a) Update the con(cid:12)guration of particle i to time t.

(b) Set te(i)   te(i) (cid:0) t, tc(i)   tc(i) (cid:0) t and t(i)   0.

3. Update the shapes of all particles to time t.

4. Store the total elapsed time T   T + t and set t   0.

30

Algorithm 3 Reset the schedule of events.

1. Reset the event heap to empty

2. For all particles i = 1; : : : ; N do:

(a) Set pe(i); pc(i)   0 and te(i); tc(i)   0.

(b) Insert particle i into the event heap with key te(i).

D. Predicting The Next Event

The most important and most involved step in the event loop is predicting the next

event to happen to a given particle, possibly right after another event has been processed.

Algorithm 4 outlines this process. Note that it is likely possible to further extend and

improve this particular step by better separating motion-altering from motion-preserving

events and improving the reuse of previous event predictions.

Algorithm 4: Predict the next binary collision and event for particle i, after an event

involving i happened.

1. If not using NNLs, then:

(a) Initialize tw   1 and ~tw   1 and set w   0.

(b) Predict the next boundary event (wall collision or transfer) time tw and partner \wall"

w for particle i, if any, by looking at all of the boundaries of c(i) (Algorithm 6). If an

exact prediction could not be made (for example, if a hard wall was involved and the

search was terminated prematurely), calculate a time ~tw up to which a boundary event

is guaranteed not to happen and set w   0.

(c) If w = 0, then force a check at time ~tw, pe(i)   (cid:0)1 and te(i)   ~tw,

(d) else predict te(i)   tw and:

i. If w < 0 then set pe(i)   w (cid:0) 2N ,

ii. else set pe(i)   w + 2N .

(e) If a hard-wall prediction was made, store any necessary information needed to process

the collision more e(cid:14)ciently later (for example, store (cid:21) in the case of ellipsoids, as

explained in the second paper in this series).

(f) For all particles (j; v) in the cells in the (cid:12)rst neighborhood of c(i), execute step 4,

31

2. else if using NNLs, then:

(a) Predict the time tN particle i will protrude outside of (collide with) its bounding neigh-

borhood N (i), limiting the length of the search interval to te(i). If an exact prediction

is not possible, calculate a time ~tN before which i is completely contained in N (i).

(b) If tN was calculated and tN < te(i), then record:

i. Set pe(i)   1 and te(i)   tN .

ii. Potentially store any additional information about this collision for particle i,

(c) else if ~tN was calculated and ~tN < te(i) then force a new prediction for particle i at

time ~tN , pe(i)   (cid:0)1 and te(i)   ~tN .

(d) For all hard walls w in NNL(i), predict the time of collision tw. If an exact prediction

could not be made, calculate a time ~tw up to which the collision is guaranteed not to

happen.

(e) If tw was calculated and tw < te(i), then record:

i. Set te(i)   tw and pe(i)   w (cid:0) 2N .

ii. Potentially store any necessary information needed to process the wall collision

more e(cid:14)ciently later,

(f) else if ~tw was calculated and ~tw < te(i), then force a check pe(i)   (cid:0)1 and te(i)   ~tw.

(g) For all particles (j; v) in NNL(i), execute step 4,

3. Skip step 4.

4. Predict the time of collision between particles i and (j; v):

(a) Predict if i and (j; v) will collide during a time interval of length min [te(i); te(j)] and if

yes, calculate the time of collision tc, or calculate a time ~tc < tc before which a collision

will not happen (see speci(cid:12)c algorithm for ellipsoids in the second paper in this series).

(b) If tc was calculated and tc < min [te(i); te(j)], then record this collision as the next

predicted binary collision for particle i:

i. Set pe(i)   j, v(i)   v and te(i)   tc.

ii. Potentially store any additional information about this collision for particle i (for

example, (cid:21) in the case of ellipsoids),

32

(c) else if ~tc was calculated and ~tc < te(i) then force a new prediction for particle i at time

~tc, pe(i)   (cid:0)1 and te(i)   ~tc.

5. If 0 < pe(i) (cid:20) N then let j = pe(i) (a new collision partner was found), and:

(a) If the involved third-party m = pe(j) is a real particle, 0 < m (cid:20) N and m 6= i, then

invalidate the third party collision prediction, pe(m)   (cid:0)1.

(b) Ensure that the collision predictions are symmetric by setting pe(j)   i, v(j) = (cid:0)v(i)

and te(j)   te(i). Also copy any additional information about the predicted collision

to particle j as well (in the case of ellipsoids, this involves storing (1 (cid:0) (cid:21)) for particle

j).

(c) Update the key of j in the event heap to te(j).

E. Binary Collisions

The two main steps in dealing with binary collisions is predicting them and processing

them. Processing a collision is inherently tied to the shape of the particle. We give a generic

speci(cid:12)cation of how to predict binary collisions between particles in Algorithm 5, and a

speci(cid:12)c implementation for ellipsoids is given in the second part of this series of papers.

In this section we focus on lattice-based boundaries and give a prescription for predicting

and processing boundary events (transfers and wall collisions).

F. Boundary Events

1. Prediction

When NNLs are not used, one must check all the boundaries of the current particle cell

c(i) and (cid:12)nd the (cid:12)rst time the particle leaves the cell or collides with a hard wall, if any.

We do not give details for predicting or processing hard-wall collisions in this paper. For

lattice based boundaries, the prediction of the next boundary event proceeds independently

along each dimension, and then the smallest of the d event times is selected, as illustrated

in Algorithm 6.

33

Algorithm 5 Predict the ((cid:12)rst) time of collision between particles i and (j; v), tc. If
prediction cannot be veri(cid:12)ed, return a time ~tc before which a collision will not happen.

Possibly also return additional information about the collision.

1. Convert v into a virtual displacement of particle j in terms of unit cells, (cid:1)rj (cid:17) nc, as

2. Calculate the current con(cid:12)guration of the particles i and j, for example, the positions of

discussed in Section II C.

their centroids,

ri   r(i) + [t (cid:0) t(i)] vi

rj   r(j) + [t (cid:0) t(j)] vj + (cid:1)rj;

and their current orientations for nonspherical particles.

3. If the shape of the particles is changing, calculate the current shape of i and j.

4. Eliminate any further use of relative positions in the procedure by calculating the current

Euclidean positions, velocities and accelerations of the particles using Eqs. (4-6) and the

above ri and rj.

5. Calculate the collision time tc or ~tc of two moving and possibly deforming particles of the

given initial shapes and con(cid:12)gurations and initial Euclidean positions, velocities and accel-

erations, assuming a force-free motion starting at time zero. Optionally collect additional

information needed to process the collision faster if it actually happens. See the speci(cid:12)c

algorithm for ellipsoids in the second paper in this series.

6. Correct the prediction to account for the current time, tc   tc + t or ~tc   ~tc + t.

2. Processing

Processing the boundary events amounts to little work when the event is a transfer from

one cell to another. For periodic BCs however, additional work occurs when the particle

crosses the boundary of the unit cell (i.e., the simulation domain), since in this case it must

be translated by a lattice vector in order to return it back into the unit cell. Considerably

more complicated is the processing of collisions with hard walls, especially for nonspherical

particles or when the lattice velocity is nonzero, however, we do not give the details of these

steps in Algorithm 7.

34

Algorithm 6 Predict the next wall event with \partner" w for particle i moving with

relative velocity v(i) and the time of occurrence tw, for a lattice-based boundary. The sign

of w determines the type of event: w > 0 speci(cid:12)es that particle i leaves its cell c(i) through

one of the cell boundaries, while w < 0 speci(cid:12)es that the particle collides with one of the

hard walls or crosses one of the boundaries of a unit cell and leaves its bin, for a periodic

system. The value of jwj determines the exact cell boundary or wall.

1. Convert the cell identi(cid:12)er 1 (cid:20) c(i) (cid:20) Nc into a d-dimensional vector giving the positions of

the cell in the Cartesian grid of cells, 1 (cid:20) g(c) (cid:20) N(c).

2. For all dimensions, k = 1; : : : ; d, do:

(a) Predict the time when the particle centroid will cross a wall of c(i) along dimension k:

i. If vk(i) = [v(i)]k > 0 (particle will exit on the \right" side of the bin), then

A. Set wk   2 (k (cid:0) 1) + 2 and

B. If boundary is periodic along dimension k and g(c)

k , then set wk   (cid:0)wk,

tk  

k (cid:0) N (c)
g(c)

k rk(i)

h

=

i

h

:

N (c)

k vk(i)

i
k = N (c)

ii. else if vk(i) < 0 (particle will exit on the \left" side of the bin), then

A. Set wk   2 (k (cid:0) 1) + 1, and

h
B. If boundary is periodic along dimension k and g(c)

i

h

tk =

N (c)

k rk(i) (cid:0) g(c)

k + 1

=

N (c)

k vk(i)

:

i

k = 1, then set wk   (cid:0)wk,

iii. else set tk   1 and wk   0.

(b) If boundary is not periodic along dimension k, then also predict the time of collision

with the hard wall boundaries along dimension k, assuming that the particle starts

from zero time:

i. If g(c)
k, t(hw)
k
ii. If g(c)
t(hw)
k

k = N (c)

k , predict time of collision with the \right" hard wall along dimension
k < tk, then set tk   t(hw)

and wk   (cid:0) [2 (k (cid:0) 1) + 2].

k

. If t(hw)

k = 1, predict time of collision with the \left" hard wall along dimension k,
. If t(hw)

k < tk, then set tk   t(hw)

and wk   (cid:0) [2 (k (cid:0) 1) + 1].

k

3. Find the dimension ~k with the smallest tk and return tw = t(i) + t~k and w = w~k.

35

Algorithm 7 Process the boundary event (transfer or collision with a hard-wall) of

particle i with wall w, assuming a lattice-based boundary.

1. From w, (cid:12)nd the dimension k along which the event happens and the side (\left" or \right").

2. If this is a boundary event, w < 0, then:

(a) If the boundary is periodic along k, then:

i. Shift the particle by a unit cell, rk(i)   rk(i) + 1 if particle is exiting its cell to

the right, or rk(i)   rk(i) (cid:0) 1 if exiting to the left.

ii. Let j = pc(i). If 0 < j (cid:20) N , correct the virtual identi(cid:12)ers for the predicted collision

between i and j, v(i) and v(j), to account for the shift in step 2(a)i.

iii. Pretend that this is a simple transfer, w   2N (cid:0) w,

(b) else, process the collision of the particle with the hard-wall. This will typically involve

calculating the Euclidean position and velocity of the particle, calculating the exchange

of momentum between the particle and the wall, calculating the new Euclidean velocity

of the particle v(E) (and also ! if necessary), converting back to relative velocity, and

updating the velocity v (and !).

3. If this is a transfer (note step 2(a)iii above), w > 0, then update the cell of the particle c(i)

and move the particle from the linked list of its previous cell to the list of the new cell.

G. Building and Updating the NNLs

In our implementation, all of the NNLs are implemented as an optimized form of linked

lists. Each interaction [(j; v) ; p] in NNL(i) stores the partner (j; v) and a priority p. We

usually prescribe a (cid:12)xed upper bound on the number of neighbors (interactions) Ni that

a particle can have (this allows us to preallocate all storage and guarantee that additional

memory will not be used unless really necessary), which can vary between particles if nec-

essary. Only the Ni interactions with highest priority are retained in NNL(i). This kind of

NNL can be used for a variety of tasks, including (cid:12)nding the (cid:12)rst few nearest neighbors of

any particle. We allow the NNLs to asymmetric, i.e., just because particle i interacts with

particle (j; k), it is not implied that particle j interacts with (i; (cid:0)k), but rather, the reverse

interaction must be stored in NNL(j) if needed. In the particular use of NNLs for neighbor

search, the priorities are the negative of the \distances" between the particles, so that only

36

the closest Ni particles are retained as neighbors.

There are two main ways of updating the NNLs after a particle collides with its bounding

neighborhood. One is to completely update the NNLs of all particles and start afresh, and

the other one is to only update the NNL of the particle in question. We next discuss these

two forms of NNL updates, complete and partial, and compare them practically in the second

paper in this series to conclude that it is in general preferable to use partial updates (however,

there are situations when it is best to use complete updates). As explained earlier, we focus

on the case when the bounding neighborhoods are scaled versions of the particles. In addition

to limiting the number of near-neighbors of any particle to Ni, we limit the maximum scaling

of the neighborhood with respect to the particle itself to (cid:22)cuto(cid:11) (cid:21) (cid:22)neigh > 1, and count as

overlapping any neighborhoods which overlap when scaled by an additional factor (1 + (cid:15)(cid:22)),

where (cid:15)(cid:22) (cid:21) 0 is a safety cushion used when the boundary deforms. Henceforth, denote

(cid:22)max = (1 + (cid:15)(cid:22)) (cid:22)cuto(cid:11).

1. Complete Updates

A simpler form of update is after a complete resetting of the NNLs, i.e., building the

NNLs from scratch. Algorithm 8 gives a recipe for this. The aim of the algorithm is to try

to make the bounding neighborhoods have a scale factor of (cid:22)max and add all overlapping

neighborhoods in the NNLs. This will always be possible if Ni is large enough. However,

we allow one to limit the number of near neighbors. This is useful when there is not a good

estimate of what a good (cid:22)cuto(cid:11) is.

The algorithm is signi(cid:12)cantly more complicated when BSCs are used since the search

for possibly overlapping bounding neighborhoods needs to be done over pairs of bounding

spheres. To avoid checking a given pair of bounding neighborhoods for overlap multiple

times, we use an integer mask M (i) for each particle, which we assume is persistent, i.e.,

stored for each particle between updates. In our algorithm, a hard wall can be a neighbor

in NNL(i) if N (i) is intersected by a hard-wall boundary. For simplicity, we do not present

pseudocode for adding these hard-wall neighbors, however, it is a straightforward exercise

to add these steps to the algorithms below.

Algorithm 8: Completely update the near-neighbor lists (NNLs) by rebuilding them

from scratch. Assume all particles have been synchronized to the same point in time.

37

1. For all particles, i = 1; : : : ; N , reset NNL(i) to an empty list.

2. For all particles, i = 1; : : : ; N , reduce r(i) to the (cid:12)rst unit cell, and if r(i) is no longer inside

c(i), then remove i from the linked list of c(i), update c(i), and insert i in the list of the new

c(i).

3. If using BSCs, then initialize the largest (absolute) radius of a bounding sphere O (E)

max   0,

and for all particles, i = 1; : : : ; N , do:

(a) Set the bounding neighborhood of i to have the same centroid, orientation and shape as

i but be scaled by a factor (cid:22)max, rN (i)   r(i), qN (i)   q(i) and ON (i)   (cid:22)maxO(i).

(b) For all bounding spheres of i, k = 1; : : : ; NBS (i), do:

i. Remove the sphere from the linked list of cell cBS

k (i).

ii. Calculate the new absolute position of its center and the cell it is in, update cBS

k (i)

accordingly, and insert the sphere into the linked list of cBS

k (i).

iii. Calculate the absolute radius O(E)

of the bounding sphere and set O(E)

max  

k

max

O(E)

max; O(E)

k

n

.

o

(c) Initialize the mask M (i)   0.

of a bounding neighborhood.

5. For all particles, i = 1; : : : ; N , do:

4. else let O(E)

max   (cid:22)max fmaxi [Omax(i)]g be the largest possible radius of an enclosing sphere

(a) If using BSCs, then for all bounding spheres of i, k = 1; : : : ; NBS (i), do:

i. For all cells ci in the neighborhood of cBS

k (i) of Euclidean extent 2O(E)

max, and for

all bounding spheres in ci belonging to some particle (j; v), do:

A. If j (cid:21) i and M (j) 6= sign(v) (jvj N + i), then execute step 7,

B. else mark this pair of particles as already checked, M (j)   sign(v) (jvj N + i).

(b) else, for all cells ci in the neighborhood of c(i) of Euclidean extent 2O (E)

max (note that

his may involve higher-order neighbors of c(i)), do:

i. For all particles (j; v) 2 ci such that j (cid:21) i, execute step 7.

6. Skip step 7.

38

7. If the largest common scaling factor which leaves i and (j; v) disjoint, (cid:22)ij (cid:20) (cid:22)max, then:

(a) Calculate (cid:22)ij exactly (ellipsoids are treated in the second paper in this series).

i. Insert the interaction [(j; v) ; (cid:0)(cid:22)ij] in NNL(i). Note this may remove some previous

entries in NNL(i) if it is already full.

ii. Insert the interaction [(i; (cid:0)v) ; (cid:0)(cid:22)ij] in NNL(j).

8. For all particles, i = 1; : : : ; N , do:

(a) Initialize the minimal scaling of i which makes it overlap with the bounding neighbor-

hood of a non-neighbor particle, (cid:22)non-neigh

  (cid:22)max.

min

(b) If NNL(i) is not full, then initialize the maximal scaling of i which leaves it disjoint

from at least one of the bounding neighborhoods of a neighbor particle, (cid:22)neigh

max   (cid:22)max,

otherwise initialize (cid:22)neigh

max   0.

(c) For all interactions [(j; v) ; p] in NNL(i), ensure that they are bi-directional:

i. If (cid:0)p > (cid:22)neigh

max , then set (cid:22)neigh

max   (cid:0)p.

ii. If there is no interaction with particle (i; (cid:0)v) in NNL(j), then:

A. If (cid:0)p > (cid:22)non-neigh

, then set (cid:22)non-neigh

  (cid:0)p.

min

min

B. Delete the interaction [(j; v) ; p] from NNL(i).

iii. If (cid:0)p < (cid:22)neigh, then set (cid:22)neigh   (cid:0)p.

(d) Set (cid:22)neigh   min

(cid:22)non-neigh
min

; (cid:22)neigh
max

(cid:16)

(cid:17)

. Note that if NNL(i) never (cid:12)lled up then (cid:22)neigh =

(e) If (cid:22)neigh < (cid:22)max, then set ON (i)   (cid:22)maxO(i).

(f) If using BSCs and (cid:22)neigh < (cid:22)max, then for all bounding spheres of i, k = 1; : : : ; NBS (i),

(cid:22)max.

do:

i. Remove the sphere from the linked list of cell cBS

k (i).

ii. Calculate the new absolute position of its center and the cell it is in, update cBS

k (i)

accordingly, and insert the sphere into the linked list of cBS

k (i).

9. If the boundary is deforming, record the current shape of the boundary to be used later to

verify the validity of the NNLs (see Section III B 1).

39

2. Partial Updates

A considerably more complex task is updating NNL(i) while trying to leave the lists of

other particles intact, other then possibly adding or deleting an interaction involving i. We

give a prescription for this in Algorithm 9, but do not give many details, as understanding

each step is not necessary to get an idea of the overall approach. For simplicity, we do not

present the case when BSCs are used, as the modi(cid:12)cations to allow for bounding complexes

closely parallel those in Algorithm 8 and it is a straightforward exercise for the reader to

modify the algorithm below accordingly.

Algorithm 9: Update the near-neighbor list of particle i, NNL(i). Assume that the

current shape of i is passed in Oi.

1. For all interactions with (j; v) in NNL(i), delete the reverse interaction with (i; (cid:0)v) in

2. Initialize the minimal scaling of i which makes it overlap with the bounding neighborhood

of a non-neighbor particle, (cid:22)non-neigh

min

  (cid:22)max, as well as the maximal scaling of i which

leaves it disjoint from at least one of the bounding neighborhoods of a neighbor particle,

NNL(j).

(cid:22)neigh
max   (cid:22)max.

3. For all cells ci in the neighborhood of c(i) of Euclidean extent O neigh

max + (cid:22)maxOi, where Oi is

the radius of the bounding sphere of i and Oneigh

max is the radius of the largest enclosing sphere

of a particle neighborhood, do:

(a) For all bounding neighborhoods Nj in the list of ci, c(j) = ci, do:

i. If the largest scaling factor which leaves i disjoint from the neighborhood of (j; v),

ij < (cid:22)max, then calculate (cid:22)neigh
(cid:22)neigh

ij

exactly, else continue with next particle (j; v).

ii. If there is room in NNL(j), then insert the interaction

iii. else if (cid:22)neigh

ij < (cid:22)non-neigh

min

then set (cid:22)non-neigh

min

  (cid:22)neigh
ij

.

iv. If (cid:22)neigh

ij < (cid:22)neigh

max then set (cid:22)neigh

max   (cid:22)neigh

ij

.

(j; v) ; (cid:0)(cid:22)neigh

ij

in NNL(i),

h

i

4. For all interactions [(j; v) ; p] in NNL(i), do:

(a) Insert the interaction [(i; (cid:0)v) ; (cid:0)p] in NNL(j).

(b) If (cid:0)p > (cid:22)neigh

max then set (cid:22)neigh

max   (cid:0)p.

40

7. Set rN (i)   r(i), qN (i)   q(i) and ON (i)   (cid:22)neighO(i), and also update Oneigh

max  

5. If NNL(i) is full, then set (cid:22)neigh   (cid:22)non-neigh

,

min

6. else set (cid:22)neigh   min

(cid:22)non-neigh
min

; (cid:22)neigh
max

.

(cid:17)

(cid:16)

.

i

max

Oneigh

max ; (cid:22)neighOi

h

V. CONCLUSION

In this (cid:12)rst paper in a series of two papers, we presented a serial collision-driven molec-

ular dynamics algorithm for nonspherical particles, with a speci(cid:12)c focus on improving the

e(cid:14)ciency by developing novel techniques for neighbor search. In particular, we developed

a rigorous scheme that incorporates near-neighbor lists into event-driven algorithms, and

further improved the handling of very elongated objects via the use of (non-hierarchical)

bounding sphere complexes. We gave detailed pseudocodes to illustrate the major steps of

the algorithm. All necessary details to implement the algorithm for ellipses and ellipsoids are

given in the second paper in this series, along with a discussion of the practical performance

of the algorithm. Acknowledgments are given in the second paper in this series.

[1] B. J. Alder and T. E. Wainwright, Studies in molecular dynamics. i. general method, J. Chem.

[2] M. P. Allen, D. Frenkel, and J. Talbot, Molecular dynamics simulation using hard particles,

Phys. 31 (1959), 459.

Comp. Phys. Rep. 9 (1989), 301{353.

[3] M. P. Allen and D. J. Tildesley, Computer simulations of liquids, Oxford Science Publications,

[4] H. Bekker, Uni(cid:12)cation of box shapes in molecular simulations, J. Comp. Chem. 18 (1997),

1987.

no. 15, 1930{1942.

[5] L. G. Casado, I. Garcia, and Ya. D. Sergeyev, Interval algorithms for (cid:12)nding the minimal root

in a set of multiextremal one-dimenisional nondiferentiable functions, SIAM J. Sci. Comput.

24 (2002), no. 2, 359{376.

41

[6] A. Donev, I. Cisse, D. Sachs, E. A. Variano, F. H. Stillinger, R. Connelly, S. Torquato, and

P. M. Chaikin, Improving the density of jammed disordered packings using ellipsoids, Science

303 (2004), 990{993.

[7] J. J. Erpenbeck and W. W. Wood, Statistical mechanics b: Modern theoretical chemistry (b.

j. berne, editor), vol. 6, ch. Molecular dynamics techniques for hard core systems, pp. 1{40,

Institute of Physics Publishing, London, 1977.

[8] D. Frenkel and J. F. Maguire, Molecular dynamics study of the dynamical properties of an

assembly of in(cid:12)nitely thin hard rods, Mol. Phys. 49 (1983), no. 3, 503{541.

[9] D. Frenkel and B. Smit, Understanding molecular simulation, Academic Press, 2002.

[10] G. Germano and F. Schmid, Simulation of nematic-isotropic phase coexistence in liquid crys-

tals under shear, NIC Symposium 2004, NIC Series Vol. 20 (H. Rollnik and D. Wolf, eds.),

Forschungszentrum J(cid:127)ulich, 2004, p. 311.

[11] S.C. Harvey, R. K.-Z. Tan, and T. E. Cheatham III, The (cid:13)ying ice cube: Velocity rescaling

in molecular dynamics leads to violation of energy equipartition, J. Comp. Chem. 19 (1998),

726{740.

[12] Y. A. Houndonougbo, B. B. Laird, and B. J. Leimkuhler, Molecular dynamics algorithms for

mixed hard-core/continuous potentials, Mol. Phys. 98 (1999), 309{316.

[13] P. M. Hubbard, Approximating polyhedra with spheres for time-critical collision detection,

ACM Trans. Graph. 15 (1996), no. 3, 179{210.

[14] M. Isobe, Simple and e(cid:14)cient algorithm for large scale molecular dynamics simulation in hard

disk systems, Int. J. Mod. Phys. C 10 (1999), no. 7, 1281{1293.

[15] M. Yoneya K. M. Aoki and H. Yokoyama, Molecular dynamic simulation methods for

anisotropic liquids, J. Chem. Phys. 120 (2004), no. 12, 5576{5582.

[16] A. T. Krantz, Analysis of an e(cid:14)cient algorithm for the hard-sphere problem, TOMACS 6

(1996), no. 3, 185{209.

[17] A. W. Lees and S. F. Edwards, The computer study of transport processes under extreme

conditions, J. Phys. C. 5 (1972), 1921{1929.

[18] B. D. Lubachevsky, Simulating colliding rigid disks in parallel using bounded lag without time

warp, Distributed Simulation, SCS Simulation Series 22 (1990), no. 1, 194{202.

[19]

, How to simulate billiards and similar systems, J. Comp. Phys. 94 (1991), 255{283.

[20] B. D. Lubachevsky and F. H. Stillinger, Geometric properties of random disk packings, J. Stat.

42

Phys. 60 (1990), 561{583, See also Ref. 21.

[21] B. D. Lubachevsky, F. H. Stillinger, and E. N. Pinson, Disks vs. spheres: Contrasting properties

of random packings, J. Stat. Phys. 64 (1991), 501{525, Second part of Ref. 20.

[22] M. Marin and P. Cordero, Hashing-cell combination for boundless space event-driven molec-

ular dynamics, 8th Joint EPS-APS International Conference on Physics Computing (Eds. P.

Borcherds and M. Bubak), World Scienti(cid:12)c Publishing Company, September 1996, pp. 315{

318.

[23] M. Marin, D. Risso, and P. Cordero, E(cid:14)cient algorithms for many-body hard particle molecular

dynamics, J. Comp. Phys. 109 (1993), 306{317.

[24] S. Miller and S. Luding, Event-driven molecular dynamics in parallel, J. Comput. Phys. 193

(2004), no. 1, 306{316.

[25] M. H. Overmars and A. F. van der Stappen, Range searching and point location among fat

objects, J. Algorithms 21 (1996), no. 3, 629{656.

[26] M. Parinello and A. Rahman, Polymorphic transitions in single crystals: A new molecular

dynamics method, J. Appl. Phys. 52 (1981), no. 12, 7182{7190.

[27] D. C. Rapaport, The event scheduling problem in molecular dynamics simulation, J. Comp.

Phys. 34 (1980), 184.

[28] D. W. Rebertus and K. M. Sando, Molecular dynamics simulation of a (cid:13)uid of hard sphero-

cylinders, J. Chem. Phys. 67 (1977), no. 6, 2585{2590.

[29] K. Shida and Y. Anzai, Reduction of the event list for molecular dynamic simulation, Comp.

Phys. Comm. 69 (1992), 317{329.

[30] H. Sigurgeirsson, A. Stuart, and W.-L. Wan, Algorithms for particle-(cid:12)eld simulations with

collisions, J. Comp. Phys. 172 (2001), 766{807.

[31] S. Torquato, A. Donev, and F. H. Stillinger, Breakdown of elasticity theory for jammed hard-

particle packings: Conical nonlinear constitutive theory, Int. J. Solids Structures 40 (2003),

no. 25, 7143 { 7153.

43

(a) Lattice-based boundary

(b) Periodic BCs

Figure 1:

Illustration of lattice-based boundaries. The top sub(cid:12)gure shows a unit cell in two

dimensions, along with the length of the unit cell along the x direction, L1, and the left and right

\walls" along the x dimension. Also shown is a particle and its bounding sphere (disk). The bottom

sub(cid:12)gure shows a unit cell and an original particle (black), along with the (cid:12)rst neighbor images

and their image identi(cid:12)ers v.

44

Figure 2: The cell method: A small disk packing and the associated grid of cells, to be used in

searching for possibly overlapping particles. Dark-shaded disks are original particles and light-

shaded ones are images.

Figure 3: The partitioning of a lattice-based simulation box into cells (dark lines). The Cartesian

grid of cells deforms in unison with the lattice, as illustrated by a snapshot of the box and its

partitioning at a latter time. Particles also move together with the lattice, even if they are at

\rest", v = 0, as shown for an ellipsoid in the (1; 3) cell.

45

Figure 4: Illustration of NNLs for a system of disks (top) and ellipses (bottom). Particles are dark,

and their bounding neighborhoods are light (it is easy to see which neighborhood goes with which

particle). For disks, the neighborhoods are disks and the pairs of near-neighbors are shown as dark

lines. For ellipses the neighborhoods are ellipses themselves and the interactions are shown as dark

triangles whose vertices are given by the centroids of the two ellipses and the point of contact of

the ellipses.

46

Neighbor List Collision-Driven Molecular Dynamics Simulation

for Nonspherical Hard Particles.

II. Applications to Ellipses and Ellipsoids

Aleksandar Donev,1, 2 Salvatore Torquato,1, 2, 3, (cid:3) and Frank H. Stillinger3

1Program in Applied and Computational Mathematics,

Princeton University, Princeton NJ 08544

2Materials Institute, Princeton University, Princeton NJ 08544

3Department of Chemistry, Princeton University, Princeton NJ 08544

Abstract

We apply the algorithm presented in the (cid:12)rst part of this series of papers to systems of hard

ellipses and ellipsoids. The theoretical machinery needed to treat such particles, including the

overlap potentials, is developed in full detail. We describe an algorithm for predicting the time of

collision for two moving ellipses or ellipsoids. We present performance results for our implementa-

tion of the algorithm, demonstrating that for dense systems of very aspherical ellipsoids the novel

techniques of using neighbor lists and bounding sphere complexes, o(cid:11)er as much as two orders of

magnitude improvement in e(cid:14)ciency over direct adaptations of traditional event-driven molecular

dynamics algorithms. The practical utility of the algorithm is demonstrated by presenting sev-

eral interesting physical applications, including the generation of jammed packings inside spherical

containers, the study of contact force chains in jammed packings, and melting the densest-known

equilibrium crystals of prolate spheroids.

(cid:3) Electronic address: torquato@electron.princeton.edu

1

I.

INTRODUCTION

In the (cid:12)rst paper of this series of two papers, we presented a collision-driven molecular dy-

namics algorithm for simulating systems of nonspherical hard particles. The algorithm rigor-

ously incorporates near-neighbor lists, and further improves the treatment of very elongated

objects via the use of bounding sphere complexes. Detailed pseudocodes for the algorithm

were presented, but several particle-shape-dependent components were left unspeci(cid:12)ed. In

particular, a key component of the algorithm is the evaluation of overlap between scaled

versions of two particles, such as the evaluation of the minimal common scaling that leaves

two disjoint ellipsoids nonoverlapping, or the maximal scaling of an ellipsoid which leaves it

contained within another ellipsoid. Additionally, the required procedures for predicting the

time-of-collision for two moving ellipsoids, as well as processing the collision, are developed.

Moreover, we discuss generalizations to other particle shapes.

We also illustrate the practical utility and versatility of the algorithm by presenting several

nontrivial and physically relevant applications. In particular, we show that by incorporating

particle growth (i.e., shape deformation), the proposed algorithm can generate jammed pack-

ings of ellipsoids and is superior to previously used algorithms in both speed and particularly

in accuracy. The high precision of the event-driven approach enables us to reach previously

unavailable high densities and to produce tightly jammed ellipsoid packings with several

thousand particles, even for relatively large aspect ratios [12]. Additionally, the inclusion of

boundary deformation allowed us to generate the densest known crystal packings of ellip-

soids [11], and here we show how the algorithm can be used to simulate a quasi-equilibrium

(adiabatic) cooling of this crystal to track its equation of state and phase behavior. We also

demonstrate how using near-neighbor lists can help monitor the particle collision history

near the jamming point and enable the study of force chains, previously studied only in

time-driven molecular dynamics of soft particles [3].

We present the tools necessary to rapidly evaluate overlap functions for ellipsoids in

Section II. We then describe the missing particle-shape-dependent pieces of the algorithm in

Section III. Some performance results for the algorithm are shown in Section IV, particularly

focusing on the use of our near-neighbor list and bounding sphere complexes techniques.

Three illustrative applications are given in Section V.

2

II. GEOMETRY OF ELLIPSES AND ELLIPSOIDS

In this section, we focus exclusively on ellipsoidal particles, particularly in two (ellipses)

and three (ellipsoids) dimensions. We present all of the necessary tools to adapt the EDMD

algorithm to ellipsoids. We (cid:12)rst give some introductory material, and then discuss several

overlap (contact) functions for ellipsoids, based on the work of Perram and Wertheim [30].

We then focus on calculation of these overlap functions and their time derivatives, which is

used in Section III to robustly determine the time-of-collision for two moving ellipsoids. We

will attempt to present most of the results so that they generalize to other dimensions as

well; however, this is not always possible. We present the basic concepts in a uni(cid:12)ed and

simple manner. Readers looking for more detailed background information are referred to

Refs. [1] and [2].

A.

Introduction and Background

In order to deal with the rotational degrees of freedom for ellipsoids and track their

orientation, as well as their centroidal position, some additional machinery is necessary.

Since very little of the notation seems to be standard, we (cid:12)rst present our own notational

system, which attempts to unify di(cid:11)erent dimensionalities whenever possible. We then

discuss orientational degrees of freedom and rotation of rigid bodies.

1. Notation

When dealing with rotational motions, especially in three dimensions, cross products

and rotational matrices appear frequently. In order to unify our presentation for two and

three dimensions as much as possible, we introduce some special matrix notation. Matrix

multiplication is assumed whenever products of matrices or a matrix and a vector appear.

We prefer to use matrix notation whenever possible1 and do not carefully try to distinguish

between scalars and matrices of one element. We denote the dot product a

b with aT b,

(cid:1)

and the outer product a

b with abT .

(cid:10)

1 Our computational implementation uses a specially designed library of inlined macros for matrix operations

extensively.

3

The (cid:12)rst notational di(cid:14)culty relates to the notion of a cross product. In three dimensions,

there is only the familiar cross product

= Ab

(1)

a

b =

(cid:2)

aybz (cid:0)
azbx (cid:0)
axby (cid:0)

azby

axbz

aybx

2

6
6
6
4

3

7
7
7
5

az ay

0

az

(cid:0)
0

A =

2

6
6
6
4

ay ax

(cid:0)

=

AT

(cid:0)

ax

(cid:0)
0

3

7
7
7
5

where

where

where

is a skew-symmetric matrix which is characteristic of the cross product and is derived from

a vector. We will simply capitalize the letter of a vector to denote the corresponding cross

product matrix (like A above corresponding to a). In two dimensions however, there are

two \cross products". The (cid:12)rst one gives the velocity of a point r in a system which rotates

around the origin with an angular frequency ! (which has just one z component and can

also be considered a scalar !),

is a cross product matrix derived from !. The second kind of \cross product" gives the

torque around the origin of a force f acting at a point (arm) r,

v = ! (cid:2) r = 2

= (cid:10)r;

!ry

(cid:0)
!rx

3

5

4

(cid:10) = 2

!

0

(cid:0)
! 0

3

=

(cid:10)T

(cid:0)

4

5

(cid:28) = f

r =

(cid:2)

r
(cid:0)

(cid:2)

f = [fxry (cid:0)

fyrx] = FLr;

FL =

fy fx

=

i

h (cid:0)

T

FR

(cid:0)

(cid:0)

(cid:1)

(2)

(3)

is another cross product matrix derived from a vector (the L and R stand for left and right

multiplication, respectively). Note that in three dimensions all of these coincide, FL = FR =
F, and also (cid:2)

. The notation was chosen so equations look simple in three dimensions,

(cid:17) (cid:2)

but are also applicable to two dimensions. The wedge product generalizes the cross product

in higher dimensions [20].

4

2. Rigid Bodies

Representing the orientation of a rigid body in a computationally convenient way has

been a subject of debate in the past [2]. A rigid body has

fR =

d (d

1)

(cid:0)
2

1 if d = 2

3 if d = 3

= 8
<

:

(4)

rotational degrees of freedom, and this is the minimal number of coordinates needed to spec-

ify the con(cid:12)guration of a hard nonspherical particle, in addition to the usual d coordinates

needed to specify the position of the centroid. In two dimensions orientations are easy to

represent via the angle (cid:30) between the major semiaxes of the ellipsoid and the x axis. But

in three dimensions specifying three (Euler) angles is numerically unstable, and extensive

experience has determined that for MD computationally the best way to represent orienta-

tions is via normalized quaternions, which in fact represent (cid:12)nite rotations starting from an

initial reference con(cid:12)guration (but see Ref.

[17] for a discussion). In the case of ellipsoids

this reference con(cid:12)guration is one in which all semiaxes are aligned with the coordinate axes.

In two dimensions we use a normalized complex number to represent orientation, but for

simplicity we will sometimes use the term \quaternion" in both two and three dimensions.

Higher dimensional generalizations are discussed in Ref. [33].

In three dimensions, normalized quaternions consist of a scalar s and a vector p,

q = [s; p] =

cos

(cid:30)
2

;

sin

(cid:18)

(cid:30)
2 (cid:19)

^(cid:30)

;

(cid:21)

(cid:20)

(5)

where ^(cid:30) is the unit vector along the axis of rotation and (cid:30) is the angle of rotation around

this axis, and the normalization condition

2 = s2 +

q
k

k

2 = 1

p
k

k

is satis(cid:12)ed. Therefore in three dimensions we use 4 numbers to represent orientation, which

seems like wasting one (cid:13)oating-point number. It is in fact possible to represent the rotation
with the oriented angle (cid:30) = (cid:30) ^(cid:30), which is just a vector with 3 coordinates. However, such

a representation has numerical problems when (cid:30) = 0, and also the representation is not

unique2. More importantly, combining rotations (as during rotational motion) does not

2 Note that the quaternion representation is also not unique since

q and q represent the same orientation.

(cid:0)

5

correspond (as one may expect) to vector addition of the (cid:30)â€™s, but it does correspond to

quaternion multiplication of the qâ€™s, which is fast since there is no need of repeating the

trigonometric evaluations. This is the reason why we also use quaternions in two-dimensions,

and represent the orientation of a particle in the plane with 2 coordinates (components of a

unit complex number),

The orthogonal rotation matrix corresponding to the rotation described by the quaternion

q = [s; p] = [cos (cid:30); sin (cid:30)] :

(6)

(5) is given with

in three dimensions, and

Q = 2

ppT
(cid:20)

(cid:0)

sP +

s2

(cid:18)

(cid:0)

1
2 (cid:19)

I

(cid:21)

Q = 2

s p

p s

3

(cid:0)
in two dimensions, corresponding to the complex number (6). The resulting orientation

4

5

after (cid:12)rst the rotation Q1 is applied and then the rotation Q2 is applied, Q12 = Q2Q1, is

represented by the quaternion product

q12 = q1q2 = [s1s2 (cid:0)
in three dimensions, and by the complex number product

p2; s1p2 + s2p1 (cid:0)

p1 (cid:1)

p1 (cid:2)

p2]

q12 = q1q2 = [s1s2 (cid:0)

p1p2; s1p2 + s2p1]

in two dimensions.

(7)

(8)

In this work we are interested in particles which move continuously in time. The rate of

rotation of a rigid body is given by the angular velocity ! (which can also be considered a

scalar ! in two dimensions), or equivalently, the in(cid:12)nitesimal change in orientation is given

by the in(cid:12)nitesimal rotation d(cid:30) = !dt. The instantaneous time derivative of the normalized

quaternion is given with3

in three dimensions, and with

_q =

1
2

s

p

(cid:0)
p sI + P

0

!

3

5

3

2

5

4

_q =

s p

p s

(cid:0)

2

4

3

2

5

4

0

!

3

5

2

4

1
2

6

3 Recall that capital P denotes the cross product matrix corresponding to p.

in two dimensions. The time derivative of the corresponding rotation matrix is

_Q =

Q(cid:10);

(cid:0)

and this result has was used extensively in deriving the various time derivatives related to

the contact function for ellipsoids, as will be given shortly.

3. Ellipsoids

inequality

An ellipsoid is a smooth convex body consisting of all points r that satisfy the quadratic

r0)T X (r

(r

(cid:0)

r0)

1;

(cid:20)

(cid:0)

where r0 is the position of the center (centroid), and X is a characteristic ellipsoid matrix
describing the shape and orientation of the ellipsoid. The case when X = 1
O2 I is a diagonal
matrix describes a sphere of radius4 O, which does not require orientation information. In

the general case,

where Q is the rotational matrix describing the orientation of the ellipsoid, and O is a

diagonal matrix containing the major semi-axes of the ellipsoid along the diagonal. The time

derivative of the matrix (10) for an ellipsoid rotating with instantaneous angular velocity !

is

X = QT O(cid:0)2Q;

_X = (cid:10)X

X(cid:10):

(cid:0)

In Algorithm 1 we give a prescription for updating the orientation of an ellipsoid rotating

with a constant angular velocity for a time (cid:1)t.

Algorithm 1 Update the orientation of an ellipsoid rotating with a uniform angular

1. Calculate the change in orientation q(cid:1)t using (cid:30)(cid:1)t = !(cid:1)t in eq. (5) or (6).

velocity ! after a time step (cid:1)t.

2. Update the quaternion, q

qq(cid:1)t, using eq. (7) or (8).

 

4 We will use the letters r and R to denote positions of points, and therefore resort to using O when referring

to radius.

(9)

(10)

(11)

7

> (cid:15)q (due to accumulation of numerical errors), renormalize the quaternion,

3. If

q

jk

1
j

k (cid:0)
q=

.

q
k

k

q

 

B. Ellipsoid Overlap Potentials

The problem of determining whether two ellipsoids A and B overlap (have a common

point) or not has been considered previously in relation to Monte Carlo or MD simulations

of hard-ellipsoid systems [1]. Here we are concerned not only with a binary overlap crite-

rion, but rather with a numerically e(cid:14)cient way of measuring a distance 5 between the two

ellipsoids F (A; B), whose sign not only gives us an overlap criterion,

F (A; B) > 0 if A and B are disjoint

F (A; B) = 0 if A and B are externally tangent

F (A; B) < 0 if A and B are overlapping;

but which is also continuously di(cid:11)erentiable in the positions and orientations of the ellipsoids

A and B and is numerically stable. An additional convenient property is that F (A; B) be

de(cid:12)ned and easy to compute for all positions and orientations of the ellipsoids. We will call

such a distance function an overlap potential. We will also make use of an overlap potential

G(A; B) for the case when ellipsoid A is completely contained within B (for example, B can

be the bounding neighborhood of A, or it can be an ellipsoidal hard-wall container),

G(A; B) > 0 if A is completely contained in B

G(A; B) = 0 if A is internally tangent to B

G(A; B) < 0 if part or all of A is outside B;

and give such a potential below. Such potentials have not been considered before since

they do not appear in other algorithms, however, our neighbor-list EDMD algorithm for

ellipsoids uses it to construct bounding neighborhoods for the particles, and additionally,

such a potential can be used to implement hard-wall boundary conditions inside an ellipsoidal

8
>>><
>>>:

8
>>><
>>>:

container.

5 This is not a distance in the mathematical sense.

8

More than three decades ago, Vieillard-Baron proposed an overlap criterion based on

the number of negative eigenvalues of a certain matrix [44], and this criterion has been

subsequently rediscovered [45]. It easily generalizes to two dimensions and can be used to

obtain an overlap potential. We have implemented and tested this overlap potential but have

found it both computationally and theoretically inferior to an overlap potential proposed by

Perram and Wertheim [30]. We have therefore completely adapted the Perram-Wertheim

(PW) overlap potential and also extended it to the case of one ellipsoid contained within

another. Many other approaches are possible, for example, an approximate measure of

the Euclidean distance between the surfaces of the two ellipsoids can be used [14, 16, 23,

31]. However, the advantage of the PW approach is its inherent symmetry, dimensionless

character, and most of all, its simple geometric interpretation in terms of scaling factors.

The geometrical idea behind the Perram-Wertheim overlap potential is very simple and is

based on considering scaling the size of the ellipsoids uniformly until they are in external or

internal tangency. Consider for example the case when A and B are disjoint, as illustrated

in the leftmost part of Fig. 1. If ellipsoid A is scaled by a nonnegative factor (cid:22)(A) such

that the centroid of B is still outside it, then there is a corresponding scaling of B, (cid:22)(B),

which brings B into external tangency with A at the contact point rC [(cid:22)(A)]. This scaling

is a solution to a simple eigenvalue-like problem involving XA and XB. The normal vectors

of A and B at the contact point are of opposite direction, and by changing the ratio of their

lengths from 0 to

we get a path of contact points going from the center of A to the center

of B. It was a wonderful idea of Perram and Wertheim [30] to parameterize this path with

a scalar (cid:21)

[0; 1], and then look for the (cid:21) = (cid:3) which makes (cid:22)(A) = (cid:22)(B), i.e.

look for

1

2

the common scaling factor (cid:22)AB which brings A and B into external tangency at the contact

point rC (shown in Fig. 1), or equivalently, look for the largest common scaling factor which

preserves non-overlap. This approach is very well-suited for the case when both A and B

are particles and thus should be treated equally. Sometimes, however, ellipsoid B has a

special status, for example, it may be the bounding neighborhood of another particle. In

this case we look for the scaling factor (cid:22)B(A) of A which brings A into external tangency

with the (cid:12)xed B (see second subsection in Section II.C in Ref.

[29]), or equivalently, the

largest scaling of A which preserves non-overlap, as illustrated in the middle part of Fig. 1.

A similar idea applies to the case when A is contained within B, in which case we look for the

largest scaling (cid:23)B(A) of A which leaves A contained completely within B, or equivalently,

9

which brings A into internal tangency with B.

Figure 1: Illustration of the scaling (cid:22) in the PW contact function: Left: The outer tangency

potential (cid:22)AB. Middle: The outer tangency potential (cid:22)B(A). Right: The inner tangency potential

(cid:23)B(A).

Using these scaling factors, we can de(cid:12)ne several overlap potentials,

FAB(A; B) = (cid:22)2

1

FB(A; B) = (cid:22)2

GB(A; B) = (cid:23)2

B(A)

AB (cid:0)
B(A)

1

1;

(cid:0)

(cid:0)

(12)

(13)

(14)

which we will refer to as the Perram-Wertheim (PW), the modi(cid:12)ed PW overlap potential,

and the internal PW overlap potential respectively. To appreciate why we use the squares

of the scaling factors, consider the case of spheres, where the PW overlap potential simply

becomes

FAB = j

2

rBj
rA (cid:0)
(OA + OB)2 (cid:0)

1 =

l2
AB
(OA + OB)2 (cid:0)

1;

which avoids the use of square roots in calculating the distance between the centers of A

and B, lAB, and is also much simpler to work with analytically. Extensive use of all three of

the contact functions (12-14) has been made in the implementation of the algorithm, and in

particular, the building and updating of the near-neighbor lists. The original PW overlap

potential (12) is the most e(cid:14)cient in practice and also has the property that it is symmetric

10

with respect to the interchange of A and B, and is preferred over (13) unless (cid:22)2

B(A) is needed
(recall from the (cid:12)rst paper in this series that (cid:22)B(A) is needed when using partial updates for

the neighbor lists). Note that FB and GB are not de(cid:12)ned for all positions of the ellipsoids,

namely, if the center of A is inside B, FB is not de(cid:12)ned, and conversely, if the center of A is

outside B, GB is not de(cid:12)ned.

C. Calculating the Overlap Potentials

In this section we address the issue of e(cid:14)ciently and reliably calculating the three PW

overlap potentials. We base our discussion on outlines of recipes for calculating FAB and FB

in the literature [1, 29, 30], but focus on detail and describe a speci(cid:12)c computational scheme

based on polynomials. Additionally, contact information such as the point of contact or the

common normal vector at the point of contact can be calculated once the overlap potential

is found.

1. Evaluating FAB

Following Perram and Wertheim, de(cid:12)ne the parametric function

where rAB = rB (cid:0)

rA, and

fAB ((cid:21)) = (cid:21) (1

(cid:21)) rT

ABY(cid:0)1rAB;

(cid:0)

Y = (cid:21)X(cid:0)1

B + (1

(cid:21)) X(cid:0)1
A :

(cid:0)

(15)

(16)

It turns out that this function is strictly concave on the interval [0; 1] and thus has a unique

maximum at (cid:21) = (cid:3)

[0; 1], from which one can directly calculate the overlap potential:

2

FAB = fAB ((cid:3)) = max
0(cid:20)(cid:21)(cid:20)1

fAB ((cid:21)) :

The maximum of fAB ((cid:21)) can easily be found numerically using only polynomial manipula-

tions, by making extensive use of matrix adjoints (sometimes called adjugates) and deter-

minants (both of which are polynomials in the matrix elements). First rewrite fAB ((cid:21)) as a

rational function:

fAB ((cid:21)) =

pAB ((cid:21))
qAB ((cid:21))

(cid:21) (1

(cid:21))

(cid:0)

=

aT
ABadj [(cid:21)I + (1
(cid:8)
det [(cid:21)I + (1

(cid:0)
(cid:21)) AAB]

(cid:21)) AAB] aAB

;

(cid:9)

(17)

(cid:0)

11

where

aAB = X1=2

B rAB and AAB = X1=2

B X(cid:0)1

A X1=2
B :

Note that powers of X are easy to calculate because of the special form (10) and orthog-

onality of Q. We have made use of the symbolic algebra system Maple

and its code

generation abilities to generate inlined Fortran code to form the coe(cid:14)cients of the polyno-

mial adj [(cid:21)I + (1

(cid:21)) A] and det [(cid:21)I + (1

(cid:21)) A] for a given symmetric matrix A, and this

(cid:0)

(cid:0)

has found numerous uses when dealing with ellipsoids, such as in evaluating the coe(cid:14)cients

of the polynomials pAB and qAB in eq. (17). The unique maximum of fAB ((cid:21)) can be found

by (cid:12)nding the root of its (cid:12)rst derivative, which is the same as (cid:12)nding the unique root of the

degree-2d polynomial

ABqAB (cid:0)
in the interval [0; 1], which can be done very rapidly using a safeguarded Newton method.

AB

hAB = p0

pABq0

A good initial guess to use in Newtonâ€™s method is the exact result for spheres

(cid:3) =

OA
OA + OB

;

where O is the largest semiaxes, i.e., the radius of the enclosing sphere for an ellipsoid.

Additionally, one often has a better initial guess for (cid:3) in cases when the relative con(cid:12)guration

of the ellipsoids has not changed much from previous evaluations of FAB. Finally, a task

which appears frequently is to evaluate the overlap potential between two ellipsoids but only

F (cuto(cid:11))
AB

if they are closer than a given cuto(cid:11), in the sense that the exact value is only needed if
FAB (cid:20)
the neighbor lists in the (cid:12)rst paper in this series). This cuto(cid:11) can be used to speed up the
process by terminating the search for (cid:3) as soon as a value fAB ((cid:21)) > F (cuto(cid:11))

(see for example the algorithms for updating

, or equivalently (cid:22)AB (cid:20)

is encountered

(cid:22)(cuto(cid:11))
AB

AB

during Newtonâ€™s method. Additionally, one can (cid:12)rst test the enclosing spheres for A and B

with the same cuto(cid:11) and not continue the calculation if the spheres are disjoint even when
scaled by a factor (cid:22)(cuto(cid:11))

.

AB

Since almost always the value of (cid:21) = (cid:3) is used, henceforth we do not explicitly denote

the special value (cid:3), unless there is the possibility for confusion. The reader should keep

in mind that expressions to follow are to be evaluated at (cid:21) = (cid:3). The subscript C will be

used to denote quantities pertaining to the contact point. The contact point rC of the two

ellipsoids is

rC = rA + (1

(cid:21)) X(cid:0)1

A n = rB (cid:0)

(cid:0)

(cid:21)X(cid:0)1

B n;

(18)

12

(cid:0)
where

where

n = Y(cid:0)1rAB

(19)

is the unnormalized common normal vector at the point of contact (once the ellipsoids are
scaled by the common factor (cid:22)AB), directed from A to B in this case. Here rBC = rC (cid:0)
and rAC = rC (cid:0)
important value is the curvature of fAB at the special point (cid:21) = (cid:3),

rA are the \arms" from the centers of the ellipsoids to the contact point. An

rB

f(cid:21)(cid:21) =

d2fAB
d(cid:21)2 = 2

BCY(cid:0)1rAC
rT
(cid:21))
(cid:21) (1

=

2nT Zn < 0;

(cid:0)

(cid:0)

Z = X(cid:0)1

A Y(cid:0)1X(cid:0)1

B = X(cid:0)1

B Y(cid:0)1X(cid:0)1

A = [(cid:21)XA + (1

(cid:21)) XB](cid:0)1 :

(cid:0)

2. Evaluating FB and GB

The evaluation of the modi(cid:12)ed outer and internal tangency PW overlap potentials FB

and GB proceeds in a similar fashion, but with a di(cid:11)ering sign in several expressions. Here

the upper sign will denote the case of internal tangency (GB), and the lower the case of

outer tangency (FB). We proceed to give a prescription for evaluation of these potentials

without detailed explanations.

As for evaluating FAB above, (cid:12)rst we de(cid:12)ne the parameterized function

We then numerically look for the largest (cid:21) = (cid:3) in [0; 1] which solves the nonlinear equation

as well as

where

fB ((cid:21)) = (cid:21)2rT

ABY(cid:0)1X(cid:0)1

B Y(cid:0)1rAB;

gB ((cid:21)) = (1

(cid:21))2 rT

ABY(cid:0)1X(cid:0)1

A Y(cid:0)1rAB;

(cid:0)

Y = (cid:21)X(cid:0)1

B (cid:7)

(1

(cid:0)

(cid:21)) X(cid:0)1
A :

and then we have the desired scaling factor

GB or FB = gB ((cid:3)) = (cid:23)2

1 or (cid:22)2

1:

B (cid:0)

B (cid:0)

fB ((cid:21)) = 1;

13

(20)

(21)

(22)

(23)

Additionally, the contact point is

rC = rA (cid:7)

(1

(cid:0)

(cid:21)) X(cid:0)1

A n = rB (cid:6)

(cid:21)X(cid:0)1

B n;

(24)

where the normal vector n is as in eq. (19). An additional useful value is the slope

f(cid:21) =

= 2

dfB
d(cid:21)

BCY(cid:0)1rAC
rT
(1

(cid:21))

:

(cid:0)

We can again use polynomial algebra to e(cid:14)ciently solve eq. (23) using a safeguarded

Newton method, by rewriting fB ((cid:21)) as a rational function

fB ((cid:21)) = P

d
k=1

(cid:21)p(B)
k
h
q2
B ((cid:21))

2

((cid:21))

i

=

(cid:21)2

adj [(cid:21)I
k

(cid:7)
det [(cid:21)I

2

(1

(cid:0)
(1

(cid:21)) AAB] aABk
(cid:21)) AAB]
(cid:0)

(cid:7)

= 1;

(25)

where p(B)

k

and qB are polynomials, to obtain the equivalent equation

qB ((cid:21))

= 1;

(cid:21)

r

d
k=1

p(B)
k

((cid:21))

P

h

2

i

which is better suited for numerical solution. The search interval for (cid:3) in this case should be
, where ~(cid:3) is the largest root of the degree-d polynomial qB in [0; 1], which

taken to be

~(cid:3); 1

can be found exactly in both two and three dimensions using standard algebraic methods

h

i

for the solution of polynomial equations of degree less than 5. A reasonable initial guess
when evaluating GB is (cid:21) = ~(cid:3).

Unlike the evaluation of FAB and FB, which are both rapid6 and robust, the evaluation of

GB poses numerical di(cid:14)culties due to the presence of the minus sign in eq. (22), which can

cause Y to become singular. This happens when

0, which does occur when

Y(cid:0)1rABk !
k

~(cid:3). In this case, since Y is singular, its adjoint is (almost always) rank-1,

(cid:3)

!

where u is some (eigen)vector, and the problem occurs because uT rAB !
apparently indeterminate 0=0 in eq.

(25). The limiting value of GB is mathematically

0, yielding an

well-de(cid:12)ned even in this case, however, its numerical evaluation is unstable, and has been

a constant source of numerical problems in our implementation. One alleviating trick is to

6 In our numerical experience FAB and its time derivatives can be evaluated signi(cid:12)cantly faster.

adj [Y]

uuT ;

!

14

avoid explicitly inverting Y and instead the adjoint should be used, Y(cid:0)1 = adj [Y] =det [Y],

where the determinant of Y can be calculated by using (23),

det [Y] = (cid:21)

~nT X(cid:0)1

B ~n;

q

where ~n = adj [Y] rAB. Even with such precautions, we have observed numerical di(cid:14)cul-

ties in the calculations involving inner tangency of A and B. It would therefore be useful

to explore alternative overlap potentials for the case when ellipsoid A is contained within

ellipsoid B, or di(cid:11)erent ways of calculating GB.

D. Time Derivatives of the Overlap Potentials

When dealing with moving ellipsoids, and in particular, when determining the time-

of-collision for two ellipsoids in motion, expressions for the time derivatives of the contact

potentials are needed. We give these expressions here without a detailed derivation. We have

additionally obtained expressions for second order derivatives, however, these are not needed

for the current exposition and are signi(cid:12)cantly more complicated, and are not presented here.

We use the standard dot notation for time derivatives.

1. Derivatives of FAB

Consider two ellipsoids moving with instantaneous velocities vA and vB and rotating

with instantaneous angular velocities !A and !B. For the purposes of the Lubachevsky-

Stillinger algorithm, we also want to allow the ellipsoid semiaxes to change with an expan-
sion/contraction rate of (cid:13) = _O, i.e., O(t) = O(0) + (cid:13)t. We have the expected result that

the rate of change of overlap depends on the projection of the relative velocity at the point

of contact, vC, along the common normal vector n,

_FAB = 2(cid:21) (1

(cid:21)) nT vC;

(cid:0)

(26)

where

and

vC = [vB + !B (cid:2) rBC + (cid:0)BrBC ]

[vA + !A (cid:2) rAC + (cid:0)ArAC]

(cid:0)

(cid:0) = QT

O(cid:0)1(cid:13)

Q:

(cid:1)

(cid:0)
15

One sometimes also needs the time derivative of (cid:21) = (cid:3)

_(cid:21) =

2
f(cid:21)(cid:21) (cid:8)

(cid:0)

where

~nT vC + nT [(cid:21)(cid:0)BrBC + (1

(cid:21)) (cid:0)ArAC] + (cid:21) (1

(cid:0)

(cid:21)) nT Z [(!B (cid:0)

(cid:0)

!A) (cid:2) n]

;

(cid:9)

(27)

~n = (cid:21)Y(cid:0)1rBC + (1

(cid:21)) Y(cid:0)1rAC:

(cid:0)

2. Derivatives of FB and GB

In this case we have:

and

_(cid:21) =

_GB or _FB =

2 (1

(cid:7)

(cid:0)

(cid:21)) nT vC;

(28)

2(cid:21)
f(cid:21) (cid:8)

(cid:0)

BCY(cid:0)1vC +
rT

ACY(cid:0)1(cid:0)BrBC (cid:0)
rT
(cid:2)

BCY(cid:0)1(cid:0)ArAC
rT

(cid:21) (1

(cid:21)) nT Z [(!B (cid:0)

(cid:0)

(cid:7)

(cid:3)

!A) (cid:2) n]

:

(cid:9)

(29)

III. EDMD FOR ELLIPSES AND ELLIPSOIDS

Having developed the necessary tools for dealing with overlap between ellipses and ellip-

soids in Section II, we can now complete the description of the EDMD algorithm. We (cid:12)rst

discuss the fundamental step of predicting collisions between moving ellipsoids, and then

explain how to process a binary collision between two ellipsoids.

A. Predicting Collisions

The central step in event-driven MD algorithms is the prediction of the time-of-collision

for two moving particles, as well as the time when a particle leaves its bounding neigh-

borhood. This is also the most time-consuming step, especially for nonspherical particles.

Although general methods can be developed for particles of arbitrary shape [43], e(cid:14)ciency

is of primary concern to us and we prefer specialized methods which utilize the properties of

ellipsoids, in particular, their smoothness and the relative simplicity of the time derivatives

of the overlap potentials given in Section II D. In three dimensions, we restrict consideration

16

to ellipsoids with a spherically symmetric moment of inertia, i.e., ellipsoids with equal mo-

ment of inertia around all axes. This is because the force-free motion of general ellipsoids, as

well as their binary collisions, are very complex to handle. For example, the angular velocity

is not constant but oscillates in a complex manner. It is not hard to adapt the algorithms

presented here to ellipsoids with several di(cid:11)erent moments of inertia, at least in principle.

Essentially, predicting the collision time tc between two moving ellipsoids A(t) and B(t)

consists in (cid:12)nding the (cid:12)rst non-zero root of the overlap potential F (t) = F [A (t) ; B (t)],

where F can be either one of FAB, FB or GB, depending on the type of collision and the

choice of the potential. Formally:

tc = min t

such that F (t) = 0 and t

0,

(cid:21)

(30)

where F (t) is a smooth continuously di(cid:11)erentiable function of time, as illustrated in Fig.

2. This kind of (cid:12)rst root location problem has wide applications and has been studied in

various disciplines. For a general non-polynomial F (t), its rigorous solution is a very hard

problem and requires either interval methods [6] or rigorous under/over estimation of F (t)
_F (and possibly of F ) [10].

based on knowledge of exact bounds on the Lipschitz constant of

These methods are rather complex and are focused on robustness and generality, rather than

e(cid:14)ciency. For particular forms of F (t), rigorous algebraic methods may be possible, such as

for example the prediction of time of collision of two needles (in(cid:12)nitely thin hard rods) [18],

and possibly spherocyllinders. However, this requires a considerable algebraic complexity

and is not easy to adapt to a new particle shape, especially ellipsoids, for which there is not

even a closed-form expression for the overlap potential.

In particular, the very elegant method for determining the time of collision of two needles

proposed in Ref.

[18] is related to the one proposed in Ref.

[10], and at its core is the
_F [10], i.e.,

need to determine a good local or global estimate of the Lipschitz constant of

an upper bound on

(these are used to construct rigorous under- or over-estimators of

F (t)). Such a global upper bound has been derived for the case of needles [c.f. Eq. (20) in
[18]], but for ellipsoids the expression for (cid:127)F (which we do not give here) is very complex and

(cid:127)F

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

we have not been able to generalize the approach in Ref.

[18]. As discussed in Ref.

signi(cid:12)cantly better results are obtained when local estimates of the Lipschitz constant of

[10],
_F

are available (i.e., upper bounds on

over a relatively short time interval), and this seems

(cid:127)F

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

17

an even harder task. Nevertheless, it is a direction worth investigating in the future.

For the purpose of EDMD, it is su(cid:14)cient only to ensure that an interval of overlap

[tc; tc + (cid:1)tc] is not missed if

min
tc(cid:20)t(cid:20)tc+(cid:1)tc

F (t) <

(cid:15)F ;

(cid:0)

(cid:0)

where (cid:15)F is some small tolerance, typically 10(cid:0)4

10(cid:0)3 in our simulations, or alternatively, if

(cid:1)tc > (cid:15)t. The use of (cid:15)F is preferable because it is dimensionless with a scale of order 1. This

essentially means that it is permissible to miss grazing collisions, i.e., collisions in which two

ellipsoids overlap for a very small amount and/or for a very short time. It certainly is not

productive to try to decide if two nearly touching particles are actually overlapping more

accurately then the inherent numerical accuracy of F (t). The choice of (cid:15)F is determined by

the relative importance of correctness versus speed of execution, as well as the stability of

the simulation. A large (cid:15)F can lead to unrecoverable errors in the event-driven algorithm,

such as runaway collisions or increasing overlap between particles.

Homotopy methods can be used to solve problems such as (30). They typically trace

the evolution of the root of an equation (starting from t = 0 in this particular case) as the

equation is deformed from an initial simple form to a (cid:12)nal form which matches F (t) = 0

[46]. An ordinary di(cid:11)erential equation (ODE) solver can be used for this purpose. An

essential component in these methods is event location in ODE s, namely, methods which

solve an ODE for a certain variable f (t) and determine the (cid:12)rst time that f (t) crosses zero

[34, 35]. We have tested a (simple) ODE-based homotopy method for solving (30), however,

since the problem at hand is one-dimensional, one can directly apply ODE event location to

f (t)

F (t), using an absolute tolerance of (cid:15)F for the ODE solver, and locate the (cid:12)rst root

(cid:17)

tc directly more e(cid:14)ciently.

The ODE to solve is given by eq. (26) or (28). However, also needed is (cid:21)(t), and one has

the option of either explicitly evaluating (cid:21) at each time step (reusing the old value of (cid:21) as an

initial guess), or also including (cid:21)(t) in a system of ODEs using eq. (27) or (29). The second

option has the advantage that one no longer needs to explicitly evaluate (cid:21) (other then at the

beginning of the integration), however, it has the additional cost of two variables instead of

one in the ODE solver, which additionally leads to smaller time steps in the ODE integrator.

Our numerical experiments have indicated that at least in two and three dimensions it is

somewhat advantageous to explicitly evaluate (cid:21) and only include F (t) in the ODE. This may

be reversed for di(cid:11)erent particle shapes, depending on the relative complexity of evaluating

18

2

1.5

)
t
(
f

1

0.5

0

0

0.2

0.4

0.6

0.8

1

t

Figure 2: The time evolution of the overlap function FAB(t) during an ellipse collision. The overlap

function is evaluated on an adaptive grid, which has a smaller time step when FAB changes rapidly,

and a larger step when it is relatively smooth. The tracing stops when a zero crossing is detected.

(cid:21) versus evaluating _(cid:21).

Once (cid:21) is evaluated however, very little extra e(cid:11)ort is needed to evaluate F explicitly, so

it seems somewhat pointless to solve an ODE for F (t). We have developed a method with a
similar structure to ODE integration, but which uses explicit evaluation of both F and _F .
The basic idea is to take a small time step (cid:1)t, evaluate both F and _F at the beginning and
end of the step, and use these values to form a cubic Hermite interpolant ~F (t) of F (t) over

the interval (cid:1)t. A theoretically-supported estimate for the absolute error of the interpolant
can be obtained by comparing the interpolant ~F and F at the midpoint of the time step,

and this error can be used to adaptively increase or decrease the size of the step so as to

keep the absolute error within (cid:15)F . This is illustrated in Fig. 2. When the interpolant crosses

the F = 0 axes, the (cid:12)rst root of the interpolant is used as an initial guess in a safeguarded

Newton algorithm to (cid:12)nd the exact root tc. The initial time step (cid:1)t needs to be su(cid:14)ciently

small to make the initial error estimate valid, and can easily be obtained by estimating

a time-scale for the collision from the sizes and velocities of the particles involved in the

collision. Even if this initial guess is conservative, the algorithm quickly increases the step

to an appropriate value. We will refer to this algorithm as trace event location, since the

function F (t) is explicitly traced until a zero-crossing is found.

There are several details one needs to be attentive to when predicting collisions inside

an EDMD algorithm. For example, some pairs of particles may already be overlapping by

19

small amounts after having collided. In this case one can look at the sign of

_F to decide

whether the two particles are about to have a collision or just had a collision. Two particles

can have a collision after having collided without an intervening collision with third party

particles. This can always happen for aspherical particles, as noted in Ref. [18], and it can

also happen for spheres when boundary deformations are present (since the particles travel

along curved paths), however, it cannot happen for spheres in traditional EDMD algorithms.

If the initial F is very close to zero, an additional safety measure is to add a small positive

correction to F to ensure that it is su(cid:14)ciently far from zero at the beginning of the search

(as compared to the accuracy in the evaluation of F (t)). In particular, such precautions are

necessary at very high densities (i.e., near jamming).

1. Predicting Collisions for Ellipsoids

We sketch the procedure for predicting collisions between two moving ellipsoids in Algo-

rithm 2. Features in Algorithm 2 include limiting the number of steps in the event location

algorithm to avoid wasting resources on predicting collisions that may never happen, as well

as allowing the exact prediction to fail. This algorithm (cid:12)rst uses collision prediction for the

bounding (or contained) spheres, in order to eliminate obvious cases when the particles do

not collide, and to identify a short search interval for the event location by calculating the

time interval during which the enclosing spheres overlap. Recall that when the boundary

is not deforming this step entails solving a quadratic equation, while it involves solving a

quartic equation when the lattice velocity is nonzero. In this context not only the (cid:12)rst root

of this quadratic/quartic equation needs to be determined, but also the second one, giving

the interval of overlap. It may be possible to further improve the initial collision prediction

step by using a bounding body other than spheres, for example, oriented bounding boxes

(orthogonal parallelepipeds) [15, 21]. However, orientational degrees of freedom need to be

eliminated since they are too hard to deal with because of the appearance of trigonometric

functions. For example, the bounding body can be a cylinder whose axis is the axis of

rotation of the ellipsoid and whose radius and length are su(cid:14)cient to bound the rotating

ellipsoid for all angles of rotation.

An important problem we have encountered in practice is the numerical evaluation of

GB when predicting the time of collision of an ellipsoid with its bounding neighborhood.

20

Namely, as the particles move, it is highly likely that a point where Y is singular will be

encountered. At such points the evaluation of GB is numerically unstable and often leads to

unacceptably small time steps. We have dealt with this problem in an ad hoc manner, by

simply trying to skip over such points, so that the search for a collision can be continued,

but a more robust and systematic approach may be possible.

Algorithm 2 Predict whether two moving ellipsoids overlap during the time interval [0; T ]
by more than (cid:15)F , and if yes, calculate the time of collision tc 2

[0; T ]. Essentially the same

procedure can be used to determine the time a particle A collides with its bounding
neighborhood B. If the prediction cannot be veri(cid:12)ed, return a time ~tc < tc before which a

collision will not happen. Also return (cid:21) at the time of collision if desired.

1. For all intervals of overlap of the bounding spheres of A and B (or for all intervals during

which the bounding sphere of A intersects the shell between the contained and bounding

sphere of its bounding neighborhood B), [tstart; tend], starting from t = 0 and in the order of

occurrence, do:

(a) If tstart > T , return reporting that no collision can happen.

min

(b) Set tend  
(c) Update the ellipsoids to time tstart, and evaluate the initial F and (cid:21).

T; tendg

f

.

(d) If F < (cid:15) (ellipsoids are overlapping or nearly touching), then evaluate _F and:

i. If

_F

(cid:21)

 

0 then set F

(cid:15) (the ellipsoids are moving apart),

ii. Else return tc = tstart (the ellipsoids are approaching).

(e) Use trace event location to obtain a good estimate of the (cid:12)rst root of F (t) during the

interval [tstart; tend], putting a limit on the number of time steps (for example, in the

range 100

250). If no root crossing is predicted, continue with the next interval in

(cid:0)

step 1. If the search terminated prematurely, then return the last recorded time ~tc = t.

(f) Bracket the estimated (cid:12)rst root of F (t) and re(cid:12)ne it using a safeguarded Newtonâ€™s

1
2 (tstart + tend), repeat step 1c and go back to

method (this may fail sometimes).

(g) If the root re(cid:12)nement failed, set tend  

step 1e (attempt to at least (cid:12)nd a valid ~tc).

2. Return reporting that no collision will happen.

21

B. Processing Binary Collisions

The steps necessary to process a binary collision between two hard particles are similar

for a variety of particle shapes, and essentially involves exchanging momentum between the

two particles. We give a recipe for colliding ellipsoids with a spherically symmetric moment

of inertia in Algorithm 3. To determine things like the pressure it is useful to maintain the

collisional contribution to the stress (cid:27)c [28], which is a suitable average of the exchange of

momentum over all collisions.

IV. PERFORMANCE RESULTS

In this section we present some results for the performance of the algorithm. Many

previous publications have given performance results for EDMD for spheres, and most of

these results apply to our algorithm. Exact numbers depend critically on details of the coding

style, programming language, compiler, architecture, etc., and are not reported here. Rather,

we try to get an intuitive feeling of how to choose the various parameters of the simulation to

improve the practical performance. Our main conclusion is that using NNLs is signi(cid:12)cantly

more e(cid:14)cient than using just the cell method for particles with aspect ratio signi(cid:12)cantly

di(cid:11)erent from one (greater than 2 or so) or at su(cid:14)ciently high densities. Additionally, using

BSCs o(cid:11)ers signi(cid:12)cant e(cid:14)ciency gains for very prolate particles, for which good bounding

sphere complexes can easily be constructed.

As derived in Ref.

[37], when only the cell method is used, optimal complexity of the

hard-sphere EDMD code is obtained when the number of cells is of the order of the number of

particles, Nc = (cid:2)(N ), with asymptotic complexity O(log N ) per collision, which comes from

the event-heap operations. In practice however the asymptotic logarithmic complexity is not

really observed, and instead to a very good approximation the computational time expanded

per processed binary collision is constant for a given aspect ratio (cid:11) at a given density, for

a wide range of relative densities (volume fractions) â€™. Even though in principle the basic

EDMD algorithm remains O(log N ) per collision, our aim is to improve the constants in

this asymptotic form, and in particular, their dependence on the shape of the particle (in

particular, the aspect ratio (cid:11)).

It is important to note that on modern serial workstations, the EDMD algorithm we have

22

presented here is almost entirely CPU-limited, and has relatively low memory requirements,

even when using NNLs and BSCs. Floating point operations dominate the computation, but

memory tra(cid:14)c is also very important. In our implementation, simulating ellipsoids is about

an order of magnitude slower than simulating spheres, even for nearly spherical ellipsoids,

simply due to the high cost of the collision prediction algorithm (the same observation is

reported in Ref.

[18]) and increased memory tra(cid:14)c. For example, on a 1666 MHz Athlon

running Linux, our Fortran 95 implementation uses about 0:1ms per sphere collision for a

wide range of system sizes and densities. With all the improvements described in this paper,

and in particular, the use of NNLs and BSCs, our implementation uses about 2ms per

ellipsoid collisions for prolate spheroids, and about 2

4ms for oblate spheroids at moderate

densities for a wide range (cid:11) = 1

10. Including boundary deformations, i.e., solving quartic

(cid:0)

(cid:0)

instead of quadratic equations when predicting binary collisions, slows down the simulation

for spheres by about a factor of 2:5 (we use a general quartic solver, and better results may

be obtained for a specialized solver).

A. Tuning the NNLs

We have performed a more detailed study of the performance of the algorithm when NNLs

are used, since this is a novel technique and has not been analyzed before. We perform an

empirical study rather then a theoretical derivation because such a derivation is complicated

by the fact that the neighborhoods evolve together with the particles, and because the

numerous constant factors or terms hidden in the asymptotic expansions of the complexity

actually dominate the practical performance.

Computationally, we have observed that it is good to maximize the number of cells Nc,

even at relatively low density â€™

0:1, especially for rather aspherical particles. This is

(cid:25)

because binary collision predictions become much more expensive than predicting or han-

dling transfers, and so the saving in not predicting collisions unnecessarily o(cid:11)sets the higher

number of transfers handled. Consistent with the results reported in [37], we observe that

the number of checks due to invalidated event predictions is comparable and sometimes

slightly larger than the number of collisions processed, and this suggests that additional

improvements in this area might increase performance noticeably.

We have tested both methods for updating the neighbor lists, the complete and the partial

23

update. A complete update/rebuild of the near neighbor lists after they become invalid is

the traditional approach in most TDMD algorithms appearing in the literature. Since MD

is usually performed on relatively homogeneous systems, when one particle displaces by a

su(cid:14)cient amount to protrude outside of its bounding neighborhood, most particles will have

displaced a signi(cid:12)cant amount, and so rebuilding their NNLs is not so much of a waste of

computational e(cid:11)ort. The main advantage of this approach is that it can be used to build

NNLs when a good estimate of (cid:22)cuto(cid:11) is not available, but rather a bound on the number of

neighbors per particle Ni is provided (this is very useful, for example, in the very early stages

of the Lubachevsky-Stillinger algorithm, when particles grow very rapidly). Additionally,

the algorithm for rebuilding the lists is simpler and thus more e(cid:14)cient. Finally, a complete

rebuilding of the NNLs yields neighbor lists of higher quality, in the sense that the structure

of the network of bounding neighborhoods is better adapted to the current con(cid:12)guration of

the system and thus the size of the neighborhoods is maximal.

The algorithm for partial updates on the other hand is more complicated, and to our

knowledge has not been used in MD codes. It requires using dynamic linked lists, and it

will in general yield smaller average neighborhood size than a complete update, since the

particle whose NNL is being updated must adjust its list without perturbing the rest of

the NNLs. Note that at the beginning the NNLs must be initialized by using a complete

update. The main advantage of the partial update scheme is that it is more (cid:13)exible in

handling nonisotropic systems or the natural (cid:13)uctuations in an isotropic one. Just because

one particle happened to move fast and leave its neighborhood does not mean that all

particles move that fast. This is especially true at lower densities where clustering happens.

In clusters particles have more collisions per unit time and thus require fewer updates of the

NNLs, but outside clusters particle move large distances without collisions and thus require

more frequent updates of their NNLs. In this sense partial updates are local in nature while

complete updates are global. We have indeed observed that in most cases it is advantageous

to use partial updates, rather then the traditional complete updates.

The (cid:12)rst and most important test is to determine whether using near neighbor lists o(cid:11)ers

any advantages over using just the cell method. The following intuitive arguments seem

clear:

(cid:15)

At very high densities, when the system of particles is nearly jammed [42], using NNLs

24

is optimal, regardless of the aspect ratio of the particles. This is because the particles

move very little while they collide with nearly the same neighbor particles over and

over again (see Fig. 8). Therefore near jamming the NNLs are rarely updated and by

predicting the collisions only with the particles with which actual collisions happen

signi(cid:12)cant savings can be obtained. However, as the density is lowered, the lists need

to be updated more frequently and the complexity of using NNLs becomes signi(cid:12)cant.

(cid:15)

(cid:15)

At very low densities the cell method is faster, even for very aspherical particles. This

is because a particle will have many collisions with the bounding neighborhoods before

it undergoes a binary collision, so that the cost is dominated by the cost of maintaining

the NNLs instead of processing collisions.

The more aspherical the particles, the more preferable the NNL method becomes

compared to the cell method. This is because for very elongated particles at reasonably

high densities there will be many particles per cell so using the cell method will require

predicting many binary collisions that will never happen, while the NNL method will

predict collisions with signi(cid:12)cantly less (truly) neighboring particles. For large (cid:11),

the dominating cost is that of rebuilding the NNLs (since this step uses the cells),

and therefore the primary goal becomes to minimize the number of NNL updates per

number of binary collisions processed, as well as to improve the e(cid:14)ciency of the NNL

rebuild, i.e., using BSCs.

Our experimental results shown in Fig. 3 support all of these conclusions. We show the

ratio of the CPU time expanded per processed binary collision for the NNL method and for

the traditional cell method. We show results for equilibrium systems of prolate spheroids of

aspect ratios (cid:11) = 1; 3 and 5 at densities â€™ = 0:1; 0:3; 0:5 and 0:6. Note that hard spheres

jam in a disordered metastable state at around â€™ = 0:64, and that for the case (cid:11) = 5 we

use â€™ = 0:55, since the jamming density is slightly lower than 0:6 for this aspect ratio [12].

In Fig. 3(a) we show the relative slowdown caused by using NNLs for the systems for which

using the cell method is better. In Fig. 3(b) we show the relative speedup obtained by using

NNLs for the systems for which it is better to use NNLs. Both the results of using partial

and complete updates are shown.

As explained in the (cid:12)rst part of this series of papers, we use two techniques to limit the

number of neighbors that enter in the NNLs. The (cid:12)rst one is to simply use the upper bound

25

on the number of neighbors (interactions) Ni to choose only the nearest Ni neighbors per

particle, and the second one is to choose a relatively small cuto(cid:11) (cid:22)cuto(cid:11) for the maximal size

of the bounding neighborhood

(i) (compared to the size of the particle i). In practice, only

N

the second approach can be used with partial updates. This is because partial updates must

work under the limitations of doing as little change to the NNLs as possible, and this requires

that there be enough room to add and remove interactions from the lists as necessary. So

when using partial updates one must set (cid:22)cuto(cid:11) to a reasonable value and then set Ni to be

larger then the maximal number of neighbors a particle will have given the cuto(cid:11) (cid:22)cuto(cid:11) and

an unlimited Ni. Reasonable values for spheres and not too aspherical particles are to set

(cid:22)cuto(cid:11) so that on average each particle has about 5

7 neighbors in two or 11

15 neighbors

(cid:0)

(cid:0)

in three dimensions (the kissing number for spheres is 6 in two and 12 in three dimensions),

while setting Ni at about 10 in two and 20 in three dimensions.

Since we wish to compare partial and complete updates, we change (cid:22)cuto(cid:11) and always

set Ni to a su(cid:14)ciently high number (which grows sharply with (cid:22)cuto(cid:11)), and compare partial

and complete updates in Fig. 3. As expected, there is an optimal value of (cid:22)cuto(cid:11) which is

larger for complete updates (for which NNL updates are signi(cid:12)cantly more expensive) and

also at lower densities. Note however that sometimes the computation speed may change

discontinuously as (cid:22)cuto(cid:11) is increased because at some point more than (cid:12)rst-neighbor cells

need to be searched during the NNL update. Important observations to note include the

fact that tuned partial NNL updates almost always outperform tuned complete updates, and

are thus preferred. Another useful observation is that the computation time is not very

sensitive to the exact value of (cid:22)cuto(cid:11). Finally, note that as much as an order of magnitude of

improvement is achieved for rather aspherical particles at high densities by using the NNLs.

This would be even more pronounced for larger aspect ratios such as (cid:11) = 10.

For large aspect ratios, the dominant cost is that of rebuilding the NNLs, during which

many particle pairs need to be tested for neighborhood. Therefore, the most important factor

for the speed of the simulation is how many particles need to be examined as potential near

neighbors of a given particle i when rebuilding NNL(i). If bounding spheres are not used, this

number is proportional to the number of particles that can (cid:12)t in a cell of length (cid:11), i.e., a cube

of volume (cid:11)3. For prolate spheroids this number is proportional to (cid:11)2, but for oblate ones it

is only proportional to (cid:11). Therefore the simulation of, for example, (cid:11) = 10, is prohibitively

expensive for prolates, but not for oblates. As the results in Fig. 4 demonstrate, using

26

BSCs signi(cid:12)cantly increases the speed of processing collisions for very prolate spheroids.

In this (cid:12)gure we show the approximate speedup obtained by using BSCs for tuned partial

updates for a range of moderate densities and a range of aspect ratios. As expected, at

large densities there are very few updates to the NNLs and therefore using BSCs does not

o(cid:11)er a large speedup. For oblate spheroids in the same range of aspect ratios, using BSCs

does not o(cid:11)er computational savings, and therefore we do not show any performance results.

However, it is important to note that when using NNLs (at su(cid:14)ciently high densities) and

BSCs (at su(cid:14)ciently high aspect ratios) the actual (tuned) processing time per collision is

approximately the same for any ellipsoid shape in this range of aspect ratios, somewhere

in the range 1

5ms per binary collision in our implementation. Therefore, for practical

(cid:0)

purposes, we feel that the algorithms presented in this paper can handle a wide range of

ellipsoid shapes very well.

With the use of BSCs, prolate ellipsoids are handled much better and the scaling reduced

to nearly independent of (cid:11) (note that one needs to examine (cid:11) bounding spheres per particle,

which is much less expensive than looking at neighbor particles, but still not free), as we

have demonstrated above. It remains a challenge to (cid:12)nd a technique that will also reduce

the scaling to nearly independent of (cid:11) for oblates as well. Additionally, it is important to

develop a theoretical analysis of the performance of the novel steps in the algorithm, and

in particular, to give estimates of the number of particles which need to be examined when

building the NNLs (per particle), the number of NNL updates which need to be processed

per binary collision (per particle).

1. Automatic Tuning of (cid:22)cuto(cid:11)

It is important to note that it is possible to automatically tune (cid:22)cuto(cid:11) during the course of

the simulation, at least in a rough way, so that the optimal computation speed is approached.

This is very important in the Lubachevsky-Stillinger packing algorithm, since there the den-

sity is not constant but rather increases until jamming is reached. Clearly in the beginning

a larger (cid:22)cuto(cid:11) is needed, while near the jamming point (cid:22)cuto(cid:11) can be set very close to 1.

By monitoring the fraction of events which are collisions with a bounding neighborhood,

and other statistics, one can periodically adaptively increase or decrease (cid:22)cuto(cid:11) during the

course of the simulation. We have successfully used such techniques to speed the process

27

of obtaining hard-particle packings, for both spheres and ellipsoids, especially for elongated

ellipsoids, but do not report details here.

V. APPLICATIONS

In this section, we present three interesting physical investigations that could not have

been undertaken without the algorithm presented in this series of papers. In Section V A, we

illustrate how collision-driven molecular dynamics can be used to generate tightly jammed

packings of ellipsoid with densities far surpassing previously achieved ones. In Section V B,

we show equation-of-state curves for quasi-equilibrium melting of an unusually dense crystal

ellipsoid packing [11]. Finally, in Section V C we show how the near neighbor lists can

be used to monitor the collision history near the jamming point and observe contact force

chains.

A. Generating Jammed Packings

We have used our collision-driven MD algorithm to implement a generalization of the

Lubachevsky-Stillinger sphere packing algorithm [24, 25] for ellipses and ellipsoids [12]. The

method is a hard-particle molecular dynamics (MD) algorithm for producing dense disor-

dered as well as ordered packings. Small ellipsoids are randomly distributed and randomly

oriented in a box with periodic boundary conditions and without any overlap. The ellipsoids

are given velocities and their motion followed as they collide elastically and also expand uni-

formly, using the event-driven algorithm. After some time, a jammed state with a diverging

collision rate and maximal density is reached. Based on our experience with spheres [22],

we believe that our algorithm produces (cid:12)nal states that are jammed, an in particular, that

are collectively jammed. In short, a collectively jammed con(cid:12)guration of particles is one in

which no subset of particles can simultaneously be continuously displaced so that its mem-

bers move out of contact with one another and with the remainder set [13, 42]. The resulting

packings are signi(cid:12)cantly denser that have previously been obtained for ellipsoids using RSA,

sedimentation, or shaking (MC-like) packing protocols [4, 5, 7, 36]. High packing densities

have been obtained for spherocylinders using a force-biased MC method [47], however, we

believe that these packings are not truly jammed. Additionally, spherocylinders cannot be

28

oblate or spherically asymmetric.

Several features of the molecular dynamics algorithm are necessary for the success of this

packing protocol. First, provisions need to be made to allow time-dependent particle shapes,

and we have explicitly included them in the treatment in Section II D. Most importantly,

a very high accuracy collision resolution is necessary at very high densities, especially near

the jamming point. For this reason, a time-driven approach cannot be used to generate

jammed packings, and special care needs to be taken to ensure high accuracy of the overlap

potentials and the time-of-collision predictions, as is done with Newton re(cid:12)nement in our

algorithms. Finally, the use of neighbor lists signi(cid:12)cantly improves the speed of the algorithm

since most computation is expended on the last stages of the algorithm when the particles

are almost jammed and the use of neighbor lists is optimal (particularly combined with

adaptive strategies for controlling (cid:22)cuto(cid:11)). Including a deforming boundary in the algorithm

additionally allows for a Parinello-Rahman-like adaptation of the shape of the unit cell,

which leads to better (strictly jammed [13, 42]) packing of the particles (see Section V B).

We have also implemented a hard-wall spherical boundary in our algorithm, for the pur-

pose of comparing our packings with experimental packings of MM candies and/or man-

ufactured ellipsoids in spherical containers. The full results of these investigations will be

presented in forthcoming publications [26], and here we just give an indication of the possibil-

ities. To save time and implementation e(cid:11)ort, we used lattice boundaries (without periodic

boundary conditions) and employed a trick to implement the spherical boundary. Speci(cid:12)-

cally, we put a spherical container inside a cube and then added special code in the handling

of the boundary conditions to predict and process collisions with the hard walls. This was

not di(cid:14)cult to do because the spherical container is a special case of an ellipsoid and we

already have well-developed tools to deal with collisions between a small ellipsoid contained

within a larger one, as presented in Section II B. In fact, implementing true (cid:13)at hard walls

is more di(cid:14)cult for ellipsoids as it necessitates the development of new overlap potentials.

Figure 5 shows one of our ellipsoid packings with an unusually high density. The properties

of this computer-generated packing compare very well to actual experimental data. In Fig.

6 we show how the packing density varies with the radial distance7, clearly illustrating the

7 This is an approximation to the true density since it is rather nontrivial to exactly evaluate the volume

of intersection of two ellipsoids.

29

layering of the particles near the hard walls and also the fact that the density inside the

core of the container has a remarkable value of about 0:74, which closely matches results

obtained using periodic boundary conditions and experimental results [12, 26].

B. Melting Dense Ellipsoid Crystals

Hard-particle systems are athermal, and the thermodynamic properties are solely a func-

tion of the density (volume fraction) (cid:30) [1]. It is well-known that in three dimensions hard-

sphere systems have a stable low-density (cid:13)uid (isotropic) phase and a stable high-density

solid (face centered cubic, FCC, crystal) phase, with a (cid:12)rst-order phase transition at in-

termediate densities [41]. Determining the exact transition densities is rather di(cid:14)cult and

requires evaluating free energies via thermodynamic integration [19]. Nevertheless, the (cid:12)rst-

order phase transitions can be directly observed in molecular dynamics simulations, and the

relevant dynamics (nucleation or relaxation) studied. In MD, one usually studies equilibrium

properties by starting with a nonequilibrium system at a given density and then allowing it

to equilibrate for a su(cid:14)ciently long time. An alternative is to very slowly change the den-

sity in a quasi-equilibrium manner while tracking the relevant properties such as pressure

or order-parameters. This kind of procedure allows one to directly observe the process of

melting of the high-density crystal or the freezing of a liquid, and identify approximately

the transition points. The collision-driven MD algorithm we have presented is ideally suited

for such a study. Namely, by imposing a very small rate of expansion/contraction (cid:13) of

the particle extents, one can continuously change the density while keeping the system in

quasi-equilibrium.

By starting with a low-density isotropic (cid:13)uid and very slowly increasing the density, one

can produce a superdense liquid and then observe a (cid:12)rst-order freezing transition as soon as

the metastable (cid:13)uid becomes unstable, typically when the density approaches the maximal

density of coexistence (as also observed in Ref. [40]). This freezing is a nucleation-activated

(rare-event) process (the dynamics of which can be observed) and does not lead to perfect

crystallization, but is clearly visible as a discontinuous pressure drop, as illustrated for hard-

spheres in the inset in Fig. 7. One can reverse the process by starting with a perfect

crystal, assuming that the stable high-density crystal structure is known, and slowly reduce

the density until the crystal melts, typically as the density approaches the minimal density

30

of coexistence, as illustrated in the inset in Fig. 7. In the (cid:12)gure, comparison is made to

the semi-empirical results for the liquid, solid, and coexistence regions for hard spheres in

the literature [40], and for ellipsoids comparison is made to scaled-particle theory for the

isotropic (cid:13)uid [38]. Unfortunately, direct coexistence is very di(cid:14)cult to observe in computer

simulations, and requires the creation of an arti(cid:12)cial interface between the two phases [27].

Additionally, it is in principle important to include unit cell dynamics in order to allow for

solid-solid transitions. However, it is di(cid:14)cult to do this in a stable manner across a range

of densities and in this study we (cid:12)x the unit cell.

For hard ellipsoids, it is not known what is the high-density crystal structure. One

can hope to identify candidate structures by densifying a liquid su(cid:14)ciently slowly to allow

for nucleation. By using the collision-driven algorithm with a very slow expansion and

small systems (6-16 particles), and with a deforming boundary, we were able to identify

crystal packings of ellipsoids that were signi(cid:12)cantly denser ((cid:30) = 0:771) than the previously

assumed crystal structure [11], namely, an a(cid:14)ne deformation of the hard-sphere crystal

(FCC, (cid:30) = 0:741) [1]. It is important to note that this discovery was made possible because

of the inclusion of boundary deformation into the algorithm, which allowed to sample a wide

range of crystal structures. In Fig. 7, we show the melting of this newly-discovered two-

layered ellipsoid crystal for an aspect ratio of p3 for prolate and 1=p3 for oblate spheroids.

The crystal melts into an isotropic (cid:13)uid and no nematic phase is observed, as can be seen

by monitoring the nematic order parameters, which rapidly goes to zero as the (cid:12)rst-order

transitions occur. For comparison, we also show the corresponding melting curves for the

ellipsoid crystal obtained by a(cid:14)nely stretching or compressing an FCC sphere crystal along

the (0; 0; 1) direction. Additionally, we try to observe the freezing of the isotropic liquid

by slow compression. However, it can be seen that despite the very slow compression the

liquid does not freeze but rather jams in a metastable glass. This illustrates that systems of

ellipsoids have a marked propensity toward (orientationally) disordered con(cid:12)gurations and

are very hard to crystallize. This is to be contrasted with the case of hard spheres where we

easily observe freezing at the same expansion rate. It is interesting to note that all of the

pressure curves have a marked linear behavior around the jamming density (cid:30)J when plotted
(cid:30)J)(cid:0)1, in agreement with free-volume theory

with a reciprocal pressure axes, i.e., P

((cid:30)

[32]. A close agreement between the results for prolate and oblate spheroids is seen.

Many questions concerning the stable and metastable phases for ellipsoids as a function of

(cid:24)

(cid:0)

31

density and aspect ratio(s) remain open, and the algorithm developed in this paper provides

a powerful tool for future studies.

It is important to point out that one can use MD to

locate the exact point of coexistence by calculating the free energy (i.e., the entropy for

hard-particle systems) by integrating the equation of state along a reversible path starting

from a con(cid:12)guration of known free energy, for both the (cid:13)uid and the solid phases.

In

particular, for the solid phase one needs to use special \single-occupancy-cell" constrained

MD, in which each particle is constrained to remain in a cell centered around its position

in the the close-packed con(cid:12)guration [48]. One can in fact use the bounding neighborhood

(i) as the cell for particle i, as was done for spheres in the so-called tether method for

N
calculating the entropy [39]. Only a minor modi(cid:12)cation to the EDMD algorithm we presented

is needed, namely, when a particle collides with its bounding neighborhood it should bounce

back elastically rather then rebuild its NNL, and the total pressure on the imaginary walls

of the bounding neighborhoods accumulated. Such investigations will be carried out in the

future.

C. Observing Contact Force Networks

In this series of papers, we have mostly focused on using near neighbor lists as a tool to

improve the e(cid:14)ciency of the collision-driven algorithm. However, using neighbor lists has

additional advantages as well. The most important one is that it allows one to monitor the

collision history of each particle or a pair of particles. This is especially useful for dense

hard-particle packings near the jamming point. In the very limit of a jammed packing, each

particle has a certain number of contacting geometric neighbors, and cannot displace from

its current position [13]. The network of interparticle contacts forms the contact network of

the packing, and this contact network can carry positive contact forces. For packings of soft

spheres, interacting with a di(cid:11)erentiable potential, it is easy to obtain contact forces near a

jamming point and observe the resulting force chains and the distribution of contact forces,

which has been noted to have an exponential tail in a variety of models of granular materials

[3].

At (cid:12)rst glance it may seem like force networks cannot be observed for hard particles

since forces are ill-de(cid:12)ned. Importantly, however, we now demonstrate that this is not true.

As the jamming point is approached, for example, via the Lubachevsky-Stillinger packing

32

algorithm, each particle collides repeatedly only with a small set of neighbors (which become

contacts in the jamming limit). By averaging the total exchanged momentum between each

pair of recently collided particles, one obtains a measure of the contact force between pairs

of particles (with some arbitrary proportionality constant). The resulting force network can

be monitored and recorded by tracking additional information for each interaction in the

NNLs, such as total number of collisions between the given pair of particles, total momentum

exchanged, etc. The resulting force chains in two dimensions are illustrated for a binary disk

packing in Fig. 8, to be compared with similar pictures in, for example, Ref. [3]. This force

network turns out to be almost in equilibrium, i.e., the total force (and torque for ellipsoids)

on each particle approaches zero, and this self stress [8] of the packing is in a sense what

causes (or certi(cid:12)es) the jamming of the particles [8]. The distribution of contact forces in a

three-dimensional hard-sphere packing is shown in Fig. 9, and matches similar results for

systems of soft particles reported in the literature.

VI. CONCLUSIONS

In this series of two papers, we have presented a practical event-driven molecular dynamics

algorithm for systems of ellipses and ellipsoids in some detail. The algorithm utilizes a

number of traditional techniques, and introduces a novel use of near-neighbor lists via the

concept of bounding neighborhoods. Furthermore, using bounding sphere complexes in

addition to neighbor lists signi(cid:12)cantly improves the handling of very aspherical particles.

We have proposed a general method for determining the time of collision of two particles of

any shape for which a smooth overlap potential can be constructed and easily di(cid:11)erentiated.

The application to ellipses or ellipsoids has been developed in detail.

We have identi(cid:12)ed a number of important directions for future investigation, which can

lead to signi(cid:12)cantly faster algorithms for very aspherical particles. First, predicting the

time of collision of two moving particles can be improved, either by using techniques other

than bounding spheres in order to narrow the search intervals during which a collision may

happen, or by improving the algorithm to search those intervals for a collision. In particular,

a new overlap potential for the case of one small ellipsoid contained within another large

ellipsoid is needed. The practical handling of bounding sphere complexes can further be

improved. More importantly, it is an open challenge to develop an algorithm to improve the

33

e(cid:14)ciency of building the near-neighbor lists for very oblate particles.

The three physical applications of the algorithm that we presented could not have been

undertaken with the same e(cid:14)ciency and accuracy without a collision-driven MD algorithm.

Our packing algorithm is unique in its ability to produce hard-particle packings which are

collectively jammed to a very high degree of accuracy (particle contacts reproduced to within

an accuracy of 10(cid:0)12) and compare well to experimental packings. The packings produced

by the algorithm are signi(cid:12)cantly more dense than those produced by previously reported

algorithms, which do not produce jammed packings and are less e(cid:14)cient. Our studies have

also enabled the discovery of the densest known ellipsoid crystals, bringing into question

previously reported phase diagrams for systems of ellipsoids in the high-density region. The

event-driven approach can also be used to e(cid:11)ectively study the thermodynamic properties

of ellipsoid packings, and, in particular, identify the equilibrium phases and observe the

dynamics of melting, freezing, and metastable liquids, at very high densities, i.e., close to

the relevant jamming point, be it a close-packed crystal, or a metastable glass. Finally, we

showed that one can gather collision statistics during the algorithm to obtain force chains

in true hard-particle packings, which have only been reported for soft particles.

ACKNOWLEDGMENTS

A. D. would like to thank H. Sigurgeirsson for his help with implementing the EDMD

event loop, L. F. Shampine and I. Gladwell for their advice concerning event location in

ODEs, and the freeglut library team for their help with visualization, as well as many

others who have contributed public domain codes used in this project. The authors were

supported in part by the Petroleum Research Fund under Grant No. 36967-AC9, and by

the National Science Foundation under Grant Nos. DMR-0213706 and DMS-0312067.

[1] M. P. Allen, G. T. Evans, D. Frenkel, and B. M. Mulder, Hard convex body (cid:13)uids, Advances

[2] M. P. Allen and D. J. Tildesley, Computer simulations of liquids, Oxford Science Publications,

in Chemical Physics 86 (1993), 1{166.

1987.

34

[3] J. Brujic, S. F. Edwards, I. Hopkinson, and H. A. Makse, Measuring the distribution of inter-

droplet forces in a compressed emulsion system, Physica A 327 (2003), 201{212.

[4] B. J. Buchalter and R. M. Bradley, Orientational order in random packings of ellipses, Phys.

[5]

, Orientational order in amorphous packings of ellipsoids, Europhys. Lett. 26 (1994),

Rev. A 46 (1992), no. 6, 3046{3056.

no. 3, 159{164.

[6] L. G. Casado, I. Garcia, and Ya. D. Sergeyev, Interval algorithms for (cid:12)nding the minimal root

in a set of multiextremal one-dimenisional nondiferentiable functions, SIAM J. Sci. Comput.

24 (2002), no. 2, 359{376.

[7] D. Coelho, J.-F. Thovert, and P. M. Adler, Geometrical and transport properties of random

packings of spheres and aspherical particles, Phys. Rev. E 55 (1997), no. 2, 1959{1978.

[8] R. Connelly, Rigid circle and sphere packings, Part I: Finite Packings, Structural Topology

[9]

, Rigid circle and sphere packings Part II: In(cid:12)nite Packings, Structural Topology 16

14 (1988), 43{60, See also Ref. 9.

(1991), 57{76, Second part of Ref. 8.

[10] P. Daponte, D. Grimaldi, A. Molinaro, and Ya. D. Sergeyev, An algorithm for (cid:12)nding the zero

crossing of time signals with lipschitzean derivatives, Measurement 16 (1995), 37{49.

[11] A. Donev, P. M. Chaikin, F. H. Stillinger, and S. Torquato, Unusually dense crystal packings

of ellipsoids, Phys. Rev. Lett. (2004), In press.

[12] A. Donev, I. Cisse, D. Sachs, E. A. Variano, F. H. Stillinger, R. Connelly, S. Torquato, and

P. M. Chaikin, Improving the density of jammed disordered packings using ellipsoids, Science

303 (2004), 990{993.

[13] A. Donev, S. Torquato, F. H. Stillinger, and R. Connelly, A linear programming algorithm to

test for jamming in hard-sphere packings, J. Comp. Phys. 197 (2004), no. 1, 139{166.

[14] David Eberly, I: Distance between ellipses in 2d ii: Distance between two ellipses in 3d, Magic

Software, Inc. http://www.magic-software.com.

[15]

, I: Dynamic collision detection using oriented bounding boxes ii: Intersection of ob-

jects with linear and angular velocities using oriented bounding boxes, Magic Software, Inc.

[16]

, I: Intersection of ellipses ii:

Intersection of ellipsoids, Magic Software,

Inc.

http://www.magic-software.com.

http://www.magic-software.com.

35

[17]

, Rotation representations

and

performance

issues, Magic Software,

Inc.

http://www.magic-software.com.

[18] D. Frenkel and J. F. Maguire, Molecular dynamics study of the dynamical properties of an

assembly of in(cid:12)nitely thin hard rods, Mol. Phys. 49 (1983), no. 3, 503{541.

[19] D. Frenkel and B. Smit, Understanding molecular simulation, Academic Press, 2002.

[20] Ronald Goldman, Cross product in four dimensions and beyond, Matrix Gems, vol. II, ch. II.8,

[21] S. Gottschalk, Collision queries using oriented bounding boxes, Ph.D. thesis, UNC Chapel Hill,

pp. 84{88, Academic Press, 1992.

Department of Computer Science, 2000.

[22] A. R. Kansal, S. Torquato, and F. H. Stillinger, Diversity of order and densities in jammed

hard-particle packings, Phys. Rev. E 66 (2002), 041109.

[23] X. Lin and T. T. Ng, Contact detection algorithms for three-dimensional ellipsoids in discrete

element modeling, Int. J. Num. Anal. Meth. Geomech. 19 (1995), 653{659.

[24] B. D. Lubachevsky and F. H. Stillinger, Geometric properties of random disk packings, J. Stat.

Phys. 60 (1990), 561{583, See also Ref. 25.

[25] B. D. Lubachevsky, F. H. Stillinger, and E. N. Pinson, Disks vs. spheres: Contrasting properties

of random packings, J. Stat. Phys. 64 (1991), 501{525, Second part of Ref. 24.

[26] W. Man, A. Donev, F. H. Stillinger, S. Torquato, and P. M. Chaikin, In preparation, 2004.

[27] J. R. Morris and X. Song, The melting lines of model systems calculated from coexistence

simulations, J. Chem. Phys. 116 (2002), no. 21, 9352{9358.

[28] M. Parinello and A. Rahman, Polymorphic transitions in single crystals: A new molecular

dynamics method, J. Appl. Phys. 52 (1981), no. 12, 7182{7190.

[29] J. W. Perram and J. Rasmussen, Ellipsoid contact potential: Theory and relation to overlap

potentials, Phys. Rev. E 54 (1996), no. 6, 6565{6572.

[30] J. W. Perram and M. S. Wertheim, Statistical mechanics of hard ellipsoids. i. overlap algorithm

and the contact function, J. Comp. Phys. 58 (1985), 409{416.

[31] E. Rimon and S. P. Boyd, Obstacle collision detection using best ellipsoid (cid:12)t, J. Intelligent and

[32] Z. W. Salsburg and W. W. Wood, Equation of state of classical hard spheres at high density,

Robotic Systems 18 (1997), 105{126.

J. Chem. Phys. 37 (1962), 798.

[33] H. Schaub, P. Tsiotras, and J. L. Junkins, Principal rotation representations of nxn orthogonal

36

matrices, Int. J. Eng. Sci. 33 (1995), no. 15, 2277{2295.

[34] L. F. Shampine, Numerical solution of ordinary di(cid:11)erential equations, Chapman and Hall,

1994.

[35] L. F. Shampine, I. Gladwell, and R. W. Brankin, Reliable solution of special event location

problems for odes, TOMS 17 (1991), no. 1, 11{25.

[36] J. D. Sherwood, Packing of spheroids in three-dimensional space by random sequential addition,

J. Phys. A 30 (1997), L839{L843.

[37] H. Sigurgeirsson, A. Stuart, and W.-L. Wan, Algorithms for particle-(cid:12)eld simulations with

collisions, J. Comp. Phys. 172 (2001), 766{807.

[38] Y. Song and E. A. Mason, Equation of state for a (cid:13)uid of hard convex bodies in any number

of dimensions, Phys. Rev. A 41 (1990), no. 6, 3121{3124.

[39] R. J. Speedy, The entropy of a glass, Mol. Phys. 80 (1993), no. 5, 1105{1120.

[40]

, Pressure of the metastable hard-sphere (cid:13)uid, J. Phys. Condens. Matter 9 (1997),

[41] S. Torquato, Random heterogeneous materials: Microstructure and macroscopic properties,

8591{8599.

Springer-Verlag, New York, 2002.

[42] S. Torquato and F. H. Stillinger, Multiplicity of generation, selection, and classi(cid:12)cation pro-

cedures for jammed hard-particle packings, J. Phys. Chem. B 105 (2001), 11849{11853.

[43] B. C. Vemuri, Y. Cao, and L. Chen, Fast collision detection algorithms with applications to

particle (cid:13)ow, Computer Graphics Forum 17 (1998), no. 2, 121{134.

[44] J. Vieillard-Baron, Phase transitions of the classical hard-ellipse system, J. Chem. Phys. 56

(1972), 4729{4744.

[45] W. Wang, J. Wang, and M.-S. Kim, An algebraic condition for the separation of two ellipsoids,

Comp. Aid. Geom. Design 18 (2001), 531{539.

[46] L. T. Watson, M. Sosonkina, R. C. Melville, A. P. Morgan, and H. F. Walker, Algorithm 777:

Hompack90: A suite of fortran 90 codes for globally convergent homotopy algorithms, TOMS

23 (1997), no. 4, 514{549.

[47] S. R. Williams and A. P. Philipse, Random packings of spheres and spherocylinders simulated

by mechanical contraction, Phys. Rev. E 67 (2003), 051301.

[48] L. V. Woodcock, Computation of the free energy of alternative crystal structures of hard

spheres, Faraday Discuss. 106 (1997), 325{338.

37

Algorithm 3 Process a binary collision between ellipsoids i and (j; v). Assume that the

particles have already been updated to the current time t, and that (cid:21) at the point of

collision is supplied (i.e., it has been stored for particle i , and also 1

(cid:21) in particle j,

when this collision was predicted).

(cid:0)

1. Calculate the Euclidean positions and velocities of particles rA, rB, vA and vB, as well as

their angular velocities !A and !B.

2. Find the contact point rC and normal velocity at the point of contact vn = ^nT vC, using the

3. If vn > 0, then return without further processing this (most likely grazing) mis-predicted

supplied (cid:21).

collision.

4. Calculate the exchange of momentum between the particles (cid:1)pAB = (cid:1)pAB ^n,

(cid:1)pAB = 2vn (cid:18)

1
mA

+

1
mB

+ k

rCA (cid:2)
IA

^n
k

+ k

rCB (cid:2)
IB

^n

k

(cid:19)

(cid:0)1

;

where m denotes mass and I moment of inertia.

5. Calculate the new Euclidean velocities of the particles,

as well as the new angular velocities

vA  
vB  

vA (cid:0)
vB +

(cid:1)pAB
mA
(cid:1)pAB
mB

^n

^n;

!A  
!B  

!A (cid:0)
!B +

(cid:1)pAB
IA
(cid:1)pAB
IB

(rCA (cid:2)
(rCB (cid:2)

^n)

^n) :

Optionally update any averages that may need to be maintained (such as average kinetic

energy) to re(cid:13)ect the change in the velocities.

6. Record the collisional stress contribution

(cid:27)c  

(cid:27)c (cid:0)

(cid:1)pAB

rAB ^nT

:

(cid:0)

(cid:1)

7. If using NNLs, record information about the collision that is being collected for the interaction

between i and (j; v), such as an accumulation of the total exchanged momentum for this

interaction, total number of collisions for this interaction, etc.

38

0

0

0.25

0.5

0.75
Cutoff (m

cutoff-1)

1

1.25

1.5

(a) Cell method wins

(C) a=1, f=0.3
(P) a=1, f=0.3
(P) a=3, f=0.1
(C) a=3, f=0.1
(C) a=1, f=0.5
(P) a=5, f=0.1
(C) a=5, f=0.1

(P) a=1, f=0.5
(P) a=1, f=0.6
(C) a=1, f=0.6
(P) a=3, f=0.3
(C) a=3, f=0.3
(P) a=3, f=0.5
(C) a=3, f=0.5
(P) a=3, f=0.6
(C) a=3, f=0.6
(P) a=5, f=0.3
(C) a=5, f=0.3
(P) a=5, f=0.5
(C) a=5, f=0.5
(P) a=5, f=0.55
(P) a=5, f=0.55

10

9

8

7

6

5

4

3

2

1

n
w
o
d
w
o
l
S

12

10

8

6

4

2

p
u
d
e
e
p
S

0

0

0.1

0.2

0.3
0.4
Cutoff (m

cutoff-1)

0.5

0.6

0.7

0.8

(b) NNL method wins

Figure 3: Performance results for using NNLs in addition to the traditional cell method for a

variety of aspect ratios (cid:11) and densities â€™ for prolate spheroids, with both partial (P) or complete

(C) updates.

39

a=2
a=4
a=6
a=8
a=10

8

7

6

5

4

3

2

1

p
u
d
e
e
p
S

0
0.1

0.2

0.3

Density f

0.4

0.5

Figure 4: Performance results for using BSCs for prolate spheroids at low to moderate densities.

Using BSCs does not appear to o(cid:11)er computational savings for oblate spheroids in the same (cid:11)

range.

40

Figure 5: A packing of N = 1; 000 ellipsoids with aspect ratios 0:8 : 1 : 1:25 inside a spherical

container. A cube enclosing the sphere is used as a pseudo-boundary for the purposes of the cell

method. The radial density pro(cid:12)le of a larger packing is shown in Fig. 6.

41

)
r
(

F

0.75

0.74

0.73

0.72

0

1

2

3

4

5

6

(R-r)/Omin

Figure 6: The (approximate) fraction (cid:8)(r) of a sphere of radius r (measured in units of the smallest

ellipsoid axes Omin) covered by the particles for a packing of N = 5; 000 ellipsoids like those in Fig.

5 inside a spherical container of radius R. Due to the lower density and ordering of the particles

next to the hard wall, one needs to eliminate several layers of particles close to the wall before (cid:8)(r)

reaches the core density of about (cid:8) = 0:74 (dashed line), surprisingly close to the highest possible

density for sphere packings. A simulation with periodic boundary conditions gives a bulk density

of about (cid:30)bulk = 0:735.

42

Coexistence
Fluid
Solid
FCC crystal melting
Liquid freezing

0
0.3

0.4

0.5

0.6

0.7

40

20

100

80

T
k
N
/
V
P

60

40

20

0
0.45

Scaled Particle Theory
FCC melting (P)
FCC melting (O)
Layered melting (O)
Layered melting (P)
Liquid freezing (P & O)

0.5

0.55

0.65

0.7

0.75

0.6
f

Figure 7: Equation-of-state (pressure-density) curves for prolate and oblate ellipsoids of aspect

ratios p3 and 1=p3 respectively, compared with spheres (inset), as obtained from quasi-equilibrium

collision-driven MD with N = 1024 particles. The temperature kT is maintained at unity by

frequent velocity rescaling and the \instantaneous" pressure and order parameters are averaged

and recorded every 100 collisions per particle. The unit cell is kept (cid:12)xed. (A) For hard spheres, a

perfect FCC crystal is slowly melted by reducing the density ((cid:13) =

10(cid:0)6) starting from (cid:30) = 0:7,

(cid:0)

and an isotropic (cid:13)uid is frozen by slowly compressed ((cid:13) = 10(cid:0)6) starting from (cid:30) = 0:4. Very similar

curves are obtained for both smaller

and for larger systems (we have used up to N = 10; 000

(cid:13)
j

j

particles), indicating that the observed curves are not dominated by (cid:12)nite-size or dynamical e(cid:11)ects.

(B) For hard ellipsoids, a very dense two-layered crystal [11] is melted from a density of (cid:30) = 0:73,

and similarly an a(cid:14)nely deformed FCC crystal is melted starting from (cid:30) = 0:7 ((cid:13) =

10(cid:0)6). An

(cid:0)

attempt to freeze an isotropic liquid on the other hand fails and leads to a jammed metastable glassy

con(cid:12)guration with (cid:30)

0:72 despite the slow expansion ((cid:13) = 10(cid:0)6), for both oblate and prolate

(cid:25)

ellipsoids. Investigating even slower expansion or larger systems is computationally prohibitive at

present, and hence the results should be interpreted with caution.

43

Figure 8: A network of interparticle forces (darker lines indicate stronger forces) in a binary disk

packing, as obtained by averaging the total exchanged momentum between colliding particles over a

long period of time during the (cid:12)nal stages of the Lubachevsky-Stillinger packing algorithm. Darker

particles collide more frequently then lighter ones.

44

y
t
i
l
i
b
a
b
o
r
P

0.8

0.6

0.4

0.2

0

0

0.1

0.01

)
f
(
P

0.001

0

1

2

3

4

5

f/F

1

2

3

4

5

Collision force

Figure 9: The probability distribution for contact forces in an almost jammed monodisperse three-

dimensional hard sphere packing (N = 10; 000 particles), along with a (cid:12)t of the form P (f )

(cid:24)
f 0:8e(cid:0)1:8f =F , where F is the mean force [3]. Only a single con(cid:12)guration was used, with density

(cid:30) = 0:6438, and the collisional forces (total exchanged momentum) were averaged over 10; 000

collisions per particle. The inset shows P (f ) on a logarithmic scale to emphasize the exponential

tail for large contact forces.

45

