6
9
9
1
 
c
e
D
 
7
2
 
 
]
h
p
-
p
m
o
c
.
s
c
i
s
y
h
p
[
 
 
1
v
3
1
0
2
1
6
9
/
s
c
i
s
y
h
p
:
v
i
X
r
a

An eﬃcient algorithm for testing the
generic rigidity of graphs in the plane

C. Moukarzel∗
H¨ochstleistungsrechenzentrum, Forschungszentrum J¨ulich,
D-52425 J¨ulich, Germany.

Given a structure made up of n sites connected by b bars, the problem of rec-
ognizing which subsets of sites form rigid units is not a trivial one, because of the
non-local character of rigidity in central-force systems. Even though this is a very
old problem of statics, no simple algorithms are available for it so the most usual
approach has been to solve the elastic equations, which is very time-consuming for
large systems. Recently an integer algorithm was proposed for this problem in two
dimensions, using matching methods from graph theory and Laman’s theorem for
two-dimensional graphs. The method is relatively simple, but its time complex-
ity grows as n2 in the worst case, and almost as fast on practical cases, so that an
improvement is highly desirable. I describe here a further elaboration of that proce-
dure, which relies upon the description of the system as a collection of rigid bodies
connected by bars, instead of sites connected by bars. Sets of rigidly connected
objects are replaced by a unique body, and this is done recursively as more rigid
connections between bodies are discovered at larger scales. As a consequence of
this “rescaling transformation”, our algorithm has much improved average behav-
ior, even when its worst-case complexity remains n2. The time complexity of the
body-bar algorithm is found to scale as n1.12 for the randomly diluted triangular
lattice, while the original site-bar version scales as n1.9 on the same problem.

I. INTRODUCTION

Consider a structure [1] made of n sites connected by b bars in d dimensions. Determining
the rigid properties of such systems constitutes a problem of obvious technological interest, which
has been under study for a long time already. The ﬁrst formal results date back to Maxwell
[3], who discussed the connections between statics and geometry. Posterior theoretical work in
the ﬁeld [5,7–9,12,21,25–27], has been accomplished by mathematicians and not widely known
among physicists, although the concept of rigidity appears in many ﬁelds of physics as for exam-
ple glasses [13,23], critical phenomena [14] and granular materials [15] among others.
The physicist’s treatment of this problem often reduced to a brute-force solution of the elastic
equations, because of the lack of a simple integer algorithm for the identiﬁcation of the rigid
clusters. In this work, recent progress in the design of such algorithms for the analysis of rigid
properties of generic lattices is reported. To do so, let us start by brieﬂy introducing some of the
basics of rigidity. In this section the main ideas will we qualitatively described, leaving for next
section more precise deﬁnitions, which will be done with the aid of the rigidity matrix. The inter-
ested reader is referred to the recent literature for more complete descriptions [8,9,12], alternative
approaches [21,24] and recent results [25–27] in the ﬁeld of rigidity.
A structure [1] is ﬂexible if it admits a continuous deformation (a ﬁnite ﬂexing) preserving all bar
lenghts, other than the trivial translations and rotations in euclidean space. Otherwise it is rigid.

∗

Present Address: Instituto de F´ısica, Universidade Federal Fluminense,

Niteroi RJ, Brazil.
email: cristian@if.uﬀ.br

1

Obviosuly if a structure admits a ﬁnite ﬂexing, then it also admits an inﬁnitesimal ﬂexing. If a
structure admits no non-trivial inﬁnitesimal ﬂexing, it is said to be inﬁnitesimally rigid. Obviously
a ﬂexible structure is also inﬁnitesimally ﬂexible. The converse is not always true, since there may
be special situations in which a structure is inﬁnitesimally ﬂexible but does not have ﬁnite ﬂex-
ings. Figure Ia shows an example of a structure that admits a ﬁnite ﬂexing, and therefore is not
rigid. If one more bar is added, the extra degree of freedom corresponding to the ﬂexing may be
eliminated. Figure Ib is an example of a structure which is both rigid and inﬁnitesimally rigid.
But the same triangle has special combinations of site locations for which inﬁnitesimal rigidity is
lost. This is exempliﬁed in Figure Ib, in which the three sites are aligned. As a consequence site 3
may be displaced by a small amount in the direction of the normal to bar 12, and all bar lenghts
remain unchanged to ﬁrst order in the displacement. Therefore this structure is inﬁnitesimally
ﬂexible though it is rigid to second order in the displacement.
These situations for which rigidity does not imply inﬁnitesimal rigidity are very rare. They only
occurr for a ’small’ set of site locations, which are called degenerate conﬁgurations. The comple-
ment of this set, the generic conﬁgurations, form an open dense subset of space. For a generic
conﬁguration, inﬁnitesimal rigidity is equivalent to rigidity. Conﬁgurations in which all site coor-
dinates are randomly chosen are with probability one generic (a precise deﬁnition will be provided
in next section).

a)

1

b)

1

c)

1

3

3

3

3’

2

2

2

FIG. 1. A simple illustration of the reasons by which a structure may fail to be inﬁnitesimally rigid
(cases a) and c) ) is provided by a triangle. Case a) is ﬂexible since it admits a continuous deformation.
Case b) is both rigid (no continuous deformation is possible) and inﬁnitesimally rigid (no inﬁnitesimal
deformation is possible). Case c) on the other hand provides an example of a degenerate conﬁguration,
for which the structure is rigid (there is no continuous deformation leaving all bar lenghts unchanged)
but not inﬁnitesimally rigid, since site 3 may be desplaced by an inﬁnitesimally small amount, and all
bar lengths would remain unchanged to ﬁrst order in the displacement. Failure to be inﬁnitesimally rigid
can be shown to be equivalent to the existence of zero-frequency modes in the linear approximation of the
vibratory behavior of the structure.

The importance of inﬁnitesimal rigidity can be easily understood in physical terms. One can
deﬁne a structure to be statically rigid if it is able to compensate, by means of suitable ﬁnite stresses
in its bars, any equilibrated load applied to its nodes. It is a classical ingeneering result that static
rigidity is equivalent to inﬁnitesimal rigidity (see [12]) for a proof.). Therefore inﬁnitesimal rigidity,
and not rigidity, is the relevant concept in the linear approximation of elasticity. Case a) in Fig. I
is obviously not statically rigid. Case c) is also not statically rigid because a load normal to bar
12 applied on site 3 cannot be compensated by ﬁnite stresses on the bars, which are all parallel
to 12.
When studying the oscillatory properties of a structure in the harmonic oscillator approximation,
inﬁnitesimal ﬂexibility is equivalent to the existence of degenerate, zero-frequency modes. Note
that cases a) and c) in Figure I both have zero-frequency modes, but for diﬀerent reasons. In

2

case a) because there is no restoring force, and in case c) because the restoring force is zero in the
linear approximation.
Throughout this work we will be concerned with the property of inﬁnitesimal rigidity, and therefore
we drop the preﬁx in the following. As suggested by the example in Fig. I, a structure can fail
to be rigid for two diﬀerent reasons. In the ﬁrst place, because it has too few bars, or they are
not correctly distributed. This has to do with the topology of the lattice, that is, depends on its
connectivity only, and not on the geometry of the structure. We will say that a given structure is
generically rigid if it has the required minimum number of “correctly distributed” bars. Generic
rigidity is a necessary condition for rigidity, but not a suﬃcient one. The importance of generic
rigidity resides in the fact that a generically rigid structure will be rigid for generic site locations.
Generic rigidity depends only on the number and location of the bars, and not on site locations.
In other words, generic rigidity depends only on the topological properties of the structure.
Topological information about a structure is conveniently represented by means of a graph G =
(V, E). Each site of the lattice is associated to a node a ∈ V , while bars are associated to edges
ab ∈ E. Nodes a and b are adjacent if edge ab exists. Edge ab is said to be incident to nodes a
and b and, conversely, nodes a and b are incident to edge ab. Graphs as described here contain
no information about the geometry of the system (site locations), but only about its connectivity
properties.
A graph contains enough information about a structure if we are only willing to discuss its generic
properties, i.e. those which are valid for “almost all” sets of site locations, except for those few
degenerate conﬁgurations, which will be ignored. It is only meaningful to do this if degenerate
conﬁgurations, and therefore lattices which are generically rigid but not rigid, are “exceptional”.
A context in which this is justiﬁed is when site locations (an assignment of site locations to the
nodes of a graph is called a realization of the graph) are randomly chosen. This ensures that
degenerate conﬁgurations have zero probability to appear, i.e. degenerate realizations are a zero
measure set. In view of this we would like to determine, from topological information only, whether
a given graph is generically rigid. A ﬁrst condition that must be satisﬁed is that the number b of
bars be large enough. Since n points in d dimensions have dn degrees of freedom and each bar
restricts one degree of freedom, b has to be at least equal to dn − d(d + 1)/2 [4], where d(d + 1)/2
is the number of distance-preserving linear transformations in d dimensions ( d translations and
d(d − 1)/2 rotations). But a right global count of bars is not enough to ensure rigidity, since bars
could be “crowded” on certain subsets of the graph, while others have less bars than needed to
make them rigid. If a certain subgraph has more bars than necessary, some of them are redundant,
and this subgraph is overconstrained. Bars which are not redundant are said to be (generically)
independent. A suﬃcient condition for (generic) rigidity is that the graph possesses dn− d(d+ 1)/2
(generically) independent bars. We see that the key point is being able to identify independent
bars. The basic theoretical tool for doing this in 2 dimensions is provided by a theorem due to
Laman [5].

Theorem 1 (Laman) The edges of a bar and joint graph G = (V, E) are generically independent
in two dimensions if and only if no subgraph G′ = (V ′, E′) has more than 2n’-3 edges.

Laman’s theorem constituted the ﬁrst graph-theoretic characterization of rigidity in 2 dimensions,
but in its original form it would give a very bad algorithm since it requires testing all possible
subgraphs, of which there is an exponentially large number. There are some equivalent restate-
ments of this theorem [10,12], some of which give rise to polynomial-time algorithms. Using one
such equivalence due to Sugihara, Hendrickson [16] has recently proposed an algorithm for testing
generic rigidity of two-dimensional graphs, which is simple enough to admit an on-lattice imple-
mentation [20]. Roughly described, Hendrickson’s algorithm consists in adding edges one by one
to the graph and matching [17,18] them to the nodes. If the matching succeeds, the new edge
is independent and is left on the system. If the matching fails, then a) the set of edges visited
during the failed search is mutually rigid, and b) the last edge is redundant. This algorithm has a
worst-case time complexity that scales as O(n2). One factor of n arises as edges are added one at
a time, while the degree to which the computational time is greater than n is determined by the
typical size of the search that must be performed in order to match each added edge. If O(n) sites

3

are mutually rigid, this size is of order n, and the algorithm is of order n2. However in this case
there is considerable time spent in searching over edges that have been previously identiﬁed as
mutually rigid. There is thus room for improvement, and this work is devoted to the description
of such an improved algorithm.

a)

b)

c)

FIG. 2.

In the bar-joint representation (a), each site of the lattice is associated to a node of the graph,
and bars are represented by edges. If sub-sets of rigidly connected sites (b) are combined into bodies and
represented by a node, we get the body-bar representation (c). The resultant structure is a multigraph
since several edges can connect a given pair of nodes. The process of replacing a set of rigidly connected
nodes by one node is called condensation.

To avoid the need to search over edges which have already been identiﬁed as mutually rigid, it is
natural to combine mutually rigid edges into clusters or “bodies” [11,15,23,24,26,27]. To develop
this idea into a workable algorithm, we note that any bar and joint graph can be considered as
being composed of bodies and bars, where eventually some of the bodies may be “trivial” bodies
with just one site. Each body is represented by a node in a multigraph. An example of this is
shown in Fig. 2. Each body, composed of several sites rigidly connected by bars, is shown as
a node in the multigraph of Fig. 2c. One of the advantages of the body-bar representation is
that the number of elements in the graph is smaller, and may be reduced each time a cluster of
rigidly connected bodies is identiﬁed, by replacing them by just one node in a process we will call
condensation.
Of course we have now to demonstrate that the idea is sound, and for that we must restate the
relevant theoretical results [16] in terms of bodies and bars. We start in section II by introducing
the rigidity matrix, which will help us to more precisely deﬁne the concepts of inﬁnitesimal rigidity,
generic rigidity, generic conﬁgurations and of redundant and independent bars, and also to discuss
the necessary conditions for generic rigidity. In section III we express Laman’s theorem in the
body-bar language, while section IV shows how Hendrickson’s algorithm is generalized for this
case. Section V discusses some practical implementation details. Also in this section the perfor-
mance of the body-bar algorithm here introduced is compared to that of the previously existing
joint-bar version. We will see that the body-bar algorithm has much better scaling properties for
the two examples analyzed, even when its worst-case behavior is the same as that of the joint-bar
algorithm, that is, O(n2).

II. RIGIDITY MATRIX FOR TWO-DIMENSIONAL BODY-BAR SYSTEMS

We will in the following only consider two-dimensional structures, unless explicitly stated other-
wise. Consider Fig. 2, in which the relationship between a bar-joint and a bar-body representation
is explicitly drawn. Any subset of rigidly connected bars and sites can be replaced by a body, a
rigid object that in two dimensions has 3 degrees of freedom, two displacements and one rotation.
We call all remaining bars external. Each body has a set of joints on its surface, to which external
bars are incident. We let xi be the location of joint i belonging to body a. An inﬁnitesimal motion

4

(1)

(2)

(3)

(4)

(5)

(6)

is a set of instantaneous velocities {vi}, one for each joint, which leave all bar lengths unaltered.
This condition is written:

(xi − xj) · (vi − vj) = 0

for every bar ij with i ∈ a, j ∈ b. We now express the velocities of the joints in terms of the
velocities of the body to which they belong. For this we select an arbitrary point xa for each body
a, and say that the velocity vi of any joint i of a body is equal to the velocity va of xa plus a
rotational component, which is ωa ∧ (xi − xa), where ωa is the angular velocity (a vector normal
to the plane) of body a, and ∧ indicates vector product.

vi = va + ωa ∧ (xi − xa)

Without loss of generality, we can choose all those arbitrary reference points xa to be at the origin
and get,

Now let us rewrite (1) by using (3), so that

vi = va + ωa ∧ xi

(xi − xj) · {(va − vb) + ωa ∧ xi − ωb ∧ xj} = 0

A little algebra shows that (4) can be reduced to,

(xi − xj ) · (va − vb) + (xj ∧ xi) · (ωa − ωb) = 0

This set of equations can be formally written as

˜M ~V = 0

where ~V is the vector of velocities and contains 3 entries for each body. Each row in ˜M corresponds
to a bar ij. Conditions (1), when written in the bar-joint representation, also give rise to a matrix
equation of the form (6). In the bar-joint representation only the ﬁrst term in (5) occurs, each row
of the rigidity matrix is associated with the vector (xj − xi), and there are 4 non-zero elements
per row. In the body-bar case, each row of the rigidity matrix is associated with the ‘line-bound
vector” (xj − xi, xi ∧ xj ) and there are 6 non-zero elements per row since xi ∧ xj is a pseudoscalar
in two dimensions. Line-bound vectors represent a force acting along a line [8] and, in contrast
to vectors, are not translationally invariant. They are only invariant under translations in the
direction (xi − xj ), meaning that a force can be moved along its line of action without changing
its eﬀect. Line-bound vectors have three independent components in 2d, two of them are needed
to determine the vector and the third one locates its line of action in the plane.
We will consider the general case of multigraphs formed by n bodies and m point-like (or “trivial”)
bodies, as in Fig. 4, which we denote as G(n, m). The general equations (5) or (6) hold for G(n, m)
with the additional constraint that the angular velocity wa = 0 for each of the m point-like bodies.
These additional constraints reﬂect the fact that rotation is irrelevant for them, so their angular
velocities can be arbitrarily ﬁxed, thus reducing the dimension of ~V . Counting the number of
degrees of freedom, we then ﬁnd (3n + 2m). The space of solutions of (6) has at least dimension
3, since two rigid translations and a rotation of the system as a whole leave all bar lengths un-
changed. This means that the rank of ˜M cannot be larger than K(n, m) = 3n + 2m − 3. The
system is said to be (inﬁnitesimally) rigid if the rigidity matrix has this maximal rank K(n, m),
which means that the only inﬁnitesimal motions are the Euclidean rigid transformations.
A realization is an assignment of site locations to all nodes of a graph. For certain (degenerate) re-
alizations, the rank of the rigidity matrix may be accidentally lowered by the existence of algebraic
dependencies between the node coordinates (degeneracies). This will only happen if a determinant
is zero, and given that determinants of the rigidity matrix are polynomials in the site coordinates,
degenerate realizations must satisfy a ﬁnite number of polynomial equations. Therefore the subset

5

of conﬁgurations for which the rigidity matrix attains the maximum possible rank over all sets
of coordinates constitutes an open dense subset. We say that a realization is generic if all site
coordinates are algebraically independent over the rationals. Therefore at a generic conﬁguration
the rank of the rigidity matrix attains its maximum value over the site coordinates.

a)

b)

c)

d)

FIG. 3. A simple body-bar structure for which: a) the bar set is independent, and the structure
is ﬂexible; b) the bar set is independent, and the structure is rigid; c) the bar set is dependent due
to an excess of bars, and the structure is rigid; and c) the bar set becomes dependent at a degenerate
conﬁguration, and the structure becomes inﬁnitesimally ﬂexible there. In this last case, the existence of a
common intersection point for three bars is a non-generic conﬁguration at which the rank of the associated
rigidity matrix is reduced from its generic value of 3 to a non-generic value 2. The extra eigenvector is
identiﬁed as an inﬁnitesimal relative rotation of the two bodies around the common intersection point.

A set of edges is independent if their associated rows in ˜M are linearly independent in an
algebraic sense. This means that an edge will be independent if and only if by removing it the
rank of the rigidity matrix is decreased by one. Cases a) and b) in Fig. II are independent, but
case a) is ﬂexible while case b) is inﬁnitesimally rigid.
If the removal of a given edge e does not alter the rank of ˜M , e is dependent or redundant.
Dependencies can arise because there are too many bars (for example the edge set in Fig. IIc) or
because of degenerate conﬁgurations. (for example three bars with a comon point as in Fig. IId).
The diﬀerence is that case c) is inﬁnitesimally rigid while case d) is not. The dependency produced
by the coincident intersection point has reduced the rank of the rigidity matrix from its maximum
value of 3 to a value of 2. There is therefore one extra inﬁnitesimal motion, which can be identiﬁed
as a relative rotation of the two bodies around the intersection point of the bars. A similar
reasoning holds for the example shown in Fig. Ic.
Once the atypical character of degeneracies is recognized, we are justiﬁed in ignoring them, and
concentrate on generic properties only. Therefore we deﬁne generic rigidity by saying that: A
structure is generically rigidy if its rigidity matrix attains its maximum rank K(n, m) at a generic
conﬁguration. The relevance of generic properties is ensured by a theorem due to Gluck [6].

Theorem 2 (Gluck) If a graph has a single inﬁnitesimally rigid realization, then all its generic
realizations are rigid.

In other words,
At a generic realization, a structure is inﬁnitesimaly rigid if and only if it is higher-order rigid if
and only if its multigraph is generically rigid
In addition to the already deﬁned property of generic site locations, we will assume the fol-
lowing generic incidence condition to hold: no 3 bars can be incident to the same joint
This condition means that bars incident to the same body are
of a non-trivial body.
In the following, whenever we refer to generic realizations of
located on generic lines.

6

multigraphs we will be assuming generic joint locations as well as generic incidence. No-
tice that multiple incidences are allowed if they occur on trivial (single-site) bodies. An
example of a multigraph that is generic in the sense required here is shown in Fig. 4.

FIG. 4. A multigraph that satisﬁes the generic incidence condition. No surface joint has more than

two incident bars. Point-like bodies can have an arbitrary number of incident bars.

Throughout this work we will assume all multigraphs G(n, m) to contain at least one non-trivial
body or two point-like ones, that is, n + m/2 ≥ 1. Excluded are then the graph with no nodes
and those with just one trivial (point-like) body. Under this condition the following results follow
almost trivially from our discussion of the rigidity matrix.

Theorem 3 Every rigid multigraph G(n, m) has a subset of K(n, m) independent bars.

Theorem 4 If a multigraph G(n, m) has more than K(n, m) bars, some are dependent.

Theorem 5 If a multigraph G(n, m) with exactly K(n, m) = 3n + 2m − 3 bars is rigid, then there
is no subgraph G′ with more than K(n′, m′) bars.

In the process of obtaining the bar-body representation from the bar-joint representation, we
have replaced subsets of rigidly connected sites by bodies with 3 degrees of freedom. This does
not change the number of independent inﬁnitesimal motions of the system, since these subsets,
being rigid, had 3 degrees of freedom each. This means that the dimension of the null space of
the rigidity matrix is the same in the bar-joint and bar-body representations. A consequence of
this is the following.

Theorem 6 A set E of external edges is dependent in the body-bar representation if and only if
it is dependent in the corresponding joint-bar representation.

Proof. The removal of an independent edge causes the rank of the rigidity matrix to change,
increasing by one the number of independent inﬁnitesimal motions. Assuming a given edge e ∈ E
to be dependent in one representation but not in the other would then conﬂict with our discussion
⋄
above.
Another result which we need for later use is the following.

Theorem 7 If an edge e incident to a non-trivial(trivial) body a and to some other body b 6= a is
dependent, then there exist at least 3(2) other edges {e′, e′′, e′′′}({e′, e′′}) incident to a which are
also dependent.

Proof: Let a be a non-trivial body and assume that and edge e incident to a is dependent. Take
the row of ˜M corresponding to e, which under the hypothesis can be expressed as a linear combi-
nation of other rows of ˜M , and consider its 3 components associated to the 3 degrees of freedom of

7

a. These are the 3 components of a line-bound vector, and are independent degrees of freedom in
a generic realization so that at least 3 other line-bound vectors (rows of ˜M ) are needed to express
it as a linear combination. The demonstration for the case in which a is a trivial body is similar,
except that vectors (2 degrees of freedom) take the place of line-bound vectors, and therefore only
2 other edges are needed.
⋄
We have introduced the rigidity matrix ˜M through a discussion of inﬁnitesimal rigidity, but it also
appears in the context of static rigidity, describing how external loads are resolved into stresses
on bars. Dependent subgraphs can then be identiﬁed to be those that can sustain equilibrated
internal stresses even in the absence of external loads.

III. LAMAN’S THEOREM FOR BODY-BAR SYSTEMS

A general graph-theoretic characterization of rigidity for linkages of bodies in n-space was ﬁrst
provided by Tay [11]. We will derive a similar result in two dimensions, which holds for the case of
mixed multigraphs, and which we need for our algorithm. Mixed multigraphs are those including
point-like bodies as well as non-trivial ones. Our derivation is based on Laman’s theorem for
bar-joint systems.

FIG. 5. The graph in this ﬁgure has no rigid realization in 3 dimensions, even when it has all the

required 18 = 3 × 8 − 6 bars, and no subgraph of it violates Laman’s condition b′ ≤ 3n′ − 6.

Theorems 3 and 5 imply that a rigid system must have a set of K(n, m) well distributed bars,
where the meaning of “well distributed” is that no subgraph has “too many” bars. This condition
is known, in the context of bar-joint systems, as Laman’s condition, and is a necessary condition
for rigidity in any space dimension (in a suitably generalized form). The converse, i.e. K(n, m)
well distributed bars ⇒ rigid does not hold in any dimension above 2. A counterexample in 3
dimensions, due to Whiteley, is shown in Fig. 5. This structure satisﬁes b′ ≤ 3n′ − 6 for all
subgraphs with n′ > 2, yet it is dependent and therefore non-rigid.
Laman was able to show [5] that the “correct distribution” of bars is a suﬃcient condition for
rigidity in 2 dimensions (Theorem 1 above). Here we translate his result to the body-bar case and
show that

Theorem 8 The edges of a multigraph G(n, m) = G(Vn, Vm, E) are independent in 2d if and only
if there is no submultigraph ˜G with more than 3˜n + 2 ˜m − 3 edges.

Proof. The demonstration of necessity, i.e. independent ⇒ well distributed, follows trivially from
Theorem 4 above. In order to demonstrate suﬃciency, we will transform the body-bar graph to

8

n, V ′

a bar-joint graph and use Laman’s theorem to show that, if a multigraph is dependent, there is a
subset of it with too many bars, i.e. a bad submultigraph.
Assume that a multigraph G = (Vn, Vm, E) contains a subset E′ of dependent bars. Let G′ =
m, E′) be the submultigraph of G deﬁned by restricting the edge set to E′ and the node sets
(V ′
to those nodes incident to some edge in E′. For each non-trivial body a ∈ V ′
n, let the cardinality ga
be the number of joints on its surface to which bars ab ∈ E′ are incident. According to Theorem 7,
in order for a non-trivial body a to belong to V ′
n, at least 4 of its incident bars must belong to
E′. This together with the condition of generic incidence (Section II) implies ga ≥ 2. A body of
cardinality ga ≥ 2 can be replaced by an isostatic bar-joint graph Ga made up of 2ga − 3 well
distributed “internal” bars and ga point-like bodies, these last taking the place of surface joints.
Doing this for each of the n′ non-trivial bodies in G′ leads to the expanded graph GE.

Theorem 6 implies that E′ is also dependent in the expanded graph GE, and since Laman’s
theorem in its original form applies to it, there must be a subgraph ˜GE = ( ˜V , ˜E) of GE with ˜b
bars and ˜m joints such that ˜b > 2 ˜m − 3.

We will have in general ˜b = ˜be +˜bi, where ˜be is the number of external edges and ˜bi the number of
internal edges in ˜E. ˜E cannot be entirely formed by internal edges since they are well distributed,
and therefore it must contain one or more external edges. Two cases are possible:
a) There are no internal bars in ˜E.
If this is the case none of the nodes of ˜GE can be the surface joint of a body. The reason for this
is Theorem 7. At least 3 bars incident to a point are dependent if one of them is. But if none
of them is internal the point cannot be a surface joint since at most 2 incident bars are allowed
per surface joint in generic multigraphs. This means that no bar in ˜E is incident to a subgraph
Ga. In this case the bad subgraph is entirely formed by point-like bodies and the result follows
immediately since Laman’s theorem is a particular case of this one (with n = 0).
b) There are one or more internal bars in ˜E, or equivalently, there is at least one edge e ∈ ˜E
incident to Ga for some body a.
If this edge e has both ends incident to the same Ga, then we have identiﬁed the bad sub-multigraph
as being formed by body a and this edge with both ends connected to it, since 1 = b > 3n − 3 = 0.
Then assume that no edge e ∈ ˜E has both ends connected to the same Ga. For each body a to
which some edge e ∈ ˜E is incident, let ˜Ga with ˜ga nodes and ˜ba edges, be the subgraph of Ga
contained in ˜GE. Let ˜ne be the number of such bodies, and ˜me the number of joints in ˜GE other
than surface joints. The condition that ˜GE be a bad subgraph is then rewritten

˜be +

˜ba > 2( ˜me +

˜ga) − 3

˜ne

X
a=1

˜ne

X
a=1

Theorem 7, together with the generic incidence condition, ensure that ˜ga ≥ 2. Since Ga are
independent by construction Laman’s condition then implies ˜ba ≤ 2˜ga − 3 . Using this and (7) we
get

, or

˜be +

˜ne

X
a=1

(2˜ga − 3) > 2( ˜me +

˜ga) − 3

˜ne

X
a=1

˜be > 2 ˜me + 3˜ne − 3

(7)

(8)

(9)

which ﬁnishes the demonstration for generic body-bar graphs.
⋄
Non-generic graphs, i.e. those with more than 2 bars incident to a joint of a body (we call this
“multiple incidence”) can also be handled by transforming them into an equivalent generic graph
in the following form. Notice that there is no limitation on the number of bars incident to point-
like bodies. Thus we can simply replace each multiple-incidence joint of a body by an auxiliary
structure made of a point-like node connected to the body by two new bars, like in Fig. 6. The
graph obtained by transforming in this way all multiple-incidence joints is generic in the sense

9

required here, and therefore the extended Laman’s theorem (theorem 8 above) applies to it. It is
easy to see that this transformed graph has equivalent rigid properties.

FIG. 6. A graph with a multiple-incidence joint (a surface joint with more than 2 incident bars) is not
generic. An equivalent (with the same rigid properties) graph that is generic can be obtained by detaching
the surface joint and connecting it to the body with two auxiliary bars (dashed lines).

IV. THE ALGORITHM

Laman’s theorem constitutes a graph-theoretic characterization of rigidity, but a naive im-
plementation of it, namely checking all possible subgraphs, would give a very poor algorithm.
Sugihara [10] and later Hendrickson [16] have used a reformulation of Laman’s theorem to pro-
pose eﬃcient (polynomial-time) algorithms for this problem. This section follows Hendrickson’s
approach, adapting his arguments to the body-bar case where needed.
We ﬁrst deﬁne the bipartite graph B(G) generated by a graph G(Vn, Vm, E) in the following way:
B(G) is composed of two sub-sets of nodes V 1 and V 2, and a set of edges connecting nodes of V 1
with nodes of V 2. There are no edges between nodes in the same subset (that is what deﬁnes a
bipartite graph). The ﬁrst subset V 1 is the set of edges E of G, while V 2 is composed of 3 copies
of the set of non-trivial nodes Vn plus 2 copies of the set of point-like nodes Vm. Edges of B(G)
connect the edges (ab) of G ( V 1 nodes) to all copies (V 2 nodes) of the bodies a and b to which
(ab) is incident. An example of this is shown in Fig. 7. We now brieﬂy describe some concepts
from graph theory which we need for our algorithm. The reader is referred to the literature on
the subject ( [17], [18]) for detailed accounts.

A

A

A’

A’’

C

C’

B

B’

B’’

1

4

3

2

B

C

a)

FIG. 7. The original graph G(Vn, Vm, E) has Vn = {A, B} (non-trivial bodies), Vm = {C} (point-like
bodies) and E = {1, 2, 3, 4} (edges). The bipartite graph B(G) derived from G has as node set the union
of V 1 and V 2. V 1 is the edge set of G, while V 2 is made of 3 copies of Vn plus 2 copies of Vm. Elements
of V 1 and V 2 are connected by and edge in B(G) if they are incident in G.

b)

1

3

4

2

10

V2

V1

A matching M of a graph is a subset of edges, no two of which share a node. Edges in M
are said to be matched, and edges not in M unmatched. Nodes incident to a matched edge are
covered, while the rest are exposed. If (ab) ∈ M, nodes a and b are mates. A matching M is
maximum if it has the largest possible number of edges. A matching is perfect or complete if no
node is exposed. Obviously, a perfect matching is also maximum. The matching problem (ﬁnding
maximum matchings) is a classic in graph theory, and has many practical applications. A path
is a chain of edges of the form {(ab)(bc)(cd) · · ·}, and it is alternating if matched and unmatched
edges follow each other in the succession. An alternating path {(ab)(bc) · · · (xy)} is an augmenting
path if both a and y are exposed nodes. The name is due to the obvious fact that any such path
allows one to increment the number of edges in the matching by one, simply by interchanging
matched ↔ unmatched along the path. Moreover, the problem of ﬁnding a maximum matching
can be reduced to that of ﬁnding augmenting paths, since

Theorem 9 M is maximum ⇐⇒ there are no augmenting paths.

Then a maximum matching is found by repeatedly discovering and inverting augmenting paths.
A particularly simple case is the matching of bipartite graphs, i.e. those whose node set V can be
partitioned into two subsets V 1 and V 2 such that no edge is incident to two nodes in the same
subset. The search for augmenting paths can be eﬃciently done by growing Hungarian Trees from
exposed nodes. They are built by breadth ﬁrst search (BFS) in the following way. Consider Fig. 8
in which thick lines represent edges in the current matching. We start the search for augmenting
paths from an exposed node v1 ∈ V 1. Take node 1 for example. Following all unmatched (thin)
edges incident from v1, go to nodes v2 in V 2. Since v1 is exposed it is incident to unmatched
edges only. In our example of Fig. 8 these edges lead to A, B. If any of these v2 nodes is exposed,
we have found an augmenting path. If not, their mates in v1 are sent to a queue Q for further
inspection. These mates are 2, 4 in this case. Nodes v2 are marked visited. Once all neighbors
of 1 have been exhausted without ﬁnding an exposed node, the next element v1 in queue Q is
taken. Say it is node 2. All unmatched edges incident to 2 are followed to v2 in V 2 and, if some
of them leads to an exposed node, the search is over. Otherwise, and if v2 was not visited before,
it is marked visited and its mate in V 1 is sent to Q. In our example this would result in node 3
being sent to Q. The search proceeds in this way until either an exposed node in V 2 is found , or
Q is depleted. In our example, after taking node 4 from Q we would ﬁnd node D exposed. The
matching can then be enlarged to cover node 1 by inverting the path D → 4 → B → 1. If on the
other hand Q is depleted without ﬁnding an exposed node in V 2, there is no augmenting path
from 1. We say in this case that v1 cannot be matched.

11

A

B

C

D

V2

V1

1

3
FIG. 8. A matching M (thick lines) can be enlarged to cover node 1 if an augmenting path is found.
Starting from 1 all unmatched (thin) edges are followed to nodes in V 2, and from them all matched edges
are followed back to nodes in V 1, in a breadth-ﬁrst manner. Repeating this procedure, an exposed node
D is found in V 2.
If now thin and thick edges are interchanged along the path 1 → D, the enlarged
matching is obtained.

4

2

Now we are ready to discuss some results needed for our algorithm. Using the relation between
G and B(G) we can give an equivalent formulation for the extended Laman’s theorem, which will
provide the basis for our algorithm.

Theorem 10 The following are equivalent:
A) The edges of G are independent in 2 dimensions.
B) For every edge ab in G, the multigraph Gab formed by quadrupling ab has no subgraph with
b′ > 3n′ + 2m′.
C) For each edge ab in G, the bipartite graph B(Gab) has no subset of V 1 that is adjacent only to
a smaller subset of V 2.
D) For each edge ab in G, B(Gab) has a complete matching from V 1 to V 2.

Proof: The equivalence of A) and B) is a trivial consequence of Laman’s theorem in its extended
form. The equivalence of B) and C) is an immediate consequence of the way in which Gab is
constructed. If such a subset exists, one would have b′ nodes of V 1 connected only to 3n′ +2m′ < b′
nodes of V 2. To prove that C) and D) are equivalent, it is easy to ﬁrst see that C) is necessary for
D). To prove that D) is necessary for C), assume that no complete matching exists. Then there
exists at least one exposed node x in V 1. Do a breadth ﬁrst search (BFS) in the following way
: Starting from x, follow all unmatched edges from V 1 to the nodes in V 2, and from them all
matched edges back to V 1 and so on. For each new node in V 1 found (including x), increment in
1 a variable k1, and for each new node in V 2 do the same with k2. Both k1 and k2 start from zero.
Each new node in V 2 leads automatically to a new node in V 1, because the hypothesis implies
that no exposed node can be found. Therefore when the BFS comes to an end (because all V 2
nodes have been visited once) we have that k1 = k2 + 1 and we have identiﬁed a subset of k1 nodes
of V 1 adjacent to only k1 − 1 nodes of V 2.
⋄
Theorem 3 means that, in order to recognize whether a given graph is rigid, we have to count
the number of independent bars it has, or equivalently, be able to detect how many of them are
dependent. Our rigidity testing algorithm will be based upon Theorem 10.D , and consists in
adding edges e one at a time to a set of independent edges ˆE, and testing whether this enlarged
ˆE′ is independent. If this is the case, e it is deﬁnitively added to ˆE, otherwise e is identiﬁed as a
dependent edge (e is not independent of ˆE) and removed from the graph.
Adding a new edge e to ˆE produces the graph G, and its associated bipartite graph B(G). We
know by Theorem 10.D that e is independent of ˆE if and only if a complete matching from V 1
to V 2 exists in B(Gab) when any edge ab in ˆE′ = e ∪ ˆE is quadrupled. Fortunately only the last

12

edge e needs be quadrupled, as the following result due to Hendrickson [16] demonstrates.

Lemma 11 Add a new edge e to an independent edge set ˆE. If a complete matching in the sense
of theorem 10 exists when e is quadrupled, then ˆE′ is independent.
Proof: assume ˆE′ is not independent. Then there must exist some edge e′ ∈ ˆE′ whose quadrupling
causes some subgraph G′ of G to have “too many edges”. This subgraph must include e since ˆE
is an independent set. But this subgraph would have the same number of edges if e is quadrupled
instead of e′, therefore a complete matching would not be possible if e is quadrupled.
⋄
Then in order to determine if a new edge e is independent of a set ˆE we have to enlarge a bipartite
matching to cover the 4 copies of the new edge e in V 1. If this cannot be done, e is redundant. We
have then an algorithm which enables us to identify redundant bars. But we also need a means
to identify rigid clusters in the system. The advantage of the body-bar representation over the
original formulation in terms of joints is that each new rigid cluster which is identiﬁed may be
replaced by one node, therefore reducing the size of the system. We will now see how these rigid
clusters are detected. For this we need the following results [16].

Theorem 12 If 3 copies of a new edge e are added to an independent set ˆE generating a graph
G′′, then B(G′′) has a complete matching from V 1 to V 2.

Proof: Assume there is no matching when e is tripled. Then there is some subgraph ˜G of G′′ for
which ˜b > 3˜n + 2 ˜m. Remove the 3 copies of e and quadruple any of the other edges. This graph
has the same number of edges as ˜G so it can also not be matched. But this is a contradiction if
ˆE is assumed to be independent.
⋄

Theorem 13 If the edge e is dependent and e is quadrupled, the failing Hungarian tree spans a
minimal subset of edges in ˆE which form an isostatic subgraph.

Proof. Since we added 4 copies of the new edge, the number of v1 nodes visited by the failing
Hungarian tree is b′ + 4, where b′ of them belong to E. The number of v2 nodes visited is
by construction of the bipartite graph 3n′ + 2m′. But in a previous demonstration, we saw that
when a BFS fails, it visits k1 nodes in V 1 and k2 nodes in V 2 with k1 = k2 + 1. Therefore,
b′ + 4 = 3n′ + 2m′ + 1, or b′ = 2m′ + 3n′ − 3, which is the condition for an isostatic subgraph.
This subgraph is minimal, since removing any of its edges would make the matching possible, by
freeing one v2 node.
⋄
The algorithm then proceeds as follows: Starting from a (possibly empty) set ˆE of independent
edges, test new edges e one by one by adding them to ˆE and trying to enlarge an already existing
matching of B(Ge), which contains four copies of e in V 1.

• If all four copies can be matched, the new edge e is independent. Remove the three extra

copies and add e to the set of independent edges ˆE.

• If the matching fails for the fourth copy of e (the ﬁrst three can always be matched), e is
dependent and the failing Hungarian tree identiﬁes a rigid subset of nodes. Remove all four
copies.

The rigid subgraph Ga identiﬁed by a failed search may be condensed to a unique body A. This
condensation step simply amounts to a deletion of all bars and bodies visited during the failed
search, and replacing them by a unique body. Therefore the amount of work involved in one
condensation is equivalent to that needed for one BFS. All bars incident to Ga are, after the
condensation, incident to body A. Condensation is only possible because we are able to handle
bodies, and is a key step in our algorithm.
Bars whose both ends are found to be connected to the same rigid body are not tested because
they are obviously dependent. This means that the same subset of nodes is not condensed twice,
so that each condensation involves at least one node which has never been condensed. Therefore

13

there will be at most n condensations. The condensation step requires just deleting all bars and
bodies in the failed Hungarian tree, therefore the total amount of work needed for condensations
is at most O(n), since there are at most O(n) bars in ˆE, and no bar is condensed twice.
A new bar leads either to a condensation or to a new element in ˆE. Both happen at most O(n)
times, so that at most O(n) tests are needed. Since each test involves growing four Hungarian
trees, each one taking (at most) a time proportional to the number O(n) of edges in ˆE, the algo-
rithm has a worst-case time complexity of O(n2).
This theoretical bound is the same as for Hendrickson’s algorithm [16]. It is not diﬃcult to un-
derstand why the worst-case complexity of the body-bar algorithm cannot be better than O(n2).
If no condensations ever occur, our algorithm is the same as Hendrickson’s. But this would only
happen if there are no redundant bars, since each redundant bar identiﬁes a rigid subgraph and
leads to a condensation. We can see that while the joint-bar algorithm has its worst-case perfor-
mance in all cases in which there is long-range rigidity [2], the body-bar algorithm can only be
pushed towards O(n2) behavior in the improbable case of long-range rigidity without redundancies
(long-range isostatic rigidity). This situation is not frequent in physical systems with disorder,
where rigidity is always redundant. Therefore we expect the body-bar version here introduced to
perform much better than the original joint-bar version on practical applications such as rigidity
percolation [20,19], glasses [13,23] or granular materials [15].

V. IMPLEMENTATION AND PERFORMANCE OF THE ALGORITHM.

The body-bar algorithm described in this work has been recently applied [19] to study rigidity
percolation on site diluted-triangular lattices. In this work we will present the comparison of per-
formance between this algorithm and the original site-and-joint version, for bond and site dilution
on triangular lattices. Bonds or sites are present on the lattice with probability p. Initially random
numbers are assigned to bonds in the following manner: In the bond dilution case, each bond ij is
assigned a random number brn(ij). For site dilution, sites i are given a random number srn(i)
and afterwards bonds are assigned brn(ij) = max(srn(i),srn(j)). In both cases, bonds are
sorted in order of increasing brn and tested in that order. The rest of the procedure is the same
for bond or site dilution. This scheme allows one to exactly detect the percolation point [19], but
is not the only possible. For example, one could ﬁx p to a certain value and, starting form an
empty system, test all bonds for which brn < p in arbitrary order. The time-complexity of the
algorithm depends on the order in which bonds are tested, although its results do not.
The graph data structure is stored using based (pointer) variables because in contrast to the reg-
ular lattice which originates it, the multigraph has no regularity, and its size changes during the
procedure, which makes static allocation of memory impractical. A new bond is tested by adding
four copies of it (V 1 nodes) to the bipartite graph and attempting to match them to the bodies (3
copies of each exist on the graph) or sites (2 copies of each) in V 2. If the four copies are matched,
the new bond is marked independent and its three additional copies are removed from the graph.
If the fourth copy is not matched, the new bond is marked redundant. The set of bonds covered
in the last search is in this case a rigid subgraph. This rigid subgraph is minimal, which means
that if any of its edges is removed then the matching would be possible. This subgraph identiﬁes
then the subset of E upon which e is dependent. The concept of dependence can be recast to
mean that a self-stress is possible, therefore the failing BFS identiﬁes the set of edges of G which
would be stressed if the new edge e is say, too long or too short. This feature of the algorithm is
very important in, for example, rigidity percolation [19], since it provides a means to identify the
stress-carrying part of a rigid cluster.
Each time a rigid subgraph is identiﬁed a routine condensation is called, which replaces all its
elements (enclosed bars and bodies) by a single body, putting three copies of it in the graph. All
external bars (bars incident to an enclosed body from a non-enclosed body) are now incident to
the new body. At a practical level the only diﬀerence with Hendrickson’s original algorithm is

14

this condensation step. If the replacement of rigid objects by one node is not done, one has the
original bar-joint algorithm. One must in this case [16] mark all enclosed objects with the new
rigid label to avoid the need to test bonds whose both ends are connected to the same rigid graph.
As mentioned in Section III, multiple incidence joints must be replaced by an auxiliary structure
in order to have an equivalent graph which is generic. In fact it is necessary to do this only in the
bond-diluted case, since for site dilution no multiple incidence points are possible. For simplicity
we always use auxiliary structures for incidence points to bodies, although they are only neces-
sary if the number of incident bars is larger than two (Section III). In this way the procedure is
much simpler (otherwise the number of incident bars should be checked after each condensation
or addition of a new edge) while the performance is not seriously aﬀected.
We saw already that rigid clusters will only be detected if a bond is tested on them, that is, if
a bond is found to be redundant. In other words, the algorithm naturally identiﬁes self-stressed
(hyperstatic) regions, while isostatic rigid clusters would go unnoticed if no bond is tested on them.
In the study of rigidity percolation [19], one is interested in detecting the exact concentration pc of
bonds at which an isostatic rigid connection between two sides of the system ﬁrst appears. This is
not automatically provided by the algorithm. A possible way to do it would be the following: after
testing each edge e, test a ﬁctitious bond connecting opposite sides of the sample. If the ﬁctitious
bond is independent, then these sides are not rigidly connected. Otherwise the ﬁrst time that
the ﬁctitious bond is found dependent, a rigid connection is identiﬁed between the two sides of
the system. This method doubles the number of tests (BFS’s) needed. We now describe a better
option, which allows the detection of the rigidity percolation point without extra eﬀort [19].
Two rigid bus-bars are assumed to exist on the upper and lower edges of the sample. These are
represented as two bodies B1 and B2, and their corresponding three copies are set in V2. Next a
ﬁctitious bond f connecting the two bus-bars is added to the graph. A node vf ∈ V 1 represents
this ﬁctitious bond in the bipartite graph B(G), and is adjacent to three copies of B1 and B2. This
node vf (just one copy of it) is matched to one of these nodes before starting to test any other
edges. Next edges in the system are tested in order of increasing random number rn. The ﬁrst
time that an isostatic rigid connection exists between the bus-bars, because of the existence of
this bond f that already restricts one relative degree of freedom between the busses, a dependent
subgraph will be found including the ﬁctitious bond. Thus the method to detect isostatic perco-
lation is simply checking, at each failed matching, whether the ﬁctitious bond vf has been visited
during the last search. If so, the last added edge e is independent (the number rn associated to
this bond is pc), and the subgraph visited in the failed search is exactly the elastic backbone1. All
bars in this subgraph except f are cutting bonds, that is, bonds whose individual removal would
produce the loss of rigidity (called red bonds in scalar percolation). At the percolation point the
ﬁctitious bond is removed.

Performance comparison.

Both the body-bar and the bar-joint algorithms have a worst-case time complexity that scales
as O(n2). But we argued that the body-bar representation has a more convenient average-case
behavior, since searches are now done in a graph of much reduced number of elements whenever
there are rigidly connected subsets of sites. In this section these diﬀerences are quantiﬁed. In
order to do so we take as a test case the randomly diluted triangular lattice.

1The spanning cluster is the subset of edges rigidly connected to both B1 and B2. The subset of it that
would be stressed if a pair of forces is applied between the busses is called the elastic backbone.

15

U
P
C

3

10

2

10

1

10

0

10

-1

10

-2

10

0.00

0.20

0.40

0.60

0.80

1.00

p

FIG. 9. Shown are total CPU times, in seconds, needed to test all present bonds of a randomly diluted
triangular lattice of size L = 128. These measurements were done both on site- and bond-diluted lattices,
using the body-bar ((×): site dilution, (+): bond dilution) and the joint-bar algorithms((◦): site dilution,
(∗): bond dilution) on a SPARC10 workstation.

Total CPU times are measured as a function of p for the bond- and site-dilution cases. Bonds
are assigned a random number rn as described in Section V, and tested sequentially in order of
increasing rn. In Figure 9 we see a plot of CPU times required on typical lattice of linear size
L = 128 for both algorithms in the above mentioned cases. As expected, the body-bar algorithm
is more advantageous only in the rigid phase, since the search for an exposed node takes place in a
region which is typically of the size of rigidly connected clusters. Each such region is represented
by one node in the body-bar case, and therefore searched over in just one step. At larger scales,
further collections of bodies are found to be rigidly connected and therefore replaced by one body,
so that the size of the typical searches is kept almost O(1).
In Section I we mentioned that the time-complexity of this procedure is of order L2 (number of
bonds tested) times the size of the typical search for an augmenting path, which generally scales
as Lθ, with θ a function of p. The overall CPU time then scales as Lµ with µ = 2 + θ(p). We
estimate this (p-dependent) exponent by measuring CPU times for sizes L = 256, 128, 64 and 32.
Averages were done over 102 to 104 samples. Figure 10 shows the value of the exponent µ for the
four cases under consideration, as a function of p. We see that the body-bar algorithm has a time
complexity that scales approximately as n1.12, while the bar-joint algorithm scales approximately
as n1.9, which is not much better than the theoretical worst-case limit n2.

16

µ

4.0

3.0

2.0

1.0

0.0

0.00

0.20

0.40

0.60

0.80

1.00

p

FIG. 10. CPU times as shown in Fig. 9 scale with system size as Lµ with µ = 2 + θ(p). The exponent
θ(p) determines how the size of a typical search scales with size (see text). Symbols are the same as for
Fig. 9. From the data in this plot we see that in the bar-joint algorithm, this size grows almost as fast
as n in the rigid phase, while for the body-bar algorithm described in this work this size remains almost
constant. This improved behavior is due to “condensation” of rigidly connected clusters in the body-bar
algorithm.

VI. ACKNOWLEDGMENTS

My interest in the problem of rigidity was started by P. M. Duxbury, and many of the ideas in
this work were inspired by discussions with him. An anonymous referee provided helpful advice
concerning the presentation of material in sections I and II.
I thank the DOE under contract
DE-FG02-90ER45418 and the PRF for ﬁnancial support. I also acknowledge support from the
Conselho Nacional de Desenvolvimento Cient´ıﬁco e Tecnol´ogico, CNPq, Brazil.

[1] The words structure or lattice are used in this work to describe a set of point-like objects (called
joints or nodes) connected by bars (also called bonds or edges). Bars are only able to transmit forces
in the direction of their axis. No regularity is assumed whatsoever. In the ingeneering context this is
usually called a framework.

[2] By long-range rigidity we mean that O(n) sites are rigidly connected, and therefore the size of most
BFS’s is O(n), since rigidly connected subgraphs contain no free (unmatched) v2 nodes. This situation
pushes the joint-bar algorithm towards its worst-case behavior, O(n2), when edges are tested in
random order.

[3] J. C. Maxwell, On Reciprocal Figures and Diagrams of Forces , Phil. Mag., Series 4, 27 (1864),

250-261.

[4] We are assuming n ≥ d.

17

[5] G. Laman, On Graphs and Rigidity of Plane Skeletal Structures, J. Eng. Math. 4, (1970), 331-340.
[6] H. Gluck, Almost all simply connected closed surfaces are rigid, in “Geometric Topology”, Lecture

Notes in Mathematics, No. 438, pp. 225-239. Springer-Verlag, Heidelberg, 1975.

[7] L. Asimov and B. Roth, The Rigidity of Graphs, Trans. Amer. Math. Soc. 245, (1978), 279-288.

The Rigidity of Graphs II, J. Math. Anal. Appl. 68, (1979), 171-190.
[8] Henry Crapo, Structural Rigidity, Structural Topology 1 (1979), 26-45.
[9] Walter Whiteley, Realizability of Polyhedra, Structural Topology, 1 (1979), 46-58.
[10] K. Sugihara, On redundant bracing in plane skeletal structures, Bull. Electrotech. Lab., 44(1980),

376-386.

B36(1985), 95-112.

[11] T. S. Tay, Rigidity of multigraphs, I: Linking rigid bodies in n-space, J. Combinatorial Theory

[12] T. S. Tay and W. Whiteley, Generating Isostatic Frameworks, Structural Topology 11 (1985), 21-69.
[13] M. F. Thorpe,Rigidity Percolation, in “Physics of Disordered Materials”, Institute for Amorphous

Studies series, Plenum Press, 1985.

[14] S. Feng and P. N. Sen, Percolation on elastic networks: New exponent and threshold, Phys. Rev. Lett.

52 (1984), 216.
S. Feng, Percolation properties of granular elastic networks in two dimensions, Phys. Rev. B32 (1985),
510, 513.
A. Day, R. Tremblay and A.-M. Tremblay, Rigid Backbone: A new geometry for percolation,
Phys. Rev. Lett. 56 (1986), 2501.
A. Hansen and S. Roux, Universality class of central-force percolation, Phys. Rev. B40 (1989), 749.
S. P. Obukov, First order rigidity transition in random rod networks, Phys. Rev. Lett. 74 (1995),
4472.

[15] E. Guyon et al, Non-local and non-linear problems in the mechanics of disordered systems: application

to granular media and rigidity problems, Rep. Prog. Phys. 53 (1990), 373-419.

[16] Bruce Hendrickson, Conditions for unique graph realization, Siam J. Comput., 21 (1992), 65-84.
[17] C. H. Papadimitriou and K. Sleiglitz, Combinatorial Optimization: Algorithms and Complexity, Pren-

tice Hall (1982), chapter 10.

[18] J. van Leeuwen, Handbook of Theoretical and Computer Science, Elsevier Science Publishers (1990),

chapter 10.

75 (1995), 4055.

75 (1995), 4051.

(1995), 388-400.

[19] C. Moukarzel and P. M. Duxbury, Stressed backbone of random central-force systems, Phys. Rev. Lett.

[20] D. J. Jacobs and M. F. Thorpe, Generic Rigidity Percolation: The Pebble Game, Phys. Rev. Lett.

[21] Henry Crapo, On the Generic Rigidity of Structures in the Plane, Adv. Appl. Materials, to appear.
[22] D. Franzblau, Combinatorial Algorithm for a Lower Bound on Frame Rigidity, SIAM J. Disc. Math. 8

[23] D. Franzblau, Computing Degrees of Freedom of a Molecular Frame: When is Greediness Suﬃcient?,

1995 preprint, DIMACS, Rutgers University.

[24] H. Gabow and H. H. Westerman, Forests, Frames and Games: Algorithms for Matroid Sums and
Applications in: Proceedings of the 20th symposium on the Theory of Computing, ACM, 1988, 47-
421.

[25] T. S. Tay and W. Whiteley, Recent Advances in Generic Rigidity of Structures, Structural Topology

9 (1985), 31-38.

Discr. Methods 8 (1987), 1-32.

[26] N. White and W. Whiteley, The Algebraic Geometry of Bar-and-Body Frameworks, SIAM J. Algebraic

[27] W. Whiteley, Matroid Unions and Rigidity, SIAM J. Discr. Math. 1 (1988), 237-255.

18

