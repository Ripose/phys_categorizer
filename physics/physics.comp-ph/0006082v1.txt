Higher Order Force Gradient Symplectic Algorithms

Siu A. Chin and Donald W. Kidwell∗

Center for Theoretical Physics, Department of Physics, Texas A&M University, College Station,

TX 77843

(March 14, 2011)

Abstract

We show that a recently discovered fourth order symplectic algorithm,

which requires one evaluation of force gradient in addition to three evalua-

tions of the force, when iterated to higher order, yielded algorithms that are

far superior to similarly iterated higher order algorithms based on the stan-

dard Forest-Ruth algorithm. We gauge the accuracy of each algorithm by

comparing the step-size independent error functions associated with energy

conservation and the rotation of the Laplace-Runge-Lenz vector when solv-

ing a highly eccentric Kepler problem. For orders 6, 8, 10 and 12, the new

algorithms are approximately a factor of 103, 104, 104 and 105 better.

0
0
0
2

 

n
u
J
 

0
3

 
 
]
h
p
-
p
m
o
c
.
s
c
i
s
y
h
p
[
 
 

1
v
2
8
0
6
0
0
0
/
s
c
i
s
y
h
p
:
v
i
X
r
a

Typeset using REVTEX

∗Present address: Candescent Technologies, 6580 Via Del Oro, San Jose, CA 95119

1

I. INTRODUCTION

Symplectic algorithms [1,2] for solving classical dynamical problems exactly conserve

all Poincar´e invariants. For periodic orbits, the errors in energy conservation are bounded

and periodic. This is in sharp contrast to Runge-Kutta type algorithms, whose energy error

increases linearly with integration time, even for periodic orbits [3,4]. Thus, symplectic algo-

rithms are ideal for long time integration of equations of motion in problems of astrophysical

interest [5]. For long time integrations, higher order algorithms are desirable because they

permit the use of larger time steps. Symplectic algorithms are also advantageous in that

higher order algorithms can be systematically generated from any low, even order algorithm

[6–8]. In this work, we will show that higher order algorithms generated by a fourth order

force gradient symplectic algorithm [9], have energy errors that are several orders of mag-

nitude smaller than existing symplectic algorithms of the same order. For completeness,

we will brieﬂy summarize the operator derivation of symplectic algorithms and their higher

order construction in Section II. While the materials in this section are not new, we be-

lieve that we have restated Creutz’ and Gockach’s [6] triplet construction of higher order

algorithms in its most transparent setting. In sections III and IV we recall force gradient

algorithms and discuss two distinct ways of gauging the errors of an algorithm when solving

the Kepler problem. We present our results and conclusions in Sections V and VI.

II. OPERATOR FACTORIZATION AND HIGHER ORDER CONSTRUCTIONS

After a tortuous start [10,11], symplectic algorithms can be derived most simply on the

basis of operator decomposition or factorization. For any dynamical variable W (qi, pi), its

time evolution is given by the Poisson bracket,

d
dt

W (qi, pi) = {W, H} ≡ Xi (cid:16)∂W

∂qi

∂H
∂pi

−

∂W
∂pi

∂H

∂qi(cid:17).

(1)

If the Hamiltonian is of the form,

2

H(p, q) =

1

2 Xi

p2
i + V ({qi}),

the evolution equation (1) can be written as an operator equation

with formal solution

dW
dt

= Xi (cid:16)pi

∂
∂qi

+ Fi

∂

∂pi(cid:17)W,

W (t) = et(T +V )W (0),

where T and V are ﬁrst order diﬀerential operators deﬁned by

T ≡ Xi

pi

∂
∂qi

,

V ≡ Xi

Fi

∂
∂pi

.

(2)

(3)

(4)

(5)

Their exponentiations, eǫT and eǫV , are displacement operators which displace qi and pi

forward in time via

qi → qi + ǫpi

and

pi → pi + ǫFi.

(6)

Thus, if eǫ(T +V ) can be factorized into products of the displacement operators eǫT and eǫV ,

each such factorization gives rise to an algorithm for evolving the system forward in time.

For example, the second order factorization

T2(ǫ) ≡ e

1

2 ǫT eǫV e

1

2 ǫT = exp[ǫ(T + V ) + ǫ3C + +O(ǫ5) · · ·],

(7)

corresponds to the second order algorithm

q1 = q0 +

1
2

ǫp0,

p1 = p0 + ǫF(q1),

q2 = q1 +

1
2

ǫp1,

(8)

where q0, p0 and q2, p1 are the initial and ﬁnal states of the algorithm respectively. This

second order symplectic algorithm only requires one evaluation of the force.

The bilaterally symmetric form of T2(ǫ) automatically guarantees that it is time-

reversible,

3

T2(−ǫ)T2(ǫ) = 1,

(9)

and implies that log(T2) can only be an odd function of ǫ, as indicated in (7). The explicit

form of the operator C is not needed for our present discussion.

Consider now the the symmetric triple product

T2(δ)T2(−sδ)T2(δ) = exp[(2 − s)δ(T + V ) + (2 − s3)δ3C + O(δ5) + · · ·].

(10)

This algorithm evolves the system forward for time δ, backward for time sδ and forward again

for time δ. Since it is manifestly time-reversible, its error terms must be odd powers of δ only.

Morever, its leading ﬁrst and third order terms can only be the sum of the ﬁrst and third

order terms of each constituent algorithm as indicated. This is because non-additive terms

must come from commutators of operators and the lowest order non-vanishing commutator

has to have two ﬁrst order terms and one third order term, which is ﬁfth order. The form of

(10) naturally suggests that the third order error term can be made to vanish by choosing

s = 2 1/3.

(11)

Thus if we now rescale δ back to the standard step size by setting ǫ = (2 − s)δ, the resulting

triplet product would be correct to 4th order,

T4 ≡ T2(cid:16) ǫ

2 − s(cid:17) = exp[ ǫ(T + V ) + O(ǫ5) + · · ·].

2 − s(cid:17)T2(cid:16) −s ǫ

2 − s(cid:17)T2(cid:16) ǫ

Expanding out the T2 ’s gives the explicit form:

T4 ≡ ea1ǫT eb1ǫV ea2ǫT eb2ǫV ea2ǫT eb1ǫV ea1ǫT

where, by inspection

a1 =

1
2

1

2 − s

,

a2 = −

1
2

s − 1
2 − s

,

b1 =

1

2 − s

,

and b2 = −

s

2 − s

.

(12)

(13)

(14)

This fourth order symplectic algorithm was apparently obtained by E. Forest in 1987. How-

ever, its original derivation was very complicated and was not published with Ruth [11]

until 1990. During this period many groups, including Campostrini and Rossi [12] in 1990,

4

Candy and Rozmous [13] in 1991, independently published the same algorithm. Our dis-

cussion followed the earliest published derivation of this algorithm by Creutz and Gocksch

[6] in 1989. After they were informed of this algorithm by Campostrini, they provided the

triplet construction and generalized it to higher order. The triplet construction was also

independently published by Suzuki [7] and Yoshida [8] in 1990.

Higher order algorithms can be obtained by repeating this construction. Starting with

any nth order symmetric algorithm,

Tn(ǫ) = exp[ ǫ(T + V ) + ǫ(n+1)D + · · ·],

(15)

the triplet product

Tn(δ)Tn(−sδ)Tn(δ) = exp[(2 − s)δ(T + V ) + (2 − sn+1)δn+1D + O(δn+3) + · · ·],

(16)

will be of order (n + 2) if we choose

s = 2 1/(n+1)

(17)

and renormalize δ = ǫ/(2 − s) as before.

III. FORCE GRADIENT ALGORITHMS

The method of operator factorization can be applied to many diﬀerent classes of evolution

equations. However, the triplet concatenations with a negative time step are a special

construction with more limited applicability. For example, one cannot use it to derive similar

Diﬀusion Monte Carlo or ﬁnite temperature path integral algorithms, because one cannot

simulate diﬀusion backward in time nor sample conﬁgurations with negative temperatures.

The triplet construction is a special example of Suzuki’s [14] general proof that, beyond

second order, it is impossible to factorize eǫ(T +V ) only into products of eǫT ’s and eǫV ’s

without introducing negative time steps. For symplectic algorithms this means that one

can never develop a purely positive time step fourth order algorithm by evaluating only

the force. For many years the Forest-Ruth (FR) algorithm was the only known fourth

5

order symplectic algorithm. Recently, a deeper understanding of the operator factorization

process has yielded three new symplectic algorithms [9] all with purely positive time steps.

These new algorithms circumvented Suzuki’s no-go theorem by evaluating the force and

its gradient. This corresponds to factorizing eǫ(T +V ) in terms of operators T , V , and the

commutator [V, [T, V ]]. The latter corresponds to

[V, [T, V ]] = 2Fj

∂Fi
∂qj

∂
∂pi

= ∇i|F|2 ∂
∂pi

,

(18)

which is the gradient of the squared magnitude of the force. Of the three algorithms derived

by Chin [9], algorithm C is particularly outstanding and corresponds to the factorization

eǫ(T +V ) = eǫ 1

3 T eǫ 3

8 V eǫ 1

6 T + O(ǫ5).

6 T eǫ 3

8 V eǫ 1

3 T eǫ 1

4eV eǫ 1

where

eV = V +

1
48

ǫ2[V, [T, V ]].

The algorithm itself can be read oﬀ directly as

q1= q0 +

p1= p0 +

q2= q1 +

p2= p1 +

q3= q2 +

p3= p2 +

q4= q3 +

1
6
3
8
1
3
1
4
1
3
3
8
1
6

ǫp0,

ǫF(q1)

ǫp1

ǫhF(q2) +

1
48

ǫ2∇|F(q2)|2i

ǫp2

ǫF(q3)

ǫp3.

(19)

(20)

(21)

In [9] it was shown that the maximum energy error for this algorithm, when used to solve

Kepler’s problem, is smaller than that of the FR algorithm by a factor of 80. At the moment

there is no general method for constructing higher order algorithms with only positive time

steps. It is not even known whether a positive time step 6th order algorithm exists. Thus,

6

beyond 4th order the triplet contruction is still the only systematic way of generating higher

order algorithms. In this work we show that intrinsic error functions associated with higher

order algorithms generated from Chin’s algorithm C are far smaller than those generated

from the FR algorithm.

IV. THE ENERGY AND THE LRL VECTOR

We gauge the numerical eﬀectiveness of each algorithm by solving the two dimensional

Kepler problem

d2q
dt2 = −

q
q3 ,

(22)

with initial conditions q0 = (10, 0) and p0 = (0, 1/10). The resulting highly eccentric (e=0.9)

orbit provides a non-trivial testing ground for trajectory integration.

A symmetric nth order symplectic algorithm evolves this system forward in time with

Hamiltonian

H(p, q) = H0(p, q) + ǫnHn(p, q) + O(ǫn+2),

(23)

which deviates from the exact Hamiltonian H0(p, q) = 1

2 p2 − 1/|q| by an error term
ǫnHn(p, q) as indicated. To gauge the intrinsic merit of each algorithm we compare their

step-size independent error coeﬃcient Hn(p, q). This can be extracted numerically as fol-

lows. Let’s start the system with total energy E0 = H0(p(0), q(0)). Since the Hamiltonian

(23) is conserved by the algorithm, we have

E0 = H0(p(t), q(t)) + ǫnHn(p(t), q(t)) + O(ǫn+2)

Denoting E(t) ≡ H0(p(t), q(t)) and Hn(t) = Hn(p(t), q(t)), we therefore have

Hn(t) = − lim
ǫ→0

1

ǫnhE(t) − E0i.

(24)

(25)

Energy conservation does not directly measure how well the orbit is determined. When

the time step is not too small, a very noticeable error is that the orbit precesses. One can,

7

but it is tedious, directly monitor this orbital precession [4]. It is more expedient to follow

the rotation of the Laplace-Runge-Lenz (LRL) vector:

A = p × L − ˆr.

(26)

When the orbit is exact the LRL vector is constant, pointing along the semi-major axis of

the orbit. When the orbit precesses the LRL vector rotates correspondingly.

For an nth order algorithm,

dA
dt

= ǫnXi (cid:16)∂A

∂qi

∂Hn
∂pi

−

∂A
∂pi

∂Hn

∂qi (cid:17).

(27)

Thus, the rate of change of each component of the LRL vector is of order ǫn. The components

themselves, which are time integrals of the above modulo a constant term, must also be of

order ǫn. Let the LRL vector initially be of length A0 and lie along the x-axis, then we have

Ax(t)= A0 + ǫnAnx(t) + O(ǫn+2),

Ay(t)= ǫnAny(t) + O(ǫn+2).

Since the square of the LRL vector is related to the energy by

A2 = 2L2E + 1,

(28)

(29)

(30)

the longitudinal deviation coeﬃcient Anx(t) is related to the energy error coeﬃcient by

Anx(t) =

1
ǫn

L2
A0

(E(t) − E0) = −

L2
A0

Hn(t),

(31)

which gives no new information. The perpendicular deviation coeﬃcient Any(t) is best

measured in terms of the rotation angle:

θ(t) = tan−1(cid:20) Ay(t)

Ax(t)(cid:21) = ǫn(cid:20) Any(t)

A0

(cid:21) + · · ·

(32)

To compare algorithms we again extract and compare their rotation error coeﬃcient function

θn(t) = Any(t)/A0 via

θn(t) = lim
ǫ→0

1
ǫn θ(t).

(33)

Since this rotational angle is related to some integral of the energy error function, it is a

better measure of the overall error of the algorithm.

8

V. RESULTS OF COMPARING HIGHER ORDER ALGORITHMS

By use of the triplet construction, we generated 6th, 8th, 10th, and 12th order algorithms

from both the Forest-Ruth and Chin’s C algorithm. We computed the fractional energy

deviation, which is just the negative of the energy error coeﬃcient normalized by the initial

energy,

lim
ǫ→0

1

ǫnhE(t)

E0

− 1i = −

Hn(t)

E0

.

(34)

Smaller and smaller time steps ǫ are used until the extracted coeﬃcient function is stablized

independent of the time step size. This typically occurs in the neighborhood of ǫ = P/5000,

where P is the period of the orbit.

Fig.1 compares the (negative) normalized error coeﬃcient functions for the 4th order

Runge-Kutta, Forest-Ruth and Chin’s C algorithms over one period of the orbit. The error

function for the two symplectic algorithms are substantial only near mid period when the

particle is at its closest approach to the attractive center. For symplectic algorithms energy

is conserved over one period, or its non-conservation is periodic. Its average energy error is

bounded and constant as a function of time. In contrast, the 4th order Runge-Kutta energy

error function is an irreversible, step-like function over one period. Each successive period

will increase the error by the same amount resulting in a linearly rising, staircase-like error

function in time. As noted earlier, the maximum error in Chin’s algorithm C is smaller than

that of the FR algorithm by a factor of 80. However, this error height comparison at one

point is not meaningful. It is better to compare the energy error averaged over one period.

This would require the integral of the energy error function. On this basis algorithm C will

be better still. While the energy error integral can be done, the same goal can be achieved

by monitoring the rotation of the LRL vector.

Fig.2 shows the corresponding error coeﬃcient functions of the rotational angle of the

LRL vector. After each period, the algorithms rotate the LRL vector by a deﬁnite amount.

The error coeﬃcient provides an intrinsic, step-size independent way of comparing this

9

rotation. In Fig.2 the rotated angle produced by algorithm C is too small to be visible when

plotted on the same scale as the other algorithms. The insert gives an enlargement of the

details. The rotational angle of the LRL vector appears to be related to some integral of

energy error function. Although we have not been able to demonstrate this analytically,

numerical integration of the energy error function does give a function similiar in shape

to the angle coeﬃcient function, having the same numbers of maxima and minima. For

the Runge-Kutta, Forest-Ruth and Chin’s C 4th order algorithms, the magnitudes of this

rotation coﬃcient after one period are 2.666, 10.860, and 0.004 respectively. On this basis,

algorithm C is better than FR by a factor of ≈ 3000. When the orbit is integrated over many

periods the rotational angle from symplectic algorithms increases linearly in a staircase-like

manner with time. In contrast, the rotational angle of the Runge-Kutta algorithm shows

a quadratic increase over long times, such as a few thousand periods. This result is easy

to understand if the rotational angle is related to some integral of the energy error. This

quadratic increase in the rotation angle of the LRL vector clearly mirrors the quadratic

increase in phase error of the Runge-Kutta algorithm, as discussed by Gladman, Duncan

and Candy [4].

Fig.3 and Fig.4 show the results when both the Forest-Ruth and Chin’s C algorithms are

iterated to 6th order by the triplet product construction. Inserts in both detail algorithm

C’s intricate structure. As an added comparison we also included results for Yoshida’s [8]

6th order algorithm A, which is a product of 7 second order algorithms (8), some with

negative time steps. For Yoshida’s algorithm, Forest-Ruth and Chin’s C algorithm in 6th

order, the magnitudes of the rotation coﬃcients after one period are 11.44, 335.1, and 0.1156

respectively. Yoshida’s algorithm is a factor of 30 better than FR, but algorithm C is a factor

of 3000 better. Note that if the energy error function is related to the diﬀerential of the the

angle error function, the zeros of the former would correspond to the extrema of the latter.

The four zero crossings of algorithm C’s energy error function are clearly reﬂected in the

two maxima and two minima of the corresponding angle error function.

Fig.5 and Fig.6 give results for the 8th order iterated algorithms based on the Forest-

10

Ruth and Chin’s C algorithm. The magnitudes of the angle error coeﬃcients are 1.386 × 104

and 0.4532 respectively, giving a ratio of approximately 3 × 104. Algorithm C retains its

characteristic shape in both the energy and the angle error function. Fig.7 and Fig.8 give

the corresponding results for the iterated 10th order algorithms. Here the intricate structure

in the C algorithm is beginning to be washed out. At this high order, quadruple numeric

precision is necessary to extract these coeﬃcient functions smoothly. The magnitudes of

the angle error coeﬃcients are now 7.141 × 105 and 17.89 respectively, giving a ratio of

4 × 104. Fig.9 and Fig.10 give similar results for the 12th order algorithms. At this point all

structures in the C algorithm are gone. The magnitudes of the angle error coeﬃcients are

now 4.473 × 107 and 427.5 respectively, giving a ratio of 1.05 × 105.

The iteration of algorithms A and B of Chin [9] also produced results that are better

than FR based algorithms. However, we do not detail their results here because they are at

least one or two orders of magnitude inferior to algorithm C.

VI. CONCULSIONS

In this work we have shown that higher order force gradient symplectic algorithms appear

to be superior to non-gradient symplectic alogorithms as measured by eneregy conservation

and the rotation of the LRL vector. While it has been shown earlier that 4th order force

gradient algorithms have smaller energy error coeﬃcients [9], it was not known that this

advantage would mulitply dramatically when algorithms are iterated to higher orders. The

conclusion that one should draw may not be that force gradient algorithms are better, but

that higher order non-gradient algorithms are far from optimal. Secondly, we suggested that

the rotation of the LRL vector gives an intergrated measure of an algorithm’s merit when

tested on the Kepler problem.

The high accuracy of this class of algorithms seemed ideal for long time integration of

few-body problems, such as that of the solar system [5]. For such few-body problems, the

evaluation of the force gradient is not excessively diﬃcult. It would be useful to examine

11

the merit of this class of algorithms in more physical applications. The distinct advantage

uncovered in this work, that it is better to iterate a 4th order algorithm with all positive

time steps, gives further impetus to search for an all positive time step 6th order symplectic

algorithm.

ACKNOWLEDGMENTS

This research was funded, in part, by the U. S. National Science Foundation grants

PHY-9512428, PHY-9870054 and DMR-9509743.

12

REFERENCES

[1] Numerical Hamiltonian Problems by J. Sanz-Serna and M. Calvo, Chapman & Hall

London, 1994.

[2] H. Yoshida, Celest. Mech. 56 (1993) 27.

[3] H. Kinoshita, H. Yoshida, an dH. Nakai, Celest. Mech. 50(1991)59-71.

[4] B. Gladman, M. Duncan and J. Candy, Celest. Mech. 52(1991)221.

[5] J. Wisdom and M. Holman, Astrophys. J., 102(1991)1528.

[6] M. Creutz and A. Gocksch, Phys. Rev. Letts. 63(1989) 9.

[7] M. Suzuki, Phys. Lett. A146 (1990)319.

[8] H. Yoshida, Phys. Lett. A150 (1990)262.

[9] S. A. Chin, Phys. Lett. A226 (1997) 344.

[10] R. D. Ruth, IEEE Trans. Nucl. Sci, NS-30(1983)2669.

[11] E. Forest and R. D. Ruth, Physica D 43(1990) 105.

[12] M. Campostrini and P. Rossi, Nucl. Phys. B329(1990) 753.

[13] J. Candy and W. Rozmus, J. Comp. Phys. 92(1991) 230.

[14] M. Suzuki, J. Math. Phys. 32 (1991)400.

13

FIGURES

RK4
FR
C

30

20

10

0

-10

4

/

)
1
-

0
E
E

/

(

-20

0.48

0.49

0.50
t / P

0.51

0.52

FIG. 1. The normalized energy deviation of a particle in a Keplerian orbit, which measures the

step-size independent energy error coeﬃcient −H4(p(t), q(t))/E0. P is the period of the elliptical

orbit and ǫ is the time step size. RK4, FR, and C denote results for the 4th order Runge-Kutta,

Forest-Ruth, and Chin’s C algorithm respectively. The maximum deviations for algorithm FR and

C are 21 and 0.27 respectively.

14

5

0

4

/

-5

-10

-15

0.48

RK4
FR
C

0.05

0.00

-0.05

0.48

0.49

0.50

0.51

0.52

0.49

0.50

0.51

t / P

FIG. 2. The

step-size

independent

error

coeﬃcient of

the

rotation angle of

the

Laplace-Runge-Lenz vector for 4th order algorithms. The LRL vector rotates substantial only

when the particle is near mid period, closest to the attractive center. The insert make visible the

ﬁne structure produced by algorithm C.

15

6

/

)
1
-

0
E
E

/

(

0.5

0.0

-0.5

0.48

0.49

0.50

0.51

0.52

FR
C
Y

500

400

300

200

100

0

0.48

0.49

0.50

0.51

t / P

FIG. 3. The normalized energy deviation for 6th order algorithms. RF and C denote 6th order

algorithms generated by a triplet product of corresponding 4th algorithms in Fig.1. The insert

makes visible the energy devivation of algorithm C, which is not visible in the bigger graph. The

maximum deviations for algorithms FR, Y and C are 513, 13.6, and 0.74 respectively.

16

6

/

100

0

-100

-200

-300

-400

0.48

FR
C
Y

0.20

0.10

0.00

0.48

0.49

0.50

0.51

0.52

0.49

0.50

0.51

t / P

FIG. 4. The step-size independent error coeﬃcient of the rotation angle of the LRL vector for

6th order algorithms as described in Fig.3. The insert makes visible the minute rotation coeﬃcient

produced by algorithm C.

17

8

/

)
1
-

0
E
E

/

(

20*103

15*103

10*103

5*103

0

-5*103

0.48

FR
C

1.0

0.0

0.48

0.49

0.50

0.51

0.52

0.49

0.50

0.51

t / P

FIG. 5. The normalized energy deviations for 8th order algorithms, as generated by a triplet

product of 6th order algorithm described in Fig.3. The insert makes visible the minute energy

deviation of algorithm C.

18

5*103

0

8

/

-5*103

-10*103

-15*103

0.48

FR
C

0.00

-0.20

-0.40

0.48

0.49

0.50

0.51

0.52

0.49

0.50

0.51

t / P

FIG. 6. The step-size independent error coeﬃcient of the rotation angle of the LRL vector for

8th order algorithms as described in Fig.5. In this order, the algorithm C based algorithm begins

to rotate in the same sense as the FR base algorithm.

19

0
1

/

)
1
-

0
E
E

/

(

106

8*105

6*105

4*105

2*105

0

0.48

FR
C

20

15

10

5

0

0.48

0.49

0.50

0.51

0.52

0.49

0.50

0.51

t / P

FIG. 7. The normalized energy deviations for 10th order algorithms, as generated by a triplet

product of 8th order algorithm described in Fig.5. The insert shows that the characteristic oscil-

lations of algorithm C are beginning to disappear.

20

FR
C

2*105

0

-2*105

-4*105

-6*105

0
1

/

5

0

-5

-10

-15

0.48

0.49

0.50

0.51

0.52

-8*105

0.48

0.49

0.50

0.51

t / P

FIG. 8. The step-size independent error coeﬃcient of the rotation angle of the LRL vector for

10th order algorithms as described in Fig.7. The insert shows that the error coeﬃcient of algorithm

C begins to look like that of the FR algorithm.

21

400

300

200

100

0

0.48

0.49

0.50

0.51

0.52

FR
C

6*107

4*107

2*107

0

2
1

/

)
1
-

0
E
E

/

(

0.48

0.49

0.50

0.51

t / P

FIG. 9. The normalized energy deviations for 12th order algorithms, as generated by a triplet

product of 10th order algorithm described in Fig.7. The insert shows that there is no longer any

distinctive structure produced by algorithm C.

22

107

0

-107

2
1

/

-2*107

-3*107

-4*107

-5*107

0.48

FR
C

0

-200

-400

0.48

0.49

0.50

0.51

0.52

0.49

0.50

0.51

t / P

FIG. 10. The step-size independent error coeﬃcient of the rotation angle of the LRL vector for

12th order algorithms as described in Fig.9. The insert shows that both algorithms have converged

to a similar step-like error function.

23

