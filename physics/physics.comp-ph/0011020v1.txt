0
0
0
2

 

v
o
N
9

 

 
 
]
h
p
-
p
m
o
c
.
s
c
i
s
y
h
p
[
 
 

1
v
0
2
0
1
1
0
0
/
s
c
i
s
y
h
p
:
v
i
X
r
a

Life in Silico - Simulation of Complex Systems

by Enzymatic Computation

Gerhard Mack and Jan W¨urthner

II. Institut f¨ur Theoretische Physik, Universit¨at Hamburg

September 28, 2000

abstract We describe software and a language for quasibiological computa-
tions. Its theoretical basis is a uniﬁed theory of complex (adaptive) systems
where all laws are regularities of relations between things or agents, and dy-
namics is made from “atomic constituents” called enzymes. The notion is
abstracted from biochemistry. The software can be used to simulate physi-
cal systems as well as basic life processes. Systems can be constructed and
manipulated by mouse click and there is an automatic translation of all op-
erations into a LISP-like scripting language, so that one may compose code
by mouse click.

1 Introduction

It is a fruitful idea to learn from nature how to do information processing by
abstracting from what happens in the living cell.

In 1959, R. Feynman gave a visionary talk describing the possibility of

building computers that were “submicroscopic”. [11].

More recently, L.M. Adleman demonstrated the feasibility of carrying out
computations at the molecular level by solving a standard NP-hard graph
problem (similar to the travelling salesman) using molecules of DNA, and
standard protocols and biochemical enzymes [1]

Here we are not interested in doing real chemistry in a bucket, but in
mathematical abstractions which incorporate the basic logic of biochemical
processes in the living cell and can be put on a computer. This was a dream

1

also of workers on Artiﬁcial Life [16]. But we may infer from Adleman’s work
that life in silico will be useful not only for simulating life processes, but for
other complex problems as well.

Starting point is a philosophical principle,

The human mind thinks about relations between things or

agents.

This tells us how to model parts of the world. A uniﬁed theory of complex
(adaptive) systems was built upon this principle [21]. Here we describe its
implementation in software.

As in category theory [19], the relations are directed binary relations,
and it is regarded as their constitutive property that they can be composed
- think of friend of a friend, brother in law, next nearest neighbor. There
are also some distinguished relations - the identities 1X of objects X with
themselves - they play a basic role similar to the number 0 in arithmetics.
Motivated by physics, a principle of locality is added by singling out some of
the relations as direct relations, called links. All others are composed from
them and possibly their “adjoints” - i.e. relations in the opposite direction.
Links between objects form networks. Their properties are laid down in the
mathematical deﬁnition of a system, given below. Basically it makes precise
the notion of structure.

We consider dynamics in discrete time. It is required to be local. Dy-
namics is also built from “atomic constituents”, called enzymes. They are
composed from very simple basic moves, including in particular composition
of two links to a single link (friend of a friend becomes friend), making or
deletion of adjoint links (reciprocation) and making or ﬁnding copies. 1

In contrast with automata theory [30], systems theory is supposed to be
self contained. Everything that is used should be provided for by the axioms
or be constructed with them. There is no other information but structure.
But in the software implementation, we will not push this point of view to
the extreme. We will admit numerical or text data that reside inside objects
and links. Regard them as coding for structure. For more discussion on the
relation between structural and numerical descriptions see ref. [21].

The whole theory may be regarded as a kind of universal chemistry where
general objects substitute for atoms and molecules, and more general links
for chemical bonds and spacial proximity.

1They are very simple examples of graph transformations [26]

2

2 Systems

According to the pioneer of general systems theory, L. van Bertalanﬀy [3], a
system is a set of units with relationships between them. And according to
F. Jacob [15], every object considered in biology is a system of systems. We
precisize to 2

Deﬁnition 1 (System) A system S is a model of a part of the world as
a network of objects X, Y, ... (which represent things or agents) with arrows
f, g, ... which represent directed relations between them.
One writes f : X 7→ Y for a relation from a source X to a target Y .

The arrows are characterized by axiomatic properties as follows:

1. composition. Arrows can be composed. If f : X 7→ Y and g : Y 7→ Z

are arrows, then the arrow

g ◦ f : X 7→ Z

is deﬁned. The composition is associative, i.e. (h ◦ g) ◦ f = h ◦ (g ◦ f ).

2. adjoint. To every arrow f : X 7→ Y there is a unique arrow f ∗ :
Y 7→ X in the opposite direction, called the adjoint of f . f ∗∗ = f and
(g ◦ f )∗ = f ∗ ◦ g ∗.

3. identity. To every object X there is a unique arrow 1X : X 7→ X which

represents the identity of a thing or agent with itself.

1X = 1∗

X,

and

1Y ◦ f = f = f ◦ 1X

for every arrow f : X 7→ Y .

4. locality: Some of the arrows are declared direct (or fundamental); they
are called links. All arrows f can be made from links by composition
and adjunction, f = bn ◦ ... ◦ b1, (n ≥ 0) where bi are links or adjoints
of links; the empty product (n = 0) represents the identity.

5. composites: The objects X are either atomic or systems. In the latter
case, X is said to have internal structure, and the objects of the system
X are called its constituents.

2Axioms 1,3 are those of a category [19]. Therefore systems are categories with a

∗-operation and a notion of locality

3

6. non-selﬁnclusion: A system cannot be its own object or constituent of
an object etc. Ultimately, constituents of ... of constituents are atomic.

A Semiadditive system satisﬁes the same axioms, except that arrows may
be composed from links and their adjoints with the help of two operations, ◦
and ⊕. The ⊕-operation adds parallel arrows. It makes the set S(X, Y ) of all
arrows with given source X and target Y into an additive (=commutative)
semigroup. The distributive law holds

(f1 ⊕ f2) ◦ (g1 ⊕ g2) = f1 ◦ g1 ⊕ f2 ◦ g1 ⊕ f1 ◦ g2 ⊕ f2 ◦ g2

An arrow o is a zero arrow if f ⊕ o = f for all f . It is understood that

arrows are modulo zero arrows.

The rationale behind the ⊕ operation is that it should be possible to interpret
two parallel links as a single link, and similarly for arrows.

Remark 1 In a Semiadditive system, the set S(X, Y ) can be extended to
an additive group if and only if f ⊕ h = g ⊕ h implies f = g, whatever is h.

In the following, we will sometimes refer to composition with ◦ as multipli-
cation, and to ⊕ as addition of links.

In addition to the axioms, it is assumed that constituents, constituents
of constituents etc. of objects of S are not objects of S. This assumption
is subject to being weakened, but weakening it may require adjustment or
redesign of software. It would be interesting to weaken also the axiomatic
property of non-selﬁnclusion. But this is a very subtle operation, cp. the
discussion in section 8.1

We found it convenient to generalize the axiomatic notion of identity
arrow by introducing identity links as a special type of link which may connect
objects that are identical in the sense of indistinguishable.

Deﬁnition 2 (Subsystems) A subsystem S1 of a system S is generated by
a set of objects in S and a set of links in S between these objects. Its arrows
are all arrows in S that can be composed from these links and their adjoints.
The boundary of S1 consists of the links in S with target in S1 which are

not links or adjoints of links in S1.

The environment of S1 is the system generated by the objects of S not in

S1 and the links between them.

4

In the software, subsystems can be speciﬁed by marks in two diﬀerent ways,
either by marking the (inward) links in its boundary, or by marking the links
which belong to it.

In the description of the software design, we use the following

Nomenclature 1

Valence The links with target X are called the Valences of X

Radical An object X together with all its valences is called a Radical.Given
some link b, the radical which contains its source (object) is called the
source radical of b.

Membrane Marks on links which identify the boundary of a subsystem are

called Membranes

Path A Path from X to Y is a sequence b1, ..., bn, where bi are links or
adjoints of links, X is the source of b1, Y is the target of bn, and
the target of bi is the source of bi+1 for i = 1, ..., n − 1. The empty
path (n = 0) from X to X is identiﬁed with 1X. Paths are special
subsystems. Marks on links which belong to a certain subsystem are
called path-links.

In simulations of biological organisms and their parts, membranes can be
used as models of cell membranes or envelopes of organs. Path-links are
used to model blood vessels and other transport channels, and neural nets.
Attachig enzymes can convert terminal objects of neural nets to sensors and
eﬀectors, and objects within blood vessels to pumps. And copy processes
can make organisms grow. Any system with all its interna can be copied by
purely local processes, induced e.g. by propagating shocks, cp. section 8.1.

2.1 Basic equations

In systems theory, basic equations are often of the form l = 1X, where
l : X 7→ X is the arrow speciﬁed by some path. Maxwell’s equations have
this form [21].

Validity of constraints of this form can distinguish between modes of
being [21]. For instance, space time is distiguished by having a Lorentzian
geometry, 3 and material bodies are in space and obey conservation laws.

3Diﬀerential geometry is a father of systems theory, with parallel transporters as

arrows

5

2.2

Isomorphic systems

The notion of isomorphic systems is somwhat subtle. Basically, two systems
S1 and S2 are isomorphic if there exists a structure preserving map F : S1 7→
S2 which maps objects into objects and links into links, and whose inverse
exists and has the same property. This induces a map of arrows f into arrows
F (f ). We require of a structure preserving map F that source and target of
F (f ) are the images of source and target of f , and 4

F (f ◦ g) = F (f ) ◦ F (g),

F (1X) = 1F (X) .
F (f ∗) = F (f )∗

(1)
(2)
(3)

There are also anti-isomorphisms. They relate complementary shapes. For
an antiisomorphism, eq.(1) is replaced by

F (f ◦ g) = F (g) ◦ F (f ),

(4)

and source and target are interchanged.

It is NOT required that the internal structure of corresponding objects
matches when they are not atomic. Nonatomic objects are regarded as black
boxes. The internal structure of black boxes (nonatomic objects) is declared
irrelevant when one does not distinguish isomorphic systems, and so is the
distinction between atomic and nonatomic objects. The only usage of the
internal structure is in constructing links of the system and their composi-
tion ◦. One does not look into black boxes anymore once they are in place
and connected.

We speak of a strong isomorphism if it IS demanded that corresponding
nonatomic objects are strongly isomorphic systems. (This recursive deﬁni-
tion makes sense because of the axiom of non-selﬁnclusion.)

3 Dynamical systems

We consider dynamics in discrete time. A deterministic dynamics of ﬁrst
order shall determine a system St+1 at time t + 1 and links between objects

4These are the axiomatic properties of functors of a category [19], with the added
demand that the map is local in the sense that it maps links to links, and preserves the
∗-operation. Anti-isomorphisms are invertible contravariant functors

6

X in St+1 and objects Y in St from a given a system St at time t. If there
is a link between X ∈ St+1 and Y ∈ St, X is said to be descendent of Y , and
Y is ancestor of X.

It is required that

1. Every object X ∈ St+1 is descendent of at least one object Y . Con-
versely, {Y1, ..., Yn} can only be the set of ancestors of some X if the
system generated by Y1, ..., Yn and identity links between them is con-
nected.

If (n > 1) we say that there is fusion. An object may have more than
one descendent ( e.g. copies or translations).

2. The dynamics is local in the sense that the isomorphism class (resp.
strong isomorphism class) of a subsystem of St+1 depends only on the
system generated by the objects in a 1-neighborhood of its ancestors
and the links between them.

A deterministic dynamics determines St up to isomorphism, a strongly de-
terministic dynamics determines it up to strong isomorphism, i.e. including
the internal structure of nonatomic objects. A dynamics is called universal
if it is well deﬁned for every system St whatever.

The idea of enzymatic computation is
ﬁrst, to build dynamics from “atomic constituents” (elementary moves)

which we call enzymes.

second, to incorporate the information about the dynamics into the initial

state by attaching enzymes to links and objects of St.

The enzymes may act conditionally. To this end they are combined with
predicates which examine the structure of a neigborhood in the system. A
predicate p determines a boolean function p.evaluate(r,v) where r is a
radical, and v is (pointer to) a valence, typically of r. The pair (predicate,
enzyme) is also called a mechanism. The enzymes are abstractions not only
of the biochemical enzymes [2] which govern life processes in cells, but of any
agent of change. Biochemical enzymes show speciﬁcity [2], i.e. they come
with their predicates inseparably build in. We shall occasionally speak of
enzymes when we really mean mechanisms.

There are several kinds of basic enzymes, i.e. elementary moves.

motion An arrow becomes promoted to link. Either

7

a) The composite of two (or more) links becomes a link, i.e.
indirect
relations become direct. example 1: Friend of a friend becomes friend.
example 2: Equations of motion of fundamental physics like Maxwells
equations [21, 22] or motion of particles in space.[Transport of material
involves motion of particles in space (or an eﬀective decription of that
in terms of algebraic values)]. example 3: catalysis, ﬁgure 1. example
4: logical deductions, cp. ref.[21, 27].

b) The adjoint of a link which was not a link becomes a link. example:
reciprocation

The converse - adjoint of a link loses the status of a link - is also
subsumed under motion. Motion is reversible.

growth An object has two or more descendents - e.g copies which are made
or taken from the environment. Fusion of objects is also subsumed
under growth, and so is the making of an object with internal structure
from a subsystem. Growth is reversible if descendents are connected by
identity links (cp. section 2 after deﬁnition 1). Removal of the identity
link would be subsumed under death, s. below.

death An object may disappear with its links, links may disappear together

with their adjoints. Death is usually irreversible.

cognition A new link is made between objects X1, X2 with matching inter-
nal structure. Locality requires that X1, X2 are connected by a path
of short length in St, i.e. there is a preexisting relation between them.
But the new link need not be the arrow determined by the preexist-
ing path. example: a chemical bond may be established when there was
spacial proximity before. Links made this way are called cognitive links.

C

C

Carl

Carl

A

B

A

B

Anne

Bert

Anne

Bert

Figure 1: Catalysis in chemistry and elsewhere. A catalyst C binds molecules A
and B. First a substrate-enzyme complex is built, where A and B bind to C. Next
the composite arrow from A to B becomes fundamental.

8

enzyme management Enzymes are attached to objects and links of St+1,

or their action somewhere at time t + 1 is speciﬁed in other ways.

The making of cognitive links only makes sense if the dynamics determines
future systems up to strong isomorphism, because the internal structure of
nonatomic objects matters. Cognitive links can be of several types f . f is a
boolean function (“matching structure”) of two objects, typically determined
by a predicate p with the property that p(r, v) depends only on the object
of radical r and the source object of valence v. Its return value is also sup-
posed to be obtained by enzymatic computation (with access to the internal
structure of objects which are systems).

The most important example of matching structure are isomorphisms and
antiisomorphism. The latter implement the lock key mechanism which is re-
sponsible for speciﬁcity in biochemistry [2]. Determining isomorphisms of
graphs is an NP-hard problem. But this is not very relevant here because in
practise one will encounter graphs with special properties. Matching struc-
tures can also be detected by neural nets, here implemented as subsystems
made with path-links.

We will subsume the making of identity links between indistinguishable
atomic objects under cognition as well, and regard such identity links as
prototypical examples of cognitive links.

A description of the most important enzymes will be given later.
So far we talked about deterministic dynamics. In a stochastic dynamics,

enzymes act with certain probabilities.

3.1 Concurrency

The action of enzymes at diﬀerent locations will not commute in general.
This results in what is known to computer scientists working on parallel
computing as the concurrency problem. Petri nets are a well know example
[25]. In the spirit of biology, one may just ignore this problem, admitting
some randomness or indeterminacy in the dynamics, e.g. through a hidden
dependence on an ordering of the valences of a radical. But it is useful to have
the option of specifying a well deﬁned deterministic dynamics for systems.

We propose to achieve this by a generalization of Jacobi sweeps.
Let us ﬁrst recall the notion of a Jacobi sweep. Consider a grid made of
nodes (objects) connected by links, where the nodes and/or the links carry
some data. Given a cost function whose arguments are the aforementioned

9

data and which is a sum of contributions which depend only on a neighbor-
hood of individual nodes or links. One may attempt its minimization by
relaxation. One makes sweeps through the grid, updating data at individual
nodes or links such that the cost function is minimized under the constraint
that all other data remain frozen. In a Jacobi sweep (as opposed to Gauss
Seidel sweeps)[13], the data after sweep t+1 are determined solely by the data
after sweep t. As a result it does not matter in which order the nodes and
links of the grid are visited - the eﬀect of the individual updating operations
will commute.

We may proceed in the same way, except that we divide the making of
the system St+1 at time t from the system St at time t into several steps
which take place at times t + 1
4 and t + 1. In intermediate steps,
there will be links connecting objects in St with objects in St + 1. We call
them “time links”

4, t + 1

2, t + 3

4 , t + 1

2 or t + 1. The intermediate step at time t + 3

We may divide enzymes into classes according to whether they act at
time t + 1
4 was introduced
for pedagogical reasons only. The enzymes which act at time t + 1
4 will be
called “object-making”, those at time t + 1
2 “link-making”. The link-making
enzymes may also put marks on newly made links to indicate information on
their adjoints.

As explained in section 3, our processes are such that every object Y in

St+1 is descendent of (at least) one object X in St.

Ignoring the attachment of enzymes to St+1 at ﬁrst, the course of events

is like this (cp. ﬁgure 2 for an example) .

t + 1

4 Make descendents Y1, ..., Yn ∈ St of objects X ∈ St, if any; (n ≤ 2).
Connect them by time links. When (n > 1) make identity links between
identical copies Y1, ..., Yn if demanded by an enzyme.

t + 1

2 Make links that will end up in St+1. Every link-making enzyme may
contribute some link or links, in a manner which depends on its neigh-
borhood in St. For pedagogical reasons, the links are made at time
t + 1
2 to connect one object in St and one object in St+1, and at time

t + 3

4 the ends in St of such links are lifted to St+1 by composition with a

time link.

t + 1 Depending on the marks on the newly made links in St+1, adjointness
relations are established among links, or new fundamental adjoints are

10

-
9

-

q

-

-

t

6
?6
?
-

6
?6
-
?
9

M
q

6



-

?
-

6

?

t + 1
4

6
I
?6
I 
?
-

K
6
?6

-
?
9
-
6
-
?6
?
-

-
6
-
9
?6
M
-
q
?
9



k
MM

q
-

q

-

6
I

6

?
-

?

t + 1
2

t + 1

-
6

?
-

6

?

Figure 2: splitfork dynamics, concurrent version

made. The operation is local in that it involves only the individual
pairs of sets S(Y, Y ′) and S(Y ′, Y ) of links between given objects Y, Y ′.

So far we neglected to say how the enzymes are put into the system
St+1. Object making enzymes are attached to descendents or identity links
between them in step t + 1
4. Link-making enzymes are attached to links in
step t + 1
2.

Dynamics of this kind is well deﬁned because all operations within anyone

of the steps commute.

In the end, the time links may be removed (if desired). This step is not

shown in ﬁgure 2.

Unfortunately the use of Jacobi sweeps is less convenient than admitting
a hidden dependence of the order in which enzymes at neighbouring locations
act on an ordering of valences in radicals. This is so because the composition
of chains of enzymes which act one after another is not a simple matter
anymore.

11

4 The System Class Laboratory

The System Class Laboratory (SyCL) is a software package composed of
three parts

core package is a C ++ class library which encodes the basic functionality
demanded by the axioms of a semi-additive system and enzymatic dy-
namics on it.

presentation package includes a graphic interface. Using it one can con-
struct and manipulate such systems by mouse-click, invoking the con-
ditional action of basic enzymes and of compound enzymes made from
them. The presentation package also includes to translate systems to
and from XML, i.e. text.

interpreter and parser package is based on a LISP-like scripting language.
One can write programs in this language and run them. Alternatively,
operations carried out by mouse click on the graphic interface are au-
tomatically recorded as commands of the scripting language. In this
way one may compose programs by mouse click.

5 The class library

5.1 Basic Data Types

In principle, system theory is self-contained 5. There are no data in systems
other than their structure, and no states of any part of a System other than
its structure. The miracle is how much can be modeled with so little building
material.

In practice, it is nevertheless convenient to admit data inside objects and
links which can be thought to code for internal structure in some way. (Links
with internal structure can be thought of as system’s with two interfaces)
The data inside links are instances of a class AlgebraicValue. They admit
algebraic operations. They can be added, multiplied and multiplied with
real numbers in a manner which is described below in subsection 5.2. Their
equality can also be ascertained. The class AlgebraicValue is derived from a

5in contrast with automata theory [30]

12

class Value which does not have the algebraic operations as methods. Ob-
jects can contain arbitrary Values. Multiplication and addition of algebraic
values that reside inside links is invoked when links are composed using the
axiomatic ◦ and ⊕-operations. Several diﬀerent classes are derived from
AlgebraicValue, including the class Predicate. We mention it separately be-
cause of its important role. Enzymes may also be attached to objects and
links in the guise of EnzymaticValue, also derived from AlgebraicValue.

The other data types correspond with Nomenclature 1, except for the
following implementational detail. The adjoint of a link b with source X
which is not itself a link is nevertheless included in the list of Valences of the
radical containing X, and is marked as a “virtual valence”. This is technically
convenient because the target of b can be addressed as source of its adjoint.

The basic data types are

Value, AlgebraicValue contain text or numerical data with operations as

described

Objects may contain a singly linked list of Values. They can be copied.

Valences contain a pointer to their source radical, a pointer to their ad-
joints, and possibly: a singly linked list of AlgebraicValue’s, a singly
linked list of Membranes, a singly linked list of Paths.

By deﬁnition, the adjoint is a valence of the source radical, possibly
virtual.

Composition ◦ of a valence with valences of its source radical is deﬁned.

Parallel valences may be added to a single valence.

Radicals contain an object, a doubly linked list of valences, and possibly a

position in 3-dimensional space.

Predicates determine a boolean function which takes as argument a pair
(r,v), where v is a pointer to valence (maybe NULL) and r is a radical
(typically the target of v). Predicates can be composed with junctors
“and, or, not”. Among the predicates are keys which permit to pass
membranes selectively.

Membranes are attached to valences. They mark the boundary of a sub-
system. They carry a string or a void* pointer as code to distinguish
them.

13

PathLinks contain a reference to a valence and data to identify the precur-
sor, successor and adjoint pathLink. A valence knows the pathLinks
that pass through it, cp. above.

System A connected nonempty system is identiﬁed by a pointer root to
one of its radicals, and possibly by the code of a membrane which
bounds it.

From root one can access the source radicals of its valences, and so
on. All the information on the system is in the radicals which can be
accessed in this way.

Enzyme Enzymes have a method Radical & act(r,v) which takes as its
arguments a radical r and a pointer v to a pointer *v to a valence (of
r). *v may be NULL. The action is on a neighborhood of r. *v may
be changed to point to a diﬀerent valence, therefore a pair (Radical
&, Valence *) is eﬀectively returned, which can be used for input to
another enzyme.

One may deﬁne a path distance d between objects X and Y by use of paths
{b1, ..., bn}. d is the minimal value of n among all the paths from X to Y .

5.2 AlgebraicValues

The implementation of algebraic operations with AlgebraicValues makes es-
sential use of object oriented design features like inheritance and virtuality.
[12]. We assume that the reader is familiar with these.

The algebraic operations satisfy the usual laws of associativity and dis-
tributivity. Multiplication may be noncommutative, and in one special case
(the max-plus-”algebra”), subtraction is undeﬁned.

There is an inheritance tree which speciﬁes how diﬀerent classes of alge-
braic values are derived from the base class AlgebraicValue. Each class has
its (virtual) methods for multiplication with members of the same class from
the right or left, for addition, and for multiplication with real numbers α.
In some cases (like strings) the multiplication with real α does nothing if
α 6= 0, and converts to a zero-element otherwise. Given any two classes A, B
of algebraic values, there is a unique class C, the “ least common ancestor“,
such that A and B are derived from C, but not from any class that is derived
from C. The result of right multiplication ∗ = is computed by invoking the

14

multiplication-method of C. Addition and left multiplication are treated in
the same way.

The inheritance tree is shown in ﬁgure 3.

Value

AlgebraicValue

AffineTransformation

AffineFrame

Matrix

EnzymeValue

Map

String

Predicate

Double

MaxPlus

Int

TrueForAllValences

Key

AntiKey

Figure 3: The class diagram for diﬀerent types of values.

There is one type of algebraic values of interest where the condition of
remark 1 is violated, the max-plus or timetable “algebra”. Its data are real
numbers (or real matrices), a ◦ b = a + b (addition of real numbers) and
a⊕b = max(a, b). For matrices, the operations are entry-wise. This “algebra”
is useful in so called discrete event systems [4], and in optimization problems
where one requires the maximum of errors which are given by real return
values of local cost functions.

There may be a (singly linked) list of AlgebraicValues in a link. In this

case, multiplication is element by element in the list.

Values in Objects need not be of type AlgebraicValue. But for instances
η of useful data types, multiplication with AlgebraicValue A from the left
is deﬁned and is associative (i.e. (A ∗ B) ∗ η = A ∗ (B ∗ η)). The multipli-
cation may be trivial, i.e. A ∗ η = η for all A. In case η is itself of type
AlgebraicValue, multiplication is deﬁned as described above.

Deﬁnition 3 ( Parallel Transport) Given a link b with AlgebraicValue A and
the value η of its source object Y , A ∗ η is regarded as a potential value of the
target object X of the link b, and the operation is called the parallel transport
of η from Y to X along the link b.

15

The parallel transport along links may be composed to parallel transport
along paths {b0, ..., bn}. Parallel transport along 1Y is the trivial map η 7→ η.
The notion comes from lattice gauge theory of elementary particles [6] and
general relativity.

Remark 2 Because of associativity, the result of the parallel transport de-
pends actually only on the arrow deﬁned by the path.

It may happen that the result of parallel transport of some type of value
from Y to X is independent of the chosen path from Y to X. In this case
the type of value is called an invariant.

Invariants have a global meaning in a connected system, because they
may be parallel transported from any Y to any X in a unique way. Important
examples are i) quantities of any chemical substance which is transferred from
object to object by diﬀusion, ii) payments in an economy.

Counterexamples are any kind of “non-ideal communication”, such as
communication of humans in natural language. Utterances in natural lan-
guage do not generally have a globally well deﬁned meaning - one’s owl is the
other’s nightingale. Gossip is an example. When the message comes back
to speaker X who send it out, it may have undergone dramatic change. So
the result of communication around some loop is not the same as along the
identity 1X.

5.3 Enzymes

We proceed to describe the most important micro-enzymes, beginning with
motion: It involves either multiplication of two links, or promotion of a
virtual adjoint of a link to the status of a link. We have enzymes V M L
for left multiplication and AM R for right multiplication. Given a V M L-
enzyme e with attached predicate p, e.act(r,m) will go through all valences
v of r, and multiplies those v from the left with the adjoint of m for which
p.evaluate(r,v) returns TRUE. An illustration is found below.
In this
ﬁgure, virtual valences are indicated as dotted lines. The AM R-enzyme is
similar.

6
am m
?-
v

o

VML-

I
am ◦ v
6
?-
R

6
am m
?-
v

o

VML-

16

I

6
?

am ◦ v
R

Alternatively, motion may involve the promotion of the adjoint of a link
to the status of link. There are enzymes to do that, one of them is the
M AD-enzyme. It makes adjoints of all valences into links which fulﬁll the
condition set by a predicate. RF U acts in the same way, except that the
argument v is replaced by its adjoint, and the source of v substitutes for r.

 -  - MAD-

 -  - RFU-

 -  -

To change a valences status from fundamental to virtual, an enzyme

M V V is used.

Growth: The most important enzyme is CP O which copies an object,
and links original and copy by an identity link. (Another version searches for
the copy in the environment). The object may be composite, i.e. a system.
CP O appears in the ﬁrst micro-enzyme in the splitFork enzyme as shown
in ﬁgure 6 in section 8.1. In the ﬁgure there, some predicates are indicated
by a string-code {?...} enclosed in braces. Their meaning is as follows

?nLK v is not a link (i.e. is a virtual valence)
?iAD adjoint of v is a link, negation ?nAD.
?iID v is an identity link.
?hLS detect a triangular structure.
There are also enzymes like SY A which make objects of subsystems

whose boundary is marked by membranes.

Death:

links are removed by RT V or RM V enzymes which kill the
particular valence given as argument, or all valences which fulﬁll a condition.
(The RM V -enzyme operates in ﬁgure 6 to remove identity links.)

A removal of a radical with all its valences and their adjoints by the

DEL-enzyme.

Enzyme management enzymes: Among them there are presentation en-
zymes. They have relatives in cell biology [2]. They hand arguments (r,v)
to another enzyme. For instance, for a P RS-enzyme e, (“present Source”)
e.act(r,v), presents (s, adjoint(v)), (s=source of v) to be acted on by
the next enzyme following e in an enzyme chain. Predicates may make the
presentation conditional.

There are also quantors such as fALL which invokes the action e.act(r,v)
of an enzyme e for all valences v of a radical r which fulﬁll a condition; e
is appended as tail of an enzyme chain with head fALL. ( A forAll Quantor
exists also for predicates.)

17

Unless one uses the concurrent version of the dynamics (cf. section 3.1),
the present implementation for single processor machines oﬀers the option of
reporting an enzyme to an agenda together with the argument pair (r,v)
it will act on, instead of attaching it to the valence v or the object of r
in the system. There are enzymes to do that. A Sag-enzyme (“source-
to-agenda”) in an enzyme chain reports the whole chain together with (s,
NULL), s the source of its v-argument.

Membranes: The “push membrane” enzymes P IM and P OM sur-
rounds a radical by a membrane (attached to all its valences) or pushes
the radical inside resp. outside a membrane that goes through one of its
valences resp. its adjoint. The membrane’s code is speciﬁed by a predicate.
Paths: There are enzymes to make or prolong paths along speciﬁed va-

lences.

6 Graphic Interface

There is a graphic interface which can be used to construct systems and
manipulate them by use of enzymes. All this is done by mouse click, except
that numerical or text-data need to be entered from the key board when they
are not copied from somewhere.

All operations are recorded and translated into code by use of the LISP-
like scripting language which is described in the next section. In this way,
programs which construct systems or code for processes on systems can be
composed by mousclick.

In detail one may

- Position objects or delete them
- Link them by valences (with or without adjoint link) or delete links.
- Enter data (Values) into objects or links.
- Select basic enzymes and accompanying predicates from lists.
- Build composite enzymes as chains of basic “micro-enzymes”.
- Invoke conditional application of enzymes to radicals r with or without a
selected valence v.
Among the enzymes there are some which
- create a membrane around an object, or push a membrane beyond other
objects.
- create paths or prolong them
- create copies of individual objects, of the whole system, or of a subsystem

18

bounded by a membrane.
- induce sweeps through the whole system [or through a part of it which is
bounded by a membrane or marked by path-Links], applying the tail of an
aF RK-enzyme to every radical in it once.
- induce sweeps which are reﬂected at the locus of maximal path distance,
assemble data from all the objects and links of the system and report them
to the system’ root. The computation of maxima of real data at all objects
is a sample application.
- induce diﬀusion within the system or a subsystem.

Coordinates are assigned to each object. A panel allows to rotate and
translate the coordinate system. Diﬀerent windows admit diﬀerent views on
a system and its dynamical behavior.

6.1 Permanence: XML

Methods are provided to translate a system into XML and conversely to
construct a system from XML-code. The methods can be invoked through
the graphic interface.

In this subsection we assume the reader is familiar with XML. An intro-

duction to XML can be found in [18].

The dtd (document type deﬁnition) listed in [31] deﬁnes tags and their
possible attributes for the systems elements. An internal id number is as-
signed to each object and valence to let a valence remember its source, target
and adjoint valence.

The <system> tag encloses anything else inside the document. The
<object> tag carries an objects id number and a position as attributes.
<value> tags may be enclosed. The <valence> tag carries a valences id
number, the id numbers of its source and target objects and of its adjoint
valence as attributes. Again, <value> tags may be enclosed. The <value>
tag carries the value type and the value content as attributes.

The way XML is designed it allows future extensions while assuring up-
and downward compatibility.

19

7 The Scripting Language

If a particular kind of complex problem occurs very often,
it might be
worthwhile to express instances of the problem as sentences in a simple
language[12]. Solving a problem then means to interpret the sentence, for
which an interpreter is needed.
Based on a certain grammar which deﬁnes a simple language, the interpreter
represents and interprets sentences in that language. To be eﬃcient, charac-
ter strings which make up the sentences are transformed into trees of objects,
which are easy to handle by the interpreter. This transformation is done by
a software called parser.
The grammar used for our purposes is very similar to the one used by the
list processing language LISP.

expression ::= list | atom
list ::= ‘(’ expression* ‘)’
atom ::= ‘a’ | ‘b’ | ... | ‘z’ | ‘+’ | ‘-’ | ‘*’ | ‘/’ | ‘$’ |
{ ‘a’ | ‘b’ | ... | ‘z’ }* | ‘ quote ’ expression

In object oriented software design, a well known interpreter pattern (sug-
gested in ref.[12]) has shown to work ﬁne in most cases. To implement a
parser and interpreter for the SyCL program package, this pattern is used
in combination with a composite pattern [12] and extended by one more ab-
straction in the way shown in ﬁgure 4.

The Element class is abstract. It provides polymorphism by assuring that
every object is of type Element. A Element can thus either be an object of
type List, which consists of further Elements, or an object of type Atom,
where Atom is abstract again. The following classes are derived from class
Atom.

A list can consist of elements of any kind. To evaluate a list, the ﬁrst element
has to be a function, or an enzyme, where the following elements serve as
parameters, which have to be evaluable unless they are quoted (i.e. they
start with a quote).

20

Element

Eval() : Element

next

Atom

List

top

IntAtom

DoubleAtom StringAtom FunctionAtom ObjectAtom

ValenceAtom EnzymeAtom

value : int

value : double

value : text

value : int

value

value

Enzyme

Valence

Object

value

Figure 4: The class diagram for the SyCL parser.

Implemented Functions

The commands, this interpreter can execute are listed below. Enzymes can
be applied as well, taking a radical or a list of a radical and a valence as a
parameter.

(adjoint v) returns the adjoint valence to valence v
(append expr li) appends the expression expr to the list li and returns this
list. The original list remains unchanged!
(car li) returns the ﬁrst element of the list li
(cdr li) returns the list li without its ﬁrst element
(connectto a x y z) searches the system for an object at the position
(x, y, z) and assignes the variable a to it.
(delete a) removes element a from the variable list and deletes it (compare
remove).
(edit a b) changes the value of an object or valence a to the SyCL value b.
(enzyme expr) deﬁnes a new enzyme from the expression expr. expr has
to be of the form xxxx=enz1enz2enz3.... and must be quoted in order not
to be executed as a command! The newly deﬁned enzyme is automatically
inserted into the enzymelist as well as the enzyme menu from the GUI.

21

(enzymes) returns the list of enzymes.
(eval expr) evaluates the expression expr.
(equal a b) or (eq a b) returns 1 if a and b are equal, an empty list oth-
erwise.
(for (n i0 i1) ( expr1 expr2 expr 3 ... )) evaluates the expressions
expr1, expr2 and expr3 ... with the variable n taking integer values from i0
to i1
(funlist) returns the list of implemented functions.
(greaterthan a b) or (gth a b) returns 1 if a is greater than b, an empty
list otherwise.
(if expr ( expr1 expr2 expr3 ... )) evaluates the expressions expr1, expr2
and expr3 ... if expr is true.
(length li) returns the number of elements of the list list.
(lessthan a b) or (lth a b) returns 1 if a is less than b, an empty list
otherwise.
(list a b ... ) returns a list with the parameters a, b, ... als elements.
(load ﬁlename) loads and evaluates commands in a ﬁle ﬁlename. This can
be done more comforably with a ﬁle-select box via the GUI open ﬁle menu
entry.
(minus a b) (- a b) returns the diﬀerence of a and it b.
(newo a) creates a new SyCL object of SyCL value a and returns an object
element.
(notequal a b) or (neq a b) returns an empty list if a and b are equal, 1
otherwise.
(nth n li) returns the nth element of a list li. Counting starts at zero!
(nthval n a) returns the nth valence of the valences directed toward the
object a (counting from 0).
(oblist) returns the list of variables.
(poso a x y z) repositions the object designated by variable a at (x, y, z).
(plus a b) (+ a b) returns the sum of a and b.
(rand n) returns an integer random number between zero (inclusive) and n
(exclusive).
(remove a) removes element a from variable list (compare delete).
(replacenth n li expr) replaces the nth element of a list li by expr and
returns this list. The original list li remains unchanged!
(run ’(e v)) lets the enzyme e act on the source of valence v.
(set a b) same as setq, but evaluates a ﬁrst.
(setl l v a b) a and b have to be object elements. An unidirectional valence

22

is created between a and b with a SyCL values v. The valence element is
assigned to the variable l.
(seto a [’int | ’real | ’bool | ’enz] [’vector m | ’covector n | ’matrix m
n] b... [x [y [z]]]) creates a SyCL object with a SyCL value b (evaluated)
and assigns the object element to the variable a. Creating a vector of dimen-
sion m, a covector of dimension n, or a matrix of dimension mxn requires
mxn elements b! x, y, z can be appended to specify coordinates.
(setq a b) creates an expression, sets it to b (evaluated) and assigns it to
the variable a.
(setv v v0 v1 a b) a and b have to be object elements. A bidirectional
valence is created between a and b with SyCL values v0 and v1 for the valence
and its adjoint. The valence element is assigned to the variable v.
(times a b) or (* a b) returns the product of a and b.
(valences a) returns the number of valences directed toward an object a.

The following script may serve as an example of motion along a valence

v between two objects a and c:

(seto a 1)
(seto b 2 100)
(seto c 3 0 100)
(setv v 1 1 a b)
(setq w (adjoint v))
(setv m 1 1 a c)
(setq q (adjoint m))
(enzyme ’move=_AMR_RMV{?nAD}_PRS_RFU)

(move ’(a m))

The last command invokes the action of the above deﬁned enzyme move with
object a and valence m as parameters.

8 Some basic Processes

8.1 Enzymatic Copying

Let us call a link bidirectonal if its adjoint is also a link, unidirectional other-
wise. Note that the terms are used to characterize individual links, not pairs
(link, adjoint link).

23

-
-

s
+

-



-



=⇒

-


-

-


s
- +

-

Figure 5: Replication fork dynamics.

There exists an enzyme, call it the splitFork-enzyme, whose continued
conditional application to a ﬁnite system S whose links are all bidirectional,
produces after some ﬁnite time two copies of S.

This is a generalization of the asymmetrical replication fork mechanism
which the living cell uses to copy DNA [2]. It works not only for chains of
pairs of bidirectional links (which mimick the double helix of DNA), but for
any system whose links are all bidirectional, independent of its topology.
[All the interna like (possibly overlapping) internal structure of constituent
objects, membranes and pathLinks marking various subsystems are copied
as well]. The operation on chains is shown in ﬁgure 5 The description of the
action sX of the splitFork-enzyme to the radical of object X is as follows.

1. A copy X ′ of X is made.

2. The links incident on X other than loops are distributed among X and

its copy as follows:

- bidirectional links with target X get X ′ as their target

- unidirectional links with target X retain X as their target

- bidirectional links with source X retain X as their source

- unidirectional links with source X get X ′ as their source

The loops X 7→ X remain in place and get a copy X ′ 7→ X ′.

3. The adjoints of formerly unidirectional links are promoted to the status

of links.

One may imagine that the copy X ′ is connected by a pair of adjoint bidirec-
tional identity links to X to begin with. Then the management of the links
can be interpreted as instances of motion - multiplication with identity links
and creation of fundamental adjoints. In the end, the identity links between
X and X ′ are killed. This decomposition of the splitfork-enzyme into an
action of micro-enzymes is illustrated in ﬁgure 6.

24

_CPO

_AMR{?nLK}

_VML{?iAD}

_MAD

_PRS

_RFU

__RMV{?iID}

Figure 6: One step within a sweep of the SplitFork enzyme: sFRK = CPO
AMR{?nLK} VML{?iAD} MAD PRS RFU RMV{?iID} Sag{?nAD}

Deﬁne a fork at X as a pair of links, both unidirectional, one with target

X and the other with source X.

Theorem 1 (Universal copy constructor) Let S0 be obtained from a ﬁnite
connected system S whose links are all bidirectional by action of sX0 at some
X0 ∈ S. For t > 0, let St be obtained from St−1 by action of sX for all objects
X such that there is a fork at X.

St is well deﬁned for t ≥ 0. For suﬃciently large t, it is independent of t

and consists of two disconnected copies of S.

“Once replication has started, it continues until the entire system has been
duplicated”. Upon substituting “genome” for “system“ this becomes a
quote from a genetics text book [17].

This theorem was ﬁrst demonstrated in [20].
The fact that sX is mathematically well deﬁned is somewhat subtle. It
rests on a theorem, proven in [21], that a system can be speciﬁed up to
isomorphism by enumerating its arrows, which of them can be composed

25

and which arrow is the result. One must also indicate which arrows are links
and what are their adjoints. But nothing need be said about objects - they
can be reconstructed. Using this, the above theorem can be proven, with
the understanding that the phrase “two copies of S” means “two systems,
both isomorphic to S”. The isomorphism class of S does not retain the
information about the internal structure of non-atomic objects (black boxes).
But this information can be retained by the copies. To retain it, one uses
the universal copy constructor to copy objects of S which are themselves
systems, to copy their non-atomic constituents, and so on. This does not
continue ad inﬁnitum by the axiom of non-self-inclusion.

The fact that the dynamics is well deﬁned rests on the fact that sXsY =

sY sX for the kind of systems that occur as St.

The action of the splitFork-enzyme is quite robust against errors due to
computer failures which mimic local mutations. But there is one exception
which leads to catastrophic results of the type of Down’s syndrome - a third
copy is made of part of the system. This happens when a fundamental
adjoint gets lost (or added) “at the wrong moment”, cf. [20]. 6

There is a more ﬂexible (but not quite as axiomatic) version of the
splitFork-enzyme which can be used to restrict copying to subsystems bounded
by membranes. It employs membranes in place of the prototypical membrane
made by unidirectional links.

8.2 Digestion

In animals, building blocks of newly made structures must ﬁrst be prepared
by degrading ingested organic material by metabolic processes.

Here we describe an enzyme whose continues action dX at an object X
of a connected system degrades its internal structure in the manner shown
in ﬁgure 8.2.

dX consists of consecutive steps.
1. (Death) The far side of all triangles of 3 links with tip X is removed,

together with their adjoints.

2. (Motion) If b is a link from Y 6= X to X and b′ is a link from Y ′ to Y

then b ◦ b′ becomes a link and b′ ceases to exist as a link.

3. Fundamental loops X 7→ X are removed.

6In man, Down’s syndrome is caused by the presence of three copies of chromosome

no. 21 instead of the usual two

26

X

⇒ X

⇒ X

⇒ X

Figure 7: Digestion enzyme attacks at X

Actually the 3rd step can be dispensed with when step 2 operates also

for Y = X.

8.3 Reaction Diﬀusion

Restrict attention to those values of objects which can be added and sub-
tracted.

Consider a radical r with object X and its valences v with source objects

Yv. There is an enzyme which does the following.

For every valence v with source Yv (or those which fulﬁll the condition
set by a predicate) it takes a fraction α ∈ R of the original value ξ of X,
subtracts it from ξ, parallel transports it to Yv along v and adds the result
to the value ηv of Yv. Conversely, it takes a fraction α of the original value
ηv, subtracts it from ηv, parallel transports it to X and adds the result to
ξ. In the most important examples, the parallel transport is trivial (i.e. ξ, η
are invariants). This models diﬀusion.

One may add loops X 7→ X which eﬀect nonlinear maps of the values of

X as “parallel transports”. This models reactions, e.g. chemical reactions.

8.4 Shock fronts

The splitFork dynamics is an example of the mechanism of propagating shock
fronts. It is an abstraction of the most essential feature of shock fronts in
nature. 7 In the splitFork dynamics, there is at any time a bipartite boundary
between the part of the system which has not yet been copied, and the two

7Shock fronts occur in nature as a consequence of nonlinearity in excitable media [7]
when the passage of an excitatory event is followed by a dead time. It has the consequence

27

copies of the rest. The two boundaries with the two copies have opposite
orientation. They are made of the unidirectional fork prongs. The excitation
(sF RK-action) is restricted to radicals which have forks, and it can only
pass through bidirectional links into the part of the system which has not
been copied yet.

Similarly, a single boundary made of unidirectional links may be made
to propagate unidirectionally. There is an enzyme aF RK to do that.
It
generates sweeps through the system. Making an enzyme chain with head
aF RK and some tail will make the tail act on every radical r of the system.
This may be used to induce relaxation sweeps, for instance.

8.5 Cellular growth

Cell replication can be achieved by realization of the following idea: A cell
A gets triggered to replicate, for instance by a certain value of a gradient
to a neighboring cell B. A copy C of A is made and placed between A
and B in order to smoothen the gradient. Therefore the fundamental links
between A and B are replaced by new fundamental links between B and C.
Furthermore C obtains new fundamental links to all neighbors, A and B are
both connected to (see ﬁgure 8).

8.6 Assembly of data

Consider a ﬁnite system with a distinguished radical root. We describe
another shock wave mechanism, call it assemblyFork, which can be used to
assemble data from the system at root.

First one sends out a shock wave which builds a spanning tree - details

are given below.

Take any data which are of type AlgebraicValue. They may be attached
to objects or links. The assemblyFork-dynamics computes the sum of these
algebraic values, parallel transported along the branches of the tree, and
deposits it at root.

For instance, the data maybe sets of strings 8, as occur in encodings of

that the excitation can only propagate in the outward direction because a renewed exci-
tation is prohibited during the dead time. Forest ﬁres are a well known and much studied
example [9]. Natural neurons also have a dead time after ﬁring.

8sets become lists by lexicographic ordering

28

_MVV

fALL{?hLS}

(_MAV)

_CPO

_AMR

{?nAD||?nLK}

_MAD_PRS_RFU

Figure 8: Cell replication in a system theoretic diagram: cell = MVV fALL
{?hLS}( MAV) CPO AMR {?nAD||?nLK} MAD PRS RFU

data in XML, where ◦ is concatenation of strings, and ⊕ is disjoint union
of sets. No loss of information is involved in taking the sum (disjoint union)
in this case.

Or the data may be the (real) elements of a max-plus-algebra, where
addition amounts to taking the maximum, and multiplication is addition of
real numbers. The maximum of all the data is computed in this case.

If the data are invariants (cf. earlier) then, by deﬁnition, it would make
no diﬀerence if parallel transport were along any path to root other than
the path along the tree. 9

When a shock proceeds up along any of the branches of the tree, a leaf
will eventually be reached where no prolongation of the branch is possible
without creating a loop. Then the shock gets reﬂected and propagates down
the tree, taking data from the leaf along via parallel transport (cf. section
5.2). At any node of the tree, the shock has to wait until the reﬂected shocks

9More generally, if all links are unitary, i.e. if b∗ = b−1, the results diﬀer at most by a

gauge transformation, cf. [21].

29

from all the branches are in. Then the data which they transport are all
added up and the result is transported further down the tree.

The max-plus version of this mechanism is important when one does op-
timization by relaxation. One needs to know the maximum of a measure of
the local error in order to know when to stop.

Let us ﬁnally describe how the spanning tree is made and marked. In
principle, the order of the valences in the valence list of a radical is irrelevant.
But we may either make an exception for the purpose of the assemblyFork-
mechanism, distinguishing the ﬁrst valence as a “principal port”. Or we
may use paths to mark the branches of the tree. Suppose we do the ﬁrst;
generalization will be obvious.

Given a distinguished radical root, the system decomposes into shells
labeled by path-distance 10 n ≥ 0 from root, and links between adjacent
shells. The shells are like the shells of an onion. The n-th shell is a subsystem
which contains all objects with path distance n from root, and the links
between them.

A shock emanating from root propagates from shell to shell in order of

increasing n.

When starting at shell 0, the tree has no link.
When the shock reaches shell n, there is a membrane = boundary between
shell n and n + 1, and the tree n will have been constructed up to shell n.
Now one selects in some arbitrary way links from the boundary such that
each object X of the n + 1st shell is source of exactly one such link. This
can be done by local operations. The adjoint of the unique link with source
X is made principal port of X. In this way the tree has been grown to shell
n + 1. Now one continues. In a ﬁnite system, there are ﬁnitely many shells.
So the process comes to an end.

9 Outlook

There exists also an (exterior) diﬀerential calculus and geometry on systems
[8, 21].
It is intermediate between standard exterior diﬀerential calculus
and geometry on manifolds and non-commutative diﬀerential calculus and
geometry [5]. It satisﬁes d2 = 0 and the Leibniz rule, the algebra of functions
is commutative, and derivatives of functions are ordinary ﬁnite diﬀerence

10path distance was deﬁned in subsection 5.1

30

derivatives. It has not been implemented in software yet, but we plan to do
so in the future.

Another line of current investigation is multiscale analysis [13]. By deﬁ-
nition, genuinely complex systems show “emergent” properties that are not
shared by their subsystems with few objects. The basic idea of multiscale
analysis, including multigrid methods[13] and the renormalization group [29],
is that although a genuinely complex system can not be understood as a whole
by studying reasonably small subsystems in isolation, a complexity reduction
is often possible by doing so. To this end one introduces new objects which
represent subsystems, but one retains only that part of the information on
their internal structure (including functionality, i.e. enzymes) that is rele-
vant for the cooperation that causes emergent - i.e. nonlocal - phenomena.
A related plan is known in information science under the name of integration
[10]. Some theoretical considerations concerning this were presented in [21]
and in [28]. Relaxation sweeps can be implemented by enzymatic compu-
tation, and it is straightforward to extend them to systems which have a
multilevel structure like multigrids. The challenge is to extend the domain
of applicability of existing multigrid and renormalization group technology,
including in particular disordered systems.

Finally it is a challenge to invent an “enzymatic game of life”, and to
implement within the present frame as much of biochemical and larger scale
processes that constitute life. This would be in the spirit of work on Artiﬁcial
life [16].

9.1 Towards an infome project

A much more challenging and long range plan would be an infome project
which amounts to mapping into software what is known about structure and
function in the living cell in such a way that processes that constitute life can
be simulated in silico. After the genome project and the envisaged proteome
project [32] which is supposed to classify all proteins that a human body
makes in its lifetime and their function, this is a logical next step.

Work on immunology along similar lines is in progress [23]; the establish-
ment of a data base has been the proposed. For a discussion of the cognition
problems that are of interest in immunology see [24].

31

10 Acknowledgement

We thank the Deutsche Forschungsgemeinschaft for ﬁnancial support, and
the German Israel foundation for a travel grant. We would like to express
our thanks to Achi Brandt, Irun Cohen, Martin Meier-Schellersheim, Dirk
Rathje, Sorin Solomon, and York Xylander for numerous enlightening dis-
cussions. We also thank Daniel L¨ubbert, Bleicke Holm, Marcus Speh and
York Xylander for their collaboration in earlier stages of this project.

References

[1] L.M.Adleman, Molecular Computation of Solutions to Combinatorial

Problems, Science 266 1021 (1994)

[2] B. Alberts, D. Bray, J. Lewis, M. Raﬀ, K. Roberts, J. Watson. Molecular

Biology of The Cell. Garland Publishing, Inc. 1989.

[3] L. von Bertalanﬀy, Les probl`emes de la vie, Paris:Gallimard 1956

- , General systems theory, George Braziller, New York 1968

[4] Hans Braker, Algorithms and Applications in Timed Discrete Event Sys-

tems, Dissertation Deﬀt 1993
C. P¨oppe, Fahrplanalgebra, Spektrum der Wissenschaft, Digest Wis-
senschaftliches Rechnen 1999

[5] A. Connes, Noncommutative Diﬀerential Geometry, San Diego: Aca-

demic Press 1994

[6] M. Creutz, Quarks, Gluons and Lattices, Cambridge (UK): Cambridge

University Press 1983

[7] M.J. Cross, P.C. Hohenberg, Rev. Mod Phys. 65 (1993) 851

H.L. Swinney, V.I.Krinski (eds), Waves and patterns in chemical and
biologicl media, Physica D49 (1991) 224
J.P. Keenes, J.J. Tyson, Physica D32 (1988) 327,
J.L. Martiel, A. Goldbeter, Biophysics J52 (1987) 807
J.Parisi, S.C. M¨uller, W.Zimmermann (eds), Nonlinear physics of com-
plex systems - current status and future trends, Springer Berlin 1988
- A perspective look at nonlinear media - from physics to biology and
social sciences, Springer, Berlin 1988

32

[8] A. Dimakis, F. M¨uller-Hoissen, Diﬀerential calculus and gauge theory

on ﬁnite sets J. Phys. A27 (1994) 3159
-, Discrete diﬀerential calculus, graphs, topologies and gauge theories, J.
Math. Phys 35 (1994) 6703
A. Dimakis, F. M¨uller-Hoissen, F. Vandersypen, Discrete diﬀerential
manifolds and dynamics on networks, J. Math. Phys 36 (1995) 3771
D. Weingarten, Geometric formulation of electrodynamics and general
relativity in discrete space-time, J. Math. Phys. 18 (1977) 165

[9] B. Drossel, Strukturbildung in oﬀenen Systemen am Beispiel eines Wald-

brandmodells, Reihe Physik Bd 21, Harri Deutsch, Frankfurt

[10] H. Ehrig and F. Orejas, Integration and Classiﬁcation of Data Types and
Process Speciﬁcation Techniques, Bulletin EATCS: Formal Speciﬁcation
Column 65 (1998)

[11] R.P. Feynman, in Miniaturization, D.H. Gilbert, Ed. Reinhold, New

York 1961) pp 282-296
- , The Feynman Lectures On Computation, A.Hey, R. Allen (ed.), Pen-
guin Books, 1999

[12] E. Gamma, R. Helm, R. Jahnson, J. Vlissides. Design Patterns - Ele-

ments of Reusable Object-Oriented Software. Addison-Wesley, 1995.

[13] W. Hackbusch, Multigrid Methods and Applications, New York:Springer

1985
U. Trottenberg, C. OOsterlee, A. Sch¨uller, Multigrid, New
York:Academic Press 1999

[14] H. Haken, Synergetics, Heidelberg: Springer 1978

M.M. Waldrop, Complexity: The emerging Science at the edge of Order
and Chaos, New York: Simon and Shuster 1992

[15] F. Jacob, La logique du vivant, Paris:Gallimard (1970)

[16] C.G. Langton, Artiﬁcial Life, SFI Studies in Sciences of complexity,

Redwood City: Addison Wesley (1989)

[17] B. Lewin, Genes VII, Oxford (UK):Oxford University Press 200, p. 349

[18] R. Light, Presenting XML. Sams.net Publishing, 1997.

33

[19] S. Mac Lane, Categories for the working mathematician, Springer Ver-

lag, New York 1971

[20] G. Mack, Gauge theory of things alive: Universal dynamics as a tool
in parallel computing, Progress Theor. Phys. (Kyoto) Suppl. 122 (1996)
201-212

[21] G. Mack, Universal Dynamics, a Uniﬁed Theory of Complex Systems.
Emergence, Life and Death, DESY 00-146, hep-th/0011074, to appear
in Commun. Math. Phys.

[22] G. Mack, Pushing Einsteins principles to the extreme, in: G. ’t Hooft et
al, Quantum Fields and Quantum Space Time, Plenum Press, NATO-
ASI series B:Physics vol. 364, New York 1997, gr-qc/9704034

[23] M. Meier-Schellersheim, G. Mack, SIMMUNE, a Tool for Simulating
and Analyzing Immune System Behaviour, submitted to Bull. Math.
Biology, cs. MA / 9903017.

[24] A. S. Perelson and G. Weissbuch, Immunology for Physicists, Rev. Mod.

Phys. 69, No.4, 1997.
I. Cohen Tending Adam’s garden: Evolving the Cognitive Immune Self,
Academic Press, New York 2000

[25] C.A. Petri, Kommunikation mit Automaten, PhD-thesis Bonn, Schriften

des Instituts f¨ur Instrumentelle Mathematik (1962)

[26] G. Rozenberg, Handbook of Graph Grammars and Computing by Graph

Transformation. vol 1: Foundations, Singapore:World Scientiﬁc 1997

[27] M. Schrattenholzer, Logik lokal, Diplomarbeit Hamburg 1999

[28] T. Tomkos, Formal speciﬁcation and modelling of Complex Systems. To-
wards a physics of information via networks, phd thesis Hamburg 1999.

[29] K. Wilson, Renormalization group and strong interactions Phys. Rev

D3 (1971) 1818
J. Kogut, K. Wilson, The renormalization group and the ǫ expansion,
Phys. Reports 12C (1974) 75

[30] S. Wolfram (ed) Theory and Applications of Celluar Automata, Singa-

pore: World Scientiﬁc 1986

34

[31] Jan W¨urthner. Enzymatic Simulation of Complex Processes, ph.d. the-
sis, Hamburg, Feb. 2000, accessible via http://lienhard.desy.de . The
most current version SyCL.xx of the software will be made accessible on
the same site.

[32] A. Pandey and M. Mann, Proteomics to study genes and genomes, Na-

ture 405 (2000) 837-846
Proteomics: A Trend guide, Suppl. to Trends in Microbiology, July 2000

35

