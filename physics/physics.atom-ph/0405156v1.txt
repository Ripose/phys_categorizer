4
0
0
2
 
y
a
M
 
1
3
 
 
]
h
p
-
m
o
t
a
.
s
c
i
s
y
h
p
[
 
 
1
v
6
5
1
5
0
4
0
/
s
c
i
s
y
h
p
:
v
i
X
r
a

Maple procedures for the coupling of angular momenta.

VI. LS

jj transformations

−

G. Gaigalas a and S. Fritzsche b †

a Institute of Theoretical Physics and Astronomy,
A. Goˇstauto 12, Vilnius 2600, Lithuania.
b Fachbereich Physik, Universit¨at Kassel,
Heinrich–Plett–Str. 40, D–34132 Kassel, Germany.
† e–mail: s.fritzsche@physik.uni-kassel.de

February 2, 2008

Abstract

Transformation matrices between diﬀerent coupling schemes are required, if a reliable
classiﬁcation of the level structure is to be obtained for open–shell atoms and ions. While,
coupling, a LSJ
for instance, relativistic computations are traditionally carried out in jj
coupling notation often occurs much more appropriate for classifying the valence–shell
structure of atoms. Apart from the (known) transformation of single open shells, however,
further demand on proper transformation coeﬃcients has recently arose from the study of
shell elements, the analysis of multiple–excited levels, or the investigation
open d
on inner–shell phenomena. Therefore, in order to facilitate a simple access to LS
jj
transformation matrices, here we present an extension to the Racah program for the
set–up and the transformation of symmetry–adapted functions. A ﬂexible notation is
introduced for deﬁning and for manipulating open–shell conﬁgurations at diﬀerent level
of complexity which can be extended also to other coupling schemes and, hence, may help
determine an optimum classiﬁcation of atomic levels and processes in the future.

and f

↔

−

−

−

PACS: 3.65F, 2.90+p.

1

PROGRAM SUMMARY

Title of program: Racah

Catalogue identiﬁer: ADQP

Program Summary URL: http://cpc.cs.qub.ac.uk/summaries/ADQP

Program obtainable from: CPC Program Library, Queen’s University of Belfast, N. Ireland.

Licensing provisions: None.

Computers for which the program is designed:
All computers with a license of the computer algebra package Maple [1].

Installations: University of Kassel (Germany).

Operating systems under which the program has been tested: Linux 6.1+.

Program language used: Maple V, Release 6 and 7.

Memory required to execute with typical data: 30 MB.

Keywords: angular momentum, complex atom, conﬁguration state function, jj
LS
relativistic, subshell state.

coupling,
jj transformation, LSJ and jjJ spectroscopic notation, nonrelativistic,

coupling, LS

−

−

−

Nature of the physical problem:
For open–shell atoms and ions, a reliable classiﬁcation of the level structure often requires the
knowledge of the LS
jj transformation matrices in order to ﬁnd the main components of the
wave functions as well as their proper spectroscopic notation. Apart from the transformation
of individual (sub–) shell states, matrices of much larger complexity arise for the transfor-
mation of symmetry–adapted conﬁguration state functions which are constructed from the
coupling of two or more open shells.

−

Method of solution:
jj transformation matrices are provided for all (sub–) shell states with orbital angular
LS
−
3 in the framework of the Racah program [2]. These matrices are then utilized
momenta l
to transform symmetry–adapted conﬁguration state functions (CSF), including the coupling
of two open shells. Moreover, a simple notation is introduced to handle such symmetry
functions interactively and to transform even atomic states which are given as a superposition
of CSF.

≤

Restrictions onto the complexity of the problem:
The program presently supports all shell states with l
7/2, i.e. up to open f7/2−
LS

coupling and with j

≤

−

3, i.e. up to open f
subshells, in jj

shells, in
coupling.

≤
and g7/2−

−
−

2

shells
For the transformation of conﬁguration state functions, the coupling of two open LS
or, correspondingly, four jj
coupling, however, a stan-
subshells are also supported. In jj
dard order [cf. subsection 2.2] is always assumed for the coupling sequence of the individual
shells. Several simpliﬁcations are used on the basis of this standard order.

−

−

−

−

−

−

and jj

Unusual features of the program:
jj transformation matrix elements between
Apart from the ”interactive access” to the LS
(sub–) shell states in LS
coupling, a complete transformation of the coupling scheme
can be carried out also for conﬁguration respectively atomic state functions, just by typing
a few lines at Maple’s prompt. To simplify the handling of the program, a short but very
powerful notation has been introduced which help the user to construct stepwise symmetry–
adapted functions of diﬀerent complexity. But although the program presently supports only
coupling, the same notation can be extended also to incorporate
shell states in LS
further coupling schemes in the future. The main commands of the present extension are
described in detail in Appendix B; for a quick reference on the current capabilities of the
Racah program, we refer the reader to Ref. [3] and to a list of all available commands in the
ﬁle Racah-commands.ps which is appended to the code.

and jj

−

−

Typical running time: The program replies promptly on most requests. Even large tabula-
tions of LS

jj transformation matrices can be carried out in a few (tens of) seconds.

−

References:
[1] Maple is a registered trademark of Waterloo Maple Inc.
[2] S. Fritzsche, Comp. Phys. Commun. 103, 51 (1997); G. Gaigalas, S. Fritzsche, B. Fricke,
Comp. Phys. Commun. 135, 219 (2001).
[3] S. Fritzsche, T. Inghoﬀ, T. Bastug and M. Tomaselli, Comp. Phys. Commun. 139, 314
(2001).

3

LONG WRITE–UP

1

Introduction

The classiﬁcation of the level structure of open–shell atoms and ions is a non–trivial task
which occurs frequently in the interpretation of complex spectra. In the analysis of optical
spectra, for instance, the correct knowledge of the LSJ spectroscopic notation of the atomic
states may help isolate individual levels and terms without that the theoretical energies from
ab–initio computations need be accurate enough for a direct assignment of the observed lines.
In fact, such a demand arises already for rather simple shell structures such as the spectrum
of Ne II [1], for which the lowest excited 2s2p 6 2S term occurs high–up in the theoretical
level structure, even if a sizeable wave function expansion is applied, and therefore may lead
to misassignments — if no additional information about further properties of these levels
or about their representation in diﬀerent coupling schemes is available. Since, today, most
relativistic computations are carried out in jj
jj
transformation of atomic states is of primary interest.

coupling, an eﬃcient and reliable LS

−

−

For atoms with a single open shell and, in particular with an open s
jj
transformation matrices are well known and can be obtained from diﬀerent sources [2, 3, 4].
These matrices are also the building blocks for the transformation of all symmetry–adapted
functions and are often simply abbreviated by

shell, the LS

or p

−

−

−

l N αLS J

*

| 



−
N −
ν

−
κ

−
J,

+
N +
ν

+
J

+
κ

J

,

+





(1)

−
N +

i.e. in terms of Fourier coeﬃcients of the corresponding shell states in the (re–coupled) basis.
+
N
However, such matrices for a single–shell conﬁguration with ﬁxed occupation N =
are only of little help in transforming atomic or conﬁguration states with a more complex shell
structures for which the individual (sub–) shell states need to be treated consistently with
respect to their deﬁnition, choice of quantum numbers as well as their phase relation to each
other. Therefore, in order to extent the single–shell matrices (1) to open d
shell con-
ﬁgurations or to evaluate these transformation matrices for complex shell structures, insight
into the construction of the subshell states is required for the all the coupling schemes under
consideration. Moreover, the size of the transformation matrices (1) increases rapidly with
the orbital angular momentum l due to the large number of (allowed) projections ml of the
electrons in any open–shell conﬁguration (n1l1)N1, (n2l2)N2, . . . [5]. For these two reasons
and due to the complexity of the recoupling coeﬃcients, which arise in the evaluation of the
transformation coeﬃcients [cf. Eqs. (22–23)], these matrix elements are often not available
from the literature, not to mention the eﬃciency of their use if more than one open shell is
involved and if such transformation need to be carried out explicitly.

and f

−

−

Today, an alternative and much simpler access to the transformation between diﬀerent cou-
pling schemes is possible by means of computer–algebraic manipulations. For the coupling of

4

angular momenta, for instance, such a framework for symbolic manipulations have been de-
veloped by us during recent years and is now known as the Racah program [6]. This program
is a powerful tool in simplifying formal expressions from the theory of angular momentum.
Recent developments to this package concerned not only the fast and reliable evaluation of
Racah expression but also the implementation of standard quantities [7], spherical harmonics
[8] as well as the evaluation of recoupling coeﬃcients [9]. Therefore, the Racah package also
meets (most of) the basic requirements which are needed for the transformation of general,
symmetry–adapted functions between diﬀerent coupling schemes. With the present extension
to the Racah package, we now support a convenient set–up and application of the LS
jj
−
3. In
transformation matrices for all atomic (sub–)shells with orbital angular momenta l
addition, a powerful notation is provided for dealing with symmetry–adapted functions at
diﬀerent level of complexity such as atomic and conﬁguration state functions as obtained from
relativistic computations. In the present implementation, we support the transformation of
such symmetry functions with up to two open (nonrelativistic) LS
shells or up to four (rel-
ativistic) jj
subshells, respectively. For even more complex shell structures, moreover, we
intent to utilize and implement these developments directly into the available atomic codes
such as Grasp92 [10] or the Ratip package [11]. But already with the present extension of
the Racah program, a major step in the LSJ classiﬁcation of atomic and ionic levels has
been achieved.

≤

−

−

−

In the next section, we ﬁrst explain the construction of symmetry–adapted functions in LS
−
and jj
coupling, respectively, as well as the evaluation of the transformation matrices. This
is followed in section 3 by a short review about Racah’s program structure and how it is
distributed before we illustrate and discuss several examples in section 4. Apart from the
transformation of conﬁguration states with a single open shell, our third example displays the
transformation of two atomic levels as they may arise in standard computations. Section 5
outlines the algebraic evaluation and simpliﬁcation of the transformation matrices, of course,
by making use again of Racah itself. This section points to the road which we need to
go in order to deal with general open–shell states and their transformation among diﬀerent
coupling schemes in the future. Finally, a few comments on further and highly desirable
extensions of the present work are given in section 6.

2 LS

jj transformation matrices

−

2.1 Transformation of subshell states

For a successful transformation of symmetry–adapted functions from one coupling scheme to
another, it is ﬁrst necessary to understand the construction of these functions in some detail.
In atomic shell theory, symmetry–adapted conﬁguration states are usually constructed from
antisymmetrized states of N equivalent electrons of a given shell (nl), to which we brieﬂy
refer as (sub–) shell states below. In LS
coupling, for example, such a subshell states of the
shell (nl) is written as [3]

−

(2)

nl N αLS

(cid:12)
(cid:12)
(cid:12)

E

5

≥

where α represents all additional quantum numbers which, apart from the total orbital angu-
lar momentum L and total spin S, are needed for the unique classiﬁcation of these states. In
practise, an additional number α is needed only for subshells with orbital angular momenta
3, i.e. for electrons from the f –, g–, . . . shells. A list of all possible subshell states for
l
open s–, p–, d– and f –shells, both in quasispin and seniority notation, has been displayed
previously in Ref. [7], table 1. For the subshell states (2), moreover, the angular momenta L
and S can be coupled also to an total angular momentum J,
, which gives rise
to the so–called LSJ notation. Of course, further additional intermediate angular momenta
will arise if the subshell states of two or more open shells are coupled to each other which,
however, should not be confused with the current discussion about the subshell states for
equivalent electrons.

nl N αLSJ

(cid:12)
(cid:12)
(cid:12)

E

coupling, similarly, the subshell states of N equivalent electrons of a subshell (nκ) are

In jj
represented by

−

where κ is the relativistic (angular momentum) quantum number

κ =

(j + 1/2)

for

l = j

1/2

±

±

nκN νJ

E

(cid:12)
(cid:12)
(cid:12)

(3)

(4)

and two further quantum numbers ν and J are found suﬃcient to classify all subshell states
with j = 1/2, 3/2, 5/2, and 7/2 unambiguously. In this coupling notation, an additional
9/2; for j = 9/2, we use the
quantum number, α, only occurs for subshell states with j
quantum number w = 0, 1, or 2 similar as for f
coupling. A list of all allowed
coupling with j = 1/2, 3/2, 5/2, 7/2, and 9/2 were given in Ref. [7],
subshell states in jj
table 2. In fact, all LS
jj transformations of symmetry–adapted functions can always
be traced back to the corresponding transformation of the subshell states (2) and (3), from
which these symmetry functions are built–up.

shells in LS

≥
−

↔

−

−

Although, at the ﬁrst glance, the deﬁnition of the subshell states in LS
coupling
appears very similar, these states generally belong to diﬀerent irreducible representations of
coupling, each (nonrelativistic) nl–shell is usually ’separable’
the SO3 rotation group. In jj
into two (relativistic) subshells with total angular momenta j± = l
1/2. Therefore, in order
coupled basis1, two subshell states with j− and
to transform a shell state

l N αLS

and jj

−

−

±

−

E

into a jj
−
−
N −
ν

−
κ

−
J

(cid:12)
(cid:12)
(cid:12)

+
N +
ν

+
J

+
κ

and

j+ may both occur in the expansion, i.e.

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
relativistic quantum number κ to simplify the notation below. Obviously, also, N =
(cid:12)
and
when one considers the corresponding total angular momentum j± = l

+
κ +1) > 0 must hold where the notation
(

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
−
κ > 0 and

+
N
+
κ < 0 becomes clearer

−
N +

−
κ =

1/2.

−

+

+

, where we utilize again the

±

1Here and in the following, we often omit the principal quantum number n in the notation of the subshell
states as this quantum number is irrelevant for the transformation properties of these states. The principal
quantum number is needed only if two or more subshell states with the same l and j but diﬀerent n’s later
occur in the construction of the symmetry functions.

6

l). Here,

−
N −
ν

−
J,

−
κ
(

+
N +
ν

+
κ

+
J) J

+

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

Making use of this notation, the transformation between the subshell states in LS
jj

coupling can be written as

−

and

−
N −
ν

−
J ,

−
κ

(

(N−

+
κ

−
N )+
ν

+
J) J

−
N −
ν

−
J ,

−
κ

(

+
κ

(N−

−
N )+
ν

+
J) J | l N αLS J

(5)

+ *

l N αLS J

=

(cid:11)

−
N

−
−
+
X
ν
J
ν

+
J

(cid:12)
(cid:12)

−
N −
ν

−
κ

−
J,

+
N +
ν

+
κ

+
J) J

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
−
N+

+

=

l (

N) αLS J

+

−
N +

l (

N) αLS J | (

−
N −
ν

−
κ

−
J ,

+
N +
ν

+
κ

+
J ) J

(cid:29) *
which, in both cases, includes a summation over all the quantum numbers (except of κ and

αLS (cid:12)
X
(cid:12)
(cid:12)
(cid:12)

+

+

+

(6)

−

(
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

is a coupled state with well–deﬁned total angular momentum

J which is built from the corresponding jj

coupled subshell states with j± = l

1/2 and

the total subshell angular momenta

−
J and

−
+
J, respectively.

±

An explicit expression for the transformation coeﬃcients

−
N −
ν

−
J,

−
κ
(

+
κ

−

(N −

N)+
ν

+
J) J

l N αLS J

=

|

+

*

+

−
N +

l (

N ) αLS J

−
N −
ν

−
J,

−
κ
(

+

N +
ν

+
J) J

+
κ

|

+

*

(7)

−

in (5) and (6) can be obtained only if we take the construction of the subshell states of
1 electrons into
N equivalent electrons from their corresponding parent states with N
account. For a number of special conﬁgurations, expressions for these coeﬃcients have been
displayed before in Ref. [12].
In general, however, the recursive deﬁnition of the subshell
states, out of their parent states, also leads to a recursive generation of the transformation
matrices (7) which we summarize in Appendix A. For the moment, it is suﬃcient to say
that these transformation coeﬃcients can be chosen real and that they occur very frequently
as the building blocks in the transformation of all symmetry functions. The transformation
matrices (7) are therefore implemented in a suitable form for all (sub–) shells with l
3 and
occupation numbers N = 1, 2, ..., 2l + 1 in the current extension to the Racah program.
..., 4l + 2, these transformation
For all other allowed occupation numbers N = 2l + 2,
coeﬃcients are obtained according to their electron–hole symmetry from the matrix elements
for N ′ = 4l + 2
N . Such a symmetry relation was established originally by Grant et al.
3.
[18] and later utilized also in the tabulations of Gaigalas et al. [5] for all subshells with l

≤

−

≤

2.2 Coupling of subshell states

Of course, many electron conﬁgurations with a single open shell occur in the notation of
atomic levels and may allow a rough characterization. For a detailed representation of these
levels, however, conﬁguration state functions (CSF) with several open shell need to be taken
into account, a situation which is even strongly enhanced when open d
shell elements
In such situations, the construction of a suitable
or excited levels are to be considered.
symmetry–adapted basis for the representation of the atomic states also requires the coupling
coupling, typically, a CSF basis is constructed
of two or more (open) subshell states. In LS

or f

−

−

−

7

E

E

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

=

from a stepwise coupling of the individual shells l N1

, l N2
2

, ...

1

(...(((l N1

1 α1L1S1, l N2

2 α2L2S2)L12S12, l N3

3 α3L3S3)L123S123)...) J

(8)

which could be written explicitly also in terms of a Clebsch–Gordan expansion. For the case
of two open shells, for example, a proper CSF basis

1 α1L1S1, l N2
(l N1

2 α2L2S2)LS J

E
lN1
1 α1L1S1 ML1MS1

lN2
2 α2L2S2 ML2MS2

ML1 MS1 ML2 MS2 MLMS (cid:12)
X
(cid:12)
(cid:12)
L1ML1 L2ML2 |

× h

E (cid:12)
(cid:12)
(cid:12)

LMLi h

S1MS1 S2MS2 |

SMSi h

LML SMS |

JMJ i

(9)

includes the coupling of the subshell orbital angular momenta L1 and L2 to a total L and
the subshell spins S1 and S2 to a total S which are ﬁnally coupled to a total J.

coupling. In principle, again, any (predeﬁned) sequence of the jj

A very similar sequence for the coupling of the subshell states
, ... is
coupled
applied also in jj
E
subshells will give rise to a valid many–particle basis. For practical purposes and in particular
for an eﬃcient transformation of such conﬁguration states, however, it is useful to deﬁne a
standard order for jj

coupled conﬁguration states such as

ν2J2

ν1J1

−

−

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

E

,

κ N1
1

κ N2
2

−

−
N 1
1

−
κ

−
ν 1

−
J 1,

+
N 1
1

+
κ

+
ν 1

+
J 1)J1,

−
N 2
2

−
κ

−
ν 2

−
J 2)J

′
12,

+
κ

+
N 2
2

+
ν 2

+
J 2)J12

−
N 3
3

−
κ

−
ν 3

−
J 3)J

′
123,

+
κ

+
N 3
3

(...(((((

+
ν 3

+
J 3)J123...)J

(10)

+

which fulﬁlls two additional conditions:
(i) If both subshells with common li,

i.e.

−
κi and

+
κi appears in the expansion, these

+
J i) Ji. Formally,
two subshells always occur successively in the sequence (
we can use this sequence even for subshell states with zero occupation if we interprete
κ0ν = 0 J = 0
1; in this case, the full Clebsch–Gordan expansion [cf. (9)] remains valid
due to the orthonormality properties of the Clebsch–Gordan coeﬃcients.
(cid:12)
(cid:12)
(ii) For the LS

jj transformation of conﬁguration states

−
ν i

+
ν i

−
J i,

−
κ

+
κ

≡

(cid:11)

−
N i
i

+
N i
i

−

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

(...(((l N1

1 α1L1S1, l N2

2 α2L2S2)L12S12, l N3

3 α3L3S3)L123S123)...) J

(...(((((

|

*

−
N 1

−
κ

1

−
ν 1

−
J 1,

+
N 1

+
κ

1

+
ν 1

+
J 1)J1,

−
N 2

−
κ

2

−

−
ν 2

J 2)J ′

12,

+
κ

2

+
ν 2

+
J 2)J12

+
N 2

−
N 3

−
κ

3

−

−
ν 3

J 3)J ′

123,

+
κ

3

+
N 3

+
ν 3

+
J 3)J123...) J

(11)

+

we further assume in standard order that l1 =
...,
i.e. that the sequence of (sub–)shell states is the same on both sides of the transformation
matrix.

−

−

−
κ1 =

+
κ1 +1), l2 =
(

−
κ2 =

+
κ2 +1),
(

In the following, we always assume this standard order in the derivation of explicit expressions
for the LS
jj transformation matrices. The two conditions (i–ii) simpliﬁes the implemen-
tation of these matrices considerably without much loss of generality. The same or at least

−

8

a very similar order in the sequence of the individual shells is assumed in many standard
programs on atomic structure.

We are now prepared to write down the transformation coeﬃcients

−
N 1

(((

−
κ

1

−
ν 1

−
J 1,

+
N 1

+
κ

1

+
ν 1

+
J 1)J1,

−
N 2

−
κ

2

−

−
ν 2

J 2)J ′

12,

+
κ

2

+
ν 2

+
J 2) J

+
N 2

*

(l N1
1 α1L1S1, l N2

2 α2L2S2)LS J

(12)

|

+

coupling or up to four open subshells in
for the coupling of two open shells in LS
coupling, respectively. As before, an expansion of a LS
coupled CSF in an appropriate
jj
jj
coupled basis is obtained by a summation over all quantum numbers apart from the κi’s.
Making use of the two expansions (5), (9) and of the recoupling theory of angular momenta,
we easily ﬁnd

−
−

−

−

(l N1
1 α1L1S1, l N2

2 α2L2S2)LS J

(cid:12)
(cid:12)
(cid:12)

=
−
N 1

−
N 2

−
ν 1

−
J 1

+
ν 1

+
J 1

−
−
X
J 2
ν 2

+
ν 2

+
J 2J1J2J ′
12

E

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

−
N 1

(((

−
κ

1

−
ν 1

−
J 1,

+
κ

1

(N1−

−
N 1)

+
ν 1

+
J 1)J1,

−
N 2

−
κ

2

−

−
ν 2

J 2)J ′

12,

+
κ

2

(N2−

−
N 2)

+
ν 2

+
J 2) J

+

((L1, L2)L, (S1, S2)S)J

((L1, S1)J1, (L2, S2)J2)J

−
J 1,

+
J 1)J1, (

−
J 2,

((

+
J 2)J2)J

−
J 1,

+
J 1)J1,

(((

−

J 2)J ′

12,

+
J 2)J

|

|

i

(cid:29)

(N1−

−
N 1)

−
ν 1

−
J 1,

+
κ

1

+

+
ν 1

J 1)J1 |

lN1
1 α1L1S1 J1

(N2−

−
N 2)

−
ν 2

−
J 2,

+
κ

2

+

+
ν 2

J 2)J2 |

lN2
2 α2L2S2 J2

+

+

× h

×

(cid:28)

−
N 1

−
N 2

−
κ
(
× *

1

−
κ
(
× *

2

where the third and fourth line denote two recoupling coeﬃcients which ensure that the
sequence of the couplings on the left– and right–hand side of the expansion is taken into
account properly. These recoupling coeﬃcients can be evaluated by means of the Racah
program; here we postpone the derivation until section 5 and display only the ﬁnal result

(l N1
1 α1L1S1, l N2

2 α2L2S2)LS J

(cid:12)
(cid:12)
(cid:12)

=

−
N 1

−
N 2

−
ν 1

−
J 1

+
ν 1

+
J 1

−
−
X
J 2
ν 2

+
ν 2

+
J 2J1J ′
12

E

(((
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

−
N 1

−
κ

1

−
ν 1

−
J 1,

+
κ

1

(N1−

−
N 1)

+
ν 1

+
J 1)J1,

−
N 2

−
κ

2

−

−
ν 2

J 2)J ′

12,

+
κ

2

(N2−

+
N 2)

+
ν 2

+
J 2)J

−
J 2+

+
J 2+J1+J

1)

(
−

×

[J1, J ′

12, L, S]

*

−
N 1

−
κ
(

1

−
ν 1

−
J 1,

+
N 1

+
κ

1

+

+
ν 1

J 1) J1 |

l N1
1 α1L1S1 J1

+

q
L1 S1 J1
L2 S2 J2
J
S
L

J1
+
J 2




(

−
J 2 J ′
12
J2 )

J

×

J2
X

[J2]




−
N 2

−
κ
(

2


−
J 2,

−
ν 2

+
N 2

+
κ

2

+
ν 2

+


J 2)J2 |

× *

lN2
2 α2L2S2 J2

+

9

(13)

+

(14)

Explicit representations of the transformation matrices becomes quickly cumbersome if more
than two open shells are involved. For such complex shell structures, a symbolic and au-
In the present implementation of the Racah
tomatic treatment seems to be inevitable.
program, an automatic transformation of conﬁguration state functions is also restricted to
symmetry functions with two open (LS–) shells, see section 4.

2.3 Transformation of atomic states

Any set of conﬁguration state functions (8) or (10) can be utilized to form a many–particle
basis for the set–up of the (corresponding) Hamiltonian matrix. The diagonalization of this
matrix then results in approximate atomic states, given as a superposition of the accordings
coupled CSF (8) are frequently applied in nonrelativistic atomic structure
CSF. While LS
calculations, the jj
coupled CSF (10) are the basis of most relativistic computations. How-
ever, not much need to be said here about the details of atomic structure theory. For the
sake of simplicity, we can restrict ourselves to the conﬁguration interaction (CI) approach in
which (any) approximate atomic state is either written in terms of a LS

coupled

−

−

−

Ψα(J P )
E

=

r
X

(cid:12)
(cid:12)
(cid:12)

a (LS)
r

(α)

γr LS JP

|

i

or jj

coupled basis

−

=

Ψα(J P )
(cid:12)
E
(cid:12)
(cid:12)

a (jj)
s

(α)

γsJP
|

i

,

s
X
where α = 1, 2, ... enumerate the atomic levels (of the given symmetry) and γr, γs denote
the sets of all quantum numbers as required for an unique classiﬁcation of the CSF. No
further information is needed to understand the transformation behaviour when one wants
from one into another basis:
to transform a state

(15)

(16)

Ψα(J P )
(cid:12)
E
(cid:12)
Ψ (LS)
(cid:12)
α

(J P )
E

←→

.

(J P )
E

Ψ (jj)
α
(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

Obviously, the transformation of any atomic state can be reduced simply to the transforma-
tion of the underlying conﬁguration state functions
, respectively.
For these CSF, explicit expressions have been discussed in the previous subsection.

γr LS JP
|

γsJP
|

and

i

i

−

−

−

−

and jj

and SL

From the user’s viewpoint, of course, the main request to the present implementation concerns
the transformation of atomic states between a LS
coupled basis. For these two
coupling schemes, both directions of the transformation are equally supported, including
a LS
coupling sequence. To facilitate the use of the program as well as the
communication inside of the code, a powerful notation has been introduced to deﬁne and
to manipulate atomic states of type (15) or (16); see section 4 and Appendix B.1 below.
With this additional notations, the transformation of atomic states is achieved by a single
line which can be typed in interactively. But already from the notation in this section it
becomes clear how (easily) other coupling schemes such as JK
coupling [15] could
be incorporated into the program, for instance, in order to search for the best representation
of some level(s) in terms of a single coupling scheme.

or LK

−

−

10

Table 1 Additional commands to the Racah package for LS
jj transformations of coupled (sub–)
shell states. A more detailed description of these new procedures, which are provided for interactive
work, is given in Appendix B. Our new commands also include a number of auxiliarity procedures to
facilitate the communication with and within the Racah program.

−

shell jj(), shell LS()

To represent a (sub–) shell state in either jj

or LS

coupling.

−

−

csf jj(), csf LS()

Racah matrix LS jj()

Returns the LS

jj transformation matrix

To represent a conﬁguration state functions of one or two open shells
in either jj

coupling.

or LS

−

−

l N νLS J

−
−
N −
ν

−
J,

−
κ
(

+

N +
ν

+
J) J

+
κ

for all subshells with l = 0, . . . , 3.

*
Transforms a conﬁguration state function from jj
coup-
ling or vice versa. CSF of diﬀerent complexity are supported by the
program.

to LS

+

−

−

(cid:12)
(cid:12)

Racah transform csf()

Racah transform asf()

Transforms an atomic state function (ASF) from jj
or vice versa.

−

to LS

coupling

−

Racah set coupling()

Deﬁnes the coupling order in the set–up of the LS
either LS

coupling.

or SL

−

shell states to

−

−

3 New procedures for the Racah package

−

Since its ﬁrst publication in 1997, the Racah package [6] has grown considerably. In its early
days, emphasis was put on simplifying those Racah expressions which included summations
only over the Wigner n
j symbols [cf. Ref. [6], Figure 1]. Apart from such algebraic manip-
ulations of expressions, however, recent developments also concerned an improved numerical
support of a few standard tasks from the theory of angular momentum. Following this line,
a number of basic quantities for evaluating (many–electron) matrix elements have been pro-
vided recently [7] and will be further enhanced in the future. With the present extension to
the Racah program, we now facilitate also the access to LS
jj transformation matrices and
to the transformation of general atomic and conﬁguration symmetry functions at diﬀerent
level of complexity.

−

Obviously, any automatic transformation of atomic states must enable the user with a quick
and simple access to the underlying symmetry functions. To support the deﬁnition and
communication of such functions, two basic terms from the atomic shell model play a central
role: atomic shell states and their successive coupling which, ﬁnally, leads to the deﬁnition of
conﬁguration state functions (CSF). In order to simplify the handling of these functions, four
auxiliarity procedures have been designed and introduced into the Racah program with the
intention to keep all necessary information about a subhsell state or a CSF close together.
These procedures such as csf jj(), shell jj(), . . .
are deﬁned separately for each coupling
coupling, and, hence, could be easily extended to include other
or jj
scheme, i.e. for LS

−

−

11

coupling schemes in the future. The procedure Racah set coupling() also diﬀers from most
other commands in that it just ’assigns’ the coupling order LS or SL of the orbital angular
momenta and the spins to a global variable; this particular procedure must therefore be
invoked prior to any other command which deals with LS

jj transformations.

−

Although a simple notation has been worked out in order to construct CSF of any complexity,
an automatic transformation of atomic states is currently supported only for conﬁguration
states with up to two open shells in LS
coupling,
respectively. This limitation has arose from the number of recoupling coeﬃcients which
occur in any transformation and which grows rapidly if more open shells get involved. In
the future, the program might be extended to more complex shell structures if demands arise
from our work or from the side of users.

and up to four open subshells in jj

−

−

jj
At user’s level, only a very few procedures have to be known in order to obtain the LS
transformation matrices or to transform some atomic or conﬁguration states. Table 1 displays
a short list of the main commands. Owing to the rapid increase of the complexity of many
expressions, however, a (much) larger number of procedures had to be implemented at a
lower level of the program. Many of them make use of previous development such as the
routines for obtaining reduced coeﬃcients of fractional parentage or for evaluating recoupling
matrices. Since all transformation coeﬃcients are evaluated directly to their numerical (i.e.
either algebraic or ﬂoating–point) values, no additional data structures needed to be deﬁned
for the present work.

−

The explicit expression (14) of a transformation matrix for two open shells showed that these
coeﬃcients are always reduced to the transformation of individual subshell states

lN αLS J

*

| 



−
N −
ν

−
κ

−
J,

+
N +
ν

+
J

+
κ

J

.

+





These matrix elements are stored internally in the program using the format

[Q, L, S, J big, N 1, Q 1, J big 1, Q 2, J big 2, factor, nom, denom]

for l = 1, 2 and

[w, Q, L, S, J big, N 1, Q 1, J big 1, Q 2, J big 2, factor, nom, denom]

for l = 3, as their recursive computation (from the matrix elements of the corresponding
parents states) was found too slow for practical purposes. In this representation, the value
nom
of each LS
denom ; they are kept
for all occupation numbers N = 1, ..., 2l + 1.

jj transformation matrix elements is given by f actor

−

×

q

With the increased size of the Racah program, a new program structure became necessary.
Following recent suggestions by the Maple standard, therefore, the program is now divided
into the two modules Racah and Jucys which must be loaded separately by the with()
feature of Maple. While the Racah module now contains all procedures for the set–up
and manipulation of Racah expression [6, 8], the standard quantities from Ref. [7] and the

12

−

present implementation of the LS
jj transformation matrices are incorporated into the
module Jucys. Of course, the use of modules also helps to keep all low–level procedures
invisible to the user. The Racah package is distributed as a tar (-xvf) ﬁle Racah2002.tar
which, apart of the source code and module libraries in diﬀerent Maple versions, includes
a Read.me for the installation of the program as well as the document Racah-commands.ps.
This document provides the deﬁnition of all data structures of the Racah program as well
as an alphabetic list of all user relevant commands. The code can be down–loaded also
from our home page via the world–wide–web (http://www.physik.uni-kassel/fritzsche). For
most commands, moreover, there are on–line help pages available which are distributed and
maintained together with the code.

4 Examples

−

A few examples from atomic shell theory are displayed below to illustrate the application of
jj transformation matrices from section 2. Beside of the computation of a particular
the LS
jj
matrix elements, we brieﬂy explain how, for instance, the user can generate a (full) LS
transformation matrix for a half–ﬁlled f
shell, i.e. the subspace which is spanned by the
subshell states. We also show explicitly how, for C2+ ions, the two low–lying
f 7 wνLS
1s22s2p J = 1 levels from a (jj
coupled) multiconﬁguration Dirac–Fock calculation can be
(cid:12)
(cid:12)
easily transformed into a more appropriate LS

coupled basis.

−

−

−

(cid:11)

Let us start with the (numerical) evaluation of the LS

jj transformation matrix element2

for a partially ﬁlled f

−
N = 3, w = 1, ν = 3, L = 7, S = 1/2, and

f 3 (w = 1, ν = 3) 2J15/2 |
D
shell, i.e. for the two (sub–) shell states with quantum numbers l = 3,
+
N = 3,

+
J= 15/2, respectively.

+
j = 7/2,

+
ν= 3,

E

Since

−
N = 0 in this case, no

subshell state occurs in the notation. For these

quantum numbers, we obtain the transformation coeﬃcient simply by typing

−
J

−
ν

(cid:29)

f 0
5/2
(cid:12)
(cid:12)
(cid:12)
(cid:12)

> Racah set coupling(LS);
> T := Racah matrix LS jj(shell LS(3,3,1,3,7,1/2),

−

−
+
f 3
ν = 3) 15/2
7/2 (

shell jj(-4,3,3,15/2));

T := .586845597 .

As previously, the same result can be obtained also in algebraic or prime–number repre-
sentations if the proper keywords algebraic or prime are added to the parameter list.
In
prime–number notation, for instance, the transformation coeﬃcient

> T := Racah matrix LS jj(shell LS(3,3,1,3,7,1/2),

shell jj(-4,3,3,15/2),prime );

2The capital J on the left–hand side denotes the spectroscopic notation for the orbital angular momentum

L = 7 and should not be confused with the total angular momentum of this shell state.

13

T := [1, -3, 3, 1, -2]

is returned as a list of (the ﬁrst few non–zero) integer powers

[a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11] .

of the prime numbers p1 = 2, p2 = 3, p3 = 5, p4 = 7, p5 = 11, p6 = 13, p7 = 17, p8 = 19,
p9 = 23, p10 = 29, p11 = 31 from which the actual values is obtained as

1
2

.

a0

11

 

Yi=1

p ai
i

!

3
2×7

3×5
2 ≈

q

−

That is, the result [1, -3, 3, 1, -2] is just equivalent to the value

0.586845597.

Several tabulations have been published over the years [5, 16, 17] to the LS

jj transformation

matrices

lN αLS J

*

−
N −
ν

−
J,

−
κ
(

+
N +
ν

+
κ

+
J)J

+

for diﬀerent — partially ﬁlled — shells and using

(cid:12)
(cid:12)
(cid:12)

diﬀerent phase conventions. With the present extension to the Racah package, we now
provide a much simpler access to these transformation matrices which can be adopted to the
actual requirements of the user. As a second example, therefore, we display how one can
3) within only a few lines of Maple code.
create an ’electronic table’ (for any shell with l
Figure 1 shows the necessary code for a half–ﬁlled f 7 shell which can easily be modiﬁed and
extended for other shells as well. The printout from this example is shown below in the Test
Run Output.

≤

We now extent our examples to the transformation of conﬁguration state functions or even
atomic states as they frequently appear in standard (relativistic) computations. To deal with
a simple case, let us consider the two lowest 1s22s2p J = 1 levels of C2+ ions which attracted
a lot of recent interest in the diagnostics of stellar atmospheres [13], In a single–conﬁguration
approximation, these two levels are written in terms of only two jj

coupled CSF

|
where α = 1, 2, and the conﬁguration states

Ψαi

= a1(α)

γ1 J = 1
i
|

+ a2(α)

−
γ2 J = 1
i
|

γ1 J = 1
i
|
γ2 J = 1
i
|

=

=

2s1
(cid:16)
(2s1

1/2 (ν = 1) 1/2; 2p1
1/2 (ν = 1) 1/2; 2p1

1/2 (ν = 1) 1/2
(cid:17)

J = 1

E

3/2 (ν = 1) 3/2) J = 1
E
and p

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

are derived from the coupling of the two valence electrons in an open s
shell, respec-
tively. In this notation, we omit the 1s2 core since it does not take part in the coupling of the
shells or in according transformations. The mixing coeﬃcients
in Eq. (18) can be
obtained from either a multiconﬁguration Dirac–Fock (MCDF) or conﬁguration interaction
calculation. By using, for instance, the well–known Grasp92 code [10], we ﬁnd for the two
J = 1 levels the expansions

ai (α)
}
{

−

−

|

Ψ1i
Ψ2i
|

= 0.8170

γ1 J = 1
i
|
γ1 J = 1
0.5767
i
|

+ 0.5767

γ2 J = 1
i
|
γ2 J = 1
+ 0.8170
i

|

−

=

.

14

(17)

(18)

(19)

(20)

N := 7;

Racah_set_coupling(LS);
l := 3;
kappa_1 := 3;
for J from 1/2 to (N*l)+1/2 do
for i from 1 to nops(t1) do

kappa_2 := -4;

j1 := 5/2;

j2 := 7/2;

Racah_set_coupling_scheme(LS_quasispin);
t1 := Racah_subshell_term_LS(l,Q_int);
Racah_set_coupling_scheme(jj_quasispin);
lprint("J=",J);

if abs(t1[i][4]-t1[i][5])<=J and J<=t1[i][4]-t1[i][5] and type(J+t1[i][4]+t1[i][5],integer) then

s1 := shell_LS(l, N, t1[i][2], 2*l+1-2*t1[i][3], t1[i][4], t1[i][5], check);
lprint(Racah_shell_print(s1));
for N1 from 0 to N do

N2 := N-N1;

M2 := (N2-(2*j2+1)/2)/2;

M1 := (N1-(2*j1+1)/2)/2;
if type(M1,integer) then

t2 := Racah_subshell_term_jj(j1,Q_int);

t3 := Racah_subshell_term_jj(j2,Q_int);

t2 := Racah_subshell_term_jj(j1,Q_halfint);

t3 := Racah_subshell_term_jj(j2,Q_halfint);

elif not type(M1,integer) then

fi;
for i_1 from 1 to nops(t2) do

if abs(M1) <= t2[i_1][3] then

s2 := shell_jj(kappa_1, N1, (2*j1+1)/2-2*t2[i_1][3], t2[i_1][4]);
for i_2 from 1 to nops(t3) do
<=

if abs(M2)

t3[i_2][3]

then

if abs(t2[i_1][4] - t3[i_2][4]) <= J

and
s3 := shell_jj(kappa_2, N2, (2*j2+1)/2-2*t3[i_2][3], t3[i_2][4], check);
result := Racah_matrix_LS_jj(s1,s2,s3,J,prime);
lprint(Racah_shell_print(s2),Racah_shell_print(s3),result);

J <= t2[i_1][4] + t3[i_2][4]

then

end if;

end if;

end do;

end if;

end do;

end do;

end if;

end do;

end do;

Figure 1: Generation of the LS
beginning of this table is shown in the Test Run Output below.

−

jj transformation matrix for a half–ﬁlled f 7 shell. The

which clearly illustrate that a (pure) jj
example.

−

coupling scheme is inappropriate for the present

A (much) more appropriate representation might be obtained in LS
coupling. However,
−
before we transform the two atomic states
into such a representation, we ﬁrst show
. The quantum numbers
the transformation of a single conﬁguration state, say,
of this state can be read oﬀ directly from its deﬁnition in (19). In the Racah program, we
may enter this CSF as

γ1 J = 1
i
|

Ψ1,2i
|

> CSF 1 := csf jj(shell jj(-1,1,1,1/2),shell jj(1,1,1,1/2),1,check);

CSF_l = csf_jj(shell_jj(-1,1,1,1/2),shell_jj(1,1,1,1/2),1)

where use is made of the two auxiliarity procedures csf jj() and shell jj(). These proce-
dures return the input (basically) unevaluated but help facilitate the communication with and
within the program (see Appendix B for further details about these commands). By deﬁn-
subshell states, we obtain the (complete)
ing ﬁrst (again) the coupling sequence for the LS
expansion of the CSF

by

−

γ1 J = 1
i
|

> Racah set coupling(LS );
> Racah transform csf("jj->LS",CSF 1,print ):

".5773502693 * |(s^1 nu=1, ^2S; p^1 nu=1, ^2P) ^2P_1 >"
".8164965809 * |(s^1 nu=1, ^2S; p^1 nu=1, ^2P) ^3P_1 >"

15

where, in spectroscopic notation, the ﬁrst lines represents the 1P1 (L = 1, S = 0, J = 1) and
the second the 3P1 component. In the last input line, the keyword print causes the procedure
to ’print’ the result (and to return a null expression) while, otherwise, the same result is
returned in a list structure [csf1(), c1, csf2(), c2, ...], as suitable for further manipulations.

Having a simple access to the transformation of conﬁguration states, we are now prepared
of the two J = 1
to transform also the (full) atomic states. For the wave functions
levels, this is simply achieved (as before) by assigning the CSF
from (19) also to
some variable CSF 2 and by carrying out the transformation explicitly:

Ψ1,2i
|
γ2 J = 1
i
|

> CSF 2 := csf jj(shell jj(-1,1,1,1/2),shell jj(-2,1,1,3/2),1);
> Racah transform asf("jj->LS",CSF 1,0.8170,CSF 2,0.5767, print ):

".9426 * |(s^1 nu=1, ^2S; p^1 nu=1, ^2P) ^1P_1 >"
".3341 * |(s^1 nu=1, ^2S; p^1 nu=1, ^2P) ^3P_1 >"

and

> Racah transform asf("jj->LS",CSF 1,-0.5767,CSF 2,0.8170, print ):

" .3341 * |(s^1 nu=1, ^2S; p^1 nu=1, ^2P) ^1P_1 >"
"-.9426 * |(s^1 nu=1, ^2S; p^1 nu=1, ^2P) ^3P_1 >" .

represents the 3P1 level.
Apparently, while the ground state level
Again, the print ﬂag is used and ensures that the results are printed to screen and are not
returned in terms of a list structure.

is a 1P1 level,

Ψ2i
|

Ψ1i
|

The command Racah transform asf() provides a very ﬂexible access to the transformation of
atomic states; any number of CSF along with their corresponding mixing coeﬃcients ai can
appear in the parameter list. Moreover, the same syntax applies for this procedure if an
atomic state is given in LS

coupling,

−

Φαi

|

=

ai(α)

γi LSJ
|

i

,

Xi

(21)

−

−

and should be transformed into jj
coupling. With just two minor diﬀerences: The string
"LS->jj" has to be used, instead, and the CSFi in the parameter list must represent proper
LS
coupled conﬁguration state functions. Although the program is currently limited to two
open shells, of course, the same syntax could be used for more complex shell structures or if
other coupling schemes are to be incorporated into the program. Moreover, the construction
of the CSF from the successive coupling of subshell states will help tackle more enhanced
tasks in the future, such as the computation of angular coeﬃcients for (non–scalar) tensorial
operators of rank K.

16

5 Evaluation of transformation matrices

We now return to the evaluation of the transformation coeﬃcients (11) from section 2 which
we could easily write down in this bra–ket notation. However, to carry out any transformation
of conﬁguration or atomic states explicitly, these matrix elements must be simpliﬁed to a
computationally suitable form. This is achieved by the recoupling of the angular momenta
which, in a number of steps, enables us to bring them into an equal sequence on the left– and
right–hand side of the transformation matrix (11). Therefore, any transformation matrix can
always be expressed in terms of several recoupling coeﬃcients and an appropriate number of
transformation matrices (7), i.e.

lN αLS J

*

| 



−
N −
ν

−
κ

−
J,

+
N +
ν

+
J

+
κ

J

,

+





where a single matrix occurs for each open shell in the construction of the symmetry–adapted
functions.

−

jj transformations and the standard order (10) of the jj

coupled subshell states,
For LS
two steps are required for the recoupling of the angular momenta. The ﬁrst step (i) arise
from the recoupling of the total subshell orbital angular momenta Li and spins Si

−

((((L1, L2)L12, L3)L123, ...)L, (((S1, S2)S12, S3)S123, ...)S) J

h

|

((((L1, S1)J1, (L2, S2)J2)J12, (L3, S3)J3) J123...) J

,

(22)

i

in order to obtain the total subshell angular momenta Ji. In the second step, then, (ii) these
total angular momenta are brought into their standard order (10) by

−
J 1,

+
J 1)J1, (

−
J 2,

+
J 2)J2)J12, (

−
J 3,

((((

+
J 3)J3 )J123, ... ) J

|

(cid:28)

−
J 1,

+
J 1)J1,

−

J 2, )J ′

12,

+
J 2)J12,

−

J 3 )J ′

123,

((((

+
J 3)J123, ... ) J

.

(23)

(cid:29)
coupled CSF are not

Further steps in the recoupling of angular momenta may arise if the jj
deﬁned in standard order (10) or if more elaborate coupling schemes occur.

−

Recoupling coeﬃcients of type (22) and (23) can be evaluated by means of the Racah
program [9]. In the following, we demonstrate this recent progress with the simpliﬁcation of
these coeﬃcients for conﬁguration states with two open shells in LS
(lN1
1 α1L1S1, lN2
((L1, L2)L, (S1, S2)S)J

. In this case, the ﬁrst recoupling coeﬃcient (22) simpliﬁes to

and is evaluated interactively by

((L1, S1)J1, (L2, S2)J2)J

2 α2L2S2)LS J

(cid:12)
(cid:12)
h
(cid:12)
> rcc 1 := Racah set(recoupling(‘<((L1,L2)L,(S1,S2)S)J|

coupling

−

E

i

|

((L1,S1)J1,(L2,S2)J2)J>‘)):

> rcc 1 := Racah evaluate(rcc 1):
> Racah print(rcc 1):

17

--->

(-2 Ll + 2 S2 + 2 S1 + 2 L2 + 2 J)

(-1)

√2J2 + 1√2J1 + 1√2S + 1√2L + 1

w9j(L2,L1,L,J2,J1,J,S2,S1,S)

which can be re–written as

((L1, L2)L, (S1, S2)S)J

((L1, S1)J1, (L2, S2)J2)J

h

|

=

[J1, J2, L, S] 


q

i

L1 S1 J1
L2 S2 J2
J
S
L






j symbols and the fact that 2J + 2 mJ can be
by using the symmetries of the Wigner 9
added without any change in the overall phase of the expression. Using similar lines, we can
evaluate the second coeﬃcient (23) for the given case of four open (jj
coupled) subshells
((Jm1, Jp1) J1, (Jm2, Jp2)J2) J

(((Jm1, Jp1) J1, Jm2)J ′

in expression (13)

12, Jp2) J

−

−

h
> rcc 2 := Racah set(recoupling(‘<((Jm1,Jp1)J1,(Jm2,Jp2)J2)J|

i

|



(((Jm1,Jp1)J1,Jm2)J12 p,Jp2)J>‘)):

(24)

> rcc 2 := Racah evaluate(rcc 2):
> Racah print(rcc 2):

--->

(-1)

(-Jp2 + 2 mJ_ - J1 + 2 Jm1 + 2 Jp1 - J - Jm2 + 2 J2)

√2J12 p + 1√2J2 + 1

triangle(J1,Jm1,Jp1)
w6j(J,J1,J2,Jm2,Jp2,J12_p)

which leads to the result

((Jm1, Jp1)J1, (Jm2, Jp2)J2)J

(((Jm1, Jp1)J1, Jm2)J ′

12, Jp2)J

(cid:10)

= (

1)Jm2+Jp2+J1+J

[J2, J ′

12]

−

q

J1
Jp2

(cid:26)

Jm2 J ′
(cid:11)
12
J2 (cid:27)
J

.

(25)

When we combine the two expression (24) and (25), we arrive at the expression (14) for the
transformation matrix of conﬁguration states with two (open) shells in LS
coupling; their
complete expansion in terms of a jj

coupled basis can be written

−

|

−

1 α1L1S1, l N2
(l N1

2 α2L2S2)LS J

(cid:12)
(cid:12)
(cid:12)

=

N1− N2− J1J2J ′
12

−
−
X
J 1
ν 1

+
ν 1

+
J 1

−
ν 2

−
J 2

+
ν 2

+
J 2 p

E

18

[J1, J2, L, S] 


L1 S1 J1
L2 S2 J2
J
S
L








−
J 2+

+
J 2+J1+J

[J2, J ′

12, L, S]

1)

(
−

×

q

J1
+
J 2




−
J 2 J ′
12

J

J2

−
N 1

−
κ
(

1

−
ν 1

−
J 1,

+
κ

1

(N1−

+
N 1)

+
ν 1

+
J 1)J


lN1
1 α1L1S1 J1

−
N 2

−
κ
(

2

−
ν 2

−
J 2,

+
κ

2

(N2−

+
N 2)

+
ν 2

+
J 2)J

lN2
2 α2L2S2 J2

|

|






+

+

× *

× *

× (cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

−
N 1

−
κ

1

(((

−
ν 1

−
J 1,

+
N 1

+
κ

1

+
ν 1

+
J 1)J1,

−
N 2

−
κ

2

−

−
ν 2

J 2)J ′

12,

+
κ

2

+
ν 2

+
J 2)J

+
N 2

+

(26)

if a summation is carried out over all

intermediate angular momenta in

or vice versa,
coupling.
LS

−

6 Summary and outlook

−

−

−

A set of additional commands to the Racah program now facilitates the transformation
coupling
of symmetry–adapted functions with quite diﬀerent complexity from jj
to LS
and vice versa. For such transformations, all partially ﬁlled (sub–) shells with l
3 (i.e.
electrons) are supported and, hence, the program extends the previously available
up to f
tabulations and implementations considerably. In the study of atomic spectra, for example,
the new version of the Racah program may help identify atomic and ionic levels as obtained
coupling. Apart from the analysis of the valence–shell
from relativistic calculations in jj
spectra, a reliable classiﬁcation of the level structure is crucial, in particular, for the study of
inner–shell processes, where the creation of additional vacancies often gives rise to a large (or
even huge) number of possible states; in practise, however, only a very few levels are typically
involved in some process but need ﬁrst to be recognized, of course. The present extension to
the Racah program can help to implement such transformations also directly into available
atomic code, a project which is currently under work for the Ratip package [11].

≤

−

With the implementation of rather abstract data structure such as shell and conﬁguration
states [cf. the auxiliarity procedures shell LS(), csf LS(), ...], we also provide a pow-
erful notation for more advanced tasks. For open–shell atoms and ions, for instance, a long–
standing problem concerns the computation of the angular coeﬃcients for eﬀective n
particle
operators as they occur in many–body perturbation theory. Here, the given notation for shell
and conﬁguration states can help decompose general matrix elements automatically. Another
task concerns the optimal classiﬁcation of atomic levels to assist the interpretation of atomic
data and to improve the data base on energy levels and transition probabilities for the large
user community of atomic data. For this aim, further coupling schemes need to be imple-
mented in the future.

−

Acknowledgement: We like to thank T. Inghoﬀ for valuable suggestions and for help with
the installation of the code.

19

Appendix A: Recurrence relations for the subshell transforma-
tion coeﬃcients

−
N −
ν

−
J ,

−
κ
(

+
N +
ν

+
κ

+
J)J

+

*

The transformation coeﬃcients

l N αLS J

between the (sub–)shell

(cid:12)
states from diﬀerent coupling schemes are the building blocks for all transformations. For a
(cid:12)
(cid:12)
given single–shell conﬁguration of N equivalent electrons (lN ), these matrices can be expressed
recursively in terms of the transformation matrices for N
1 equivalent electrons, i.e. in terms
of the transformation of the corresponding parent states. The recurrence relations for the
subshell transformation coeﬃcients therefore include the coeﬃcients of fractional parentage
l N αLS

and a proper recoupling of the angular momenta

−

l N −1 (α′L′S′) l
(cid:13)
(cid:13)
(cid:13)

+

−
N −
ν

−
J,

N +
ν

+
κ

−
κ
(

(cid:17)
+
J)J

(cid:16)

lN αLS J

|

*

+

=

[L, S] /N

lN αLS

lN −1 (α′L′S′) l

[J ′]

p

α′L′S′
X

(cid:0)

−
N [j−,

−
J]

(cid:13)
(cid:13)

L
l
s
S
j− J

L′
S′
J ′







′

′−
X−
ν
J

J ′
(cid:1) X

−
J −

+
J+J ′

1)j−+

(
−

+
J

′

−
J

(

j− J

J ′
−
J )

r

× 



×  

−
N−1)
j(
−

′


′−
−
ν
(
J

) j−


−
ν

−
J

−
N −
j
−

lN −1 α′L′S′ J ′

|

! *

−
N −1)−
ν

′ −
J

′

,

(

−
κ
(

+

N +
ν

+
J )J ′

+
κ

+

+
N [j−,

+
J]

+

r

(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)

L
l
s
S
j+ J

L′
S′
J ′







′
′ +
X+
J
ν

−
J +

′
+
J

+J

1)j++

(
−

J ′
J

(

−
J
j+

J ′
+
J )

+
N −1)
j(
+


+
ν
(

′

′+
J

)j+


+
ν

+
J

+
N
j
+

×  

′
l(N −1) α

′

L

S

′

′

J

|

! *

−
N −
ν

−
J,

−
κ
(

+

′

(

N −1)+
ν

′ +
J

+
κ

′

) J

. (27)

(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)

(cid:29)

1
4

They can be applied to the transformation of any subshell state by starting from

−
κ
(

−
ν

−
J,

+
κ

+
ν

+
J) J

l 2 αLS J

|

(cid:28)

=

1
√2

1 + (

1)L+S

−

(cid:0)

(cid:1) p

[j−, j+, L, S]

(28)

L
l
l
s
S
s
j− j+ J

and

l 2 αLS J

(cid:28)

±
κ

2±
ν J

|

(cid:29)

=

1 + (

1)L+S

1 + (

1)J

[j±]

L, S]

−

−

(cid:0)

(cid:1) (cid:0)

(cid:1)

p

L
l
l
s
S
s
j± j± J

.

(29)

In the present work, the recurrence relations (27) have been utilized to generate the trans-
formation matrices for all partially ﬁlled shells with l
electrons, and for
occupation numbers N = 1, 2, ..., 2l + 1. In this process, we made use of the coeﬃcients
of fractional parentage
in
coupling, which were implemented earlier into the Racah package [7]. To keep the (cur-
jj
rent) transformation of the symmetry–adapted functions feasible in time, these coeﬃcients

lN −1 (α′L′S′) l
(cid:13)
(cid:13)
(cid:13)

jN −1 (ν′J ′)j
(cid:16)

3, i.e. up to f

in LSJ– and

lN αLS

jN νJ

(cid:13)
(cid:13)
(cid:13)

−

≤

−

(cid:16)

(cid:17)

(cid:17)











+












20

are stored internally in the program [cf. section 4]. For all occupation numbers larger than
2l + 1, i.e. N = 2l + 2, ..., 4l + 1, we make use of the symmetry relation [18]

l N ανLS J

|

*

−
N −
ν

−
J,

−
κ
(

+
N +
ν

+
κ

+
J) J

+

= (

1)(ν−

−

−
ν −

+
ν )/2

*

l 4l+2−N ανLS J

−
κ

|

(2j− +1−

−
N ) −
ν

−
J,

+
κ

(2j+ +1−

+
N ) +
ν

+
J) J

.

(30)

+

which is easily derived from the following two properties of the coeﬃcients of fractional
parentage [cf. Eq. (15) in Ref. [19] and Eq. (9) in Ref. [20]]

l 4l+1−N (α′ν′L′S′)l

l 4l+2−N ανLS

(cid:16)

=

(cid:13)
(cid:13)
1)S+S′+L+L′−l− 1
(cid:13)

(cid:17)
2 (ν+ν′−1)

2 + 1

(
−

(N + 1)(2L′ + 1)(2S′ + 1)

× (cid:18)

(4l + 2

N )(2L + 1)(2S + 1)

−

1
2

(cid:19)

(cid:16)

l N (α′ν′L′S′)l

(31)

l N +1 ανLS
(cid:13)
(cid:13)
(cid:13)

(cid:17)

and

(cid:16)

j2j−N (ν′J ′)j

j2j+1−N νJ

(cid:13)
(cid:13)
(cid:13)
1)J+J ′−j+ 1

(cid:17)
2 (ν+ν′−1)

= (

−

(N + 1)(2J ′ + 1)

(2j + 1

N )(2J + 1)

(cid:18)

−

1
2

(cid:19)

jN (ν′J ′)j
(cid:16)

.

(32)

jN +1 νJ
(cid:13)
(cid:13)
(cid:13)

(cid:17)

For further details about the properties of the cfp coeﬃcients and the subshell transformation
matrices (7), see Refs. [19, 20] and Ref. [5], respectively.

Appendix B: New commands for the Racah package

The commands of the present extension to the Racah program can be described fairly
independent from previous parts. Below, we brieﬂy explain those procedures which have
been added and which are of interest for an interactive use of the LS
jj transformation
matrices. This provides a short description of the input and output of the procedures to
facilitate also the understanding of our examples in sections 4 and 5; as previously, we follow
the style of the former Maple Handbook [14]. A more detailed description of all the presently
available commands of the Racah package (at user’s level) is distributed with the source
code in the ﬁle Racah-commands.ps.

−

As introduced earlier in the text, the terms of a subshell state and a conﬁguration state
function play a key role in the transformation of (coupled) states and the evaluation of
matrix elements for open shells. They form the basic entities in dealing with such tasks
and are often used to describe the input and output of (many) commands. To facilitate the
handling of these ’atomic states’ (i.e. the communication with and among the procedures of
the Racah program), we ﬁrst introduce a number of auxiliarity procedures for these coupled

21

−

−

and jj

states in LS
coupling. Although several tests are made on the particular input
of these procedures, they basically return unevaluated and, thus, serve mainly for keeping
necessary information together. As seen from their names and list of parameters, these
auxiliarity procedures are designed so that further coupling schemes can be easily added
later as according requirements arise. Since these procedures frequently occur during input
and output and no actual manipulation is made, also no preﬁx Racah has been added.

Presently, procedures for the notation of shell–states and (atomic) CSF are provided in jj
and LS

coupling.

−

B.1 Auxiliarity procedures

−

csf jj(shell jj)

•

Auxiliarity procedure to represent a conﬁguration state function which is built from a
single jj
or

coupled subshell state

nκ N νJ

κ N νJ

.

−

Output: An unevaluated call to csf jj(shell jj) is returned.

(cid:12)
(cid:12)
(cid:12)

E

(cid:12)
(cid:12)
(cid:12)

E

(κ N1
(cid:12)
(cid:12)
(cid:12)

Argument options: (shell jj,check ) to check, in addition, that the given quantum num-
bers in shell jj() give rise to a valid jj
−
(shell jj1,shell jj2,J) to represent a conﬁguration state function (CSF) of two jj
subshell states

coupled subshell state with j = 1/2, . . . , 7/2.

♣
coupled

1 ν1J1, n2κ N2

1 ν1J1, κ N2

2 ν2J2)J

2 ν2J2)J

(n1κ N1

or

−

.

E

3 ν3J3)J

1 ν1J1, n2κ N2

coupled subshell states

♣
three jj
−
((n1κ N1

(shell jj1,shell jj2,J12,shell jj3,J) to represent a conﬁguration state function (CSF) of
(cid:12)
E
(cid:12)
(cid:12)
1 ν1J1, κ N2
((κ N1
(cid:12)
3 ν3J3)J
(cid:12)
(cid:12)

2 ν2J2)J12, n3κ N3

2 ν2J2)J12, κ N3

−
2 ν2J2)J12, κ N3

(shell jj1,shell jj2,J12,shell jj3,J123,shell jj4,J) to represent a conﬁguration state func-
E
coupled subshell states
3 ν3J3)J123, κ N4

(cid:12)
(cid:12)
♣
(cid:12)
tion (CSF) of four jj
(((κ N1
1 ν1J1, κ N2
(cid:12)
(((n1κ N1
(cid:12)
(cid:12)
Additional information: All (given) quantum numbers in the parameter list must
(cid:12)
(cid:12)
(cid:12)
evaluate to proper integers or half–integers.

3 ν3J3)J123, n4κ N4
E
4 ν4J4)J

2 ν2J2)J12, n3κ N3

1 ν1J1, n2κ N2

4 ν4J4)J

or

or

E

E

.

.

See also: csf LS(), shell jj(), Racah csf print().

csf LS(shell LS,J)

•

Auxiliarity procedure to represent a conﬁguration state function which is built from a
single LS

coupled subshell state

nl N νLSJ

.

−

E
Output: An unevaluated call to csf LS(shell LS,J) is returned.

E

l N νLSJ
(cid:12)
(cid:12)
(cid:12)
(shell LS,J,check ) to check,

or

(cid:12)
(cid:12)
(cid:12)

Argument options:
tum numbers in shell LS() and J give rise to a valid LSJ
with l = 0, . . . , 3.
function (CSF) of two LS
1 ν1L1S1, n2l N2
(n1l N1

in addition, that the given quan-
coupled subshell state
(shell LS1,shell LS2,L,S,J) to represent a conﬁguration state
1 ν1L1S1, l N2
(l N1
or
(cid:12)
(cid:12)
(cid:12)

−
2 ν2L2S2)LSJ

coupled subshell states

2 ν2L2S2)LSJ

−

♣

E

.

(cid:12)
(cid:12)
(cid:12)

E

22

Additional information: All (given) quantum numbers in the parameter list must
evaluate to proper integers or half–integers.

See also: csf jj(), shell LS(), Racah csf print().

shell jj(kappa,N,nu,J)

•

Auxiliarity procedure to represent a jj
j = 1/2, . . . , 7/2.

κ N νJ
(cid:12)
(cid:12)
(cid:12)
Output: An unevaluated call to shell jj(kappa,N,nu,J) is returned.

coupled subshell state

−

E

for

Argument options: ([n,kappa],N,nu,J) to represent a jj
nκ N νJ
♣
numbers give rise to a valid jj
(cid:12)
(cid:12)
(cid:12)
proper error message if this is not the case.

(kappa,N,nu,J,check ) to check, in addition, that the given quantum
coupled subshell state; the program terminates with an

coupled subshell state

−

−

E

.

♣
1/2.

Additional information: All quantum numbers (except of n) must evaluate to proper
The relativistic angular momentum quantum number κ =
integers or half–integers.
The principal quantum number n is often not required for
(j +1/2) for l = j
±
the transformation of subshell states but enters the notation, if diﬀerent subshell states
are coupled to each other or, in particular, in the evaluation of (most physical) matrix
For
elements.
N
1/2 is formally allowed in
order to facilitate the input for several procedures from Appendix B.2.

All occupation numbers must be in the range N = 0, . . . , (2j + 1).

0, an (unphysical) subshell angular momentum j =

−

±

≡

♣

♣

♣

See also: csf jj(), shell LS(), Racah shell print(), Racah tabulate().

shell LS(l,N,nu,L,S)

•

Auxiliarity procedure to represent a LS
l = 0, . . . , 2.

−

coupled subshell state

l N νLS

for

(cid:12)
(cid:12)
(cid:12)

E

Output: An unevaluated call to shell LS(l,N,nu,L,S) is returned.

Argument options: (l,N,w,nu,L,S) to represent a LS
l N wνLS

for l = 3 and the additional quantum number w = 0, . . . , 10.

coupled subshell state

−

E

or

([n,l],N,nu,L,S) or ([n,l],N,w,nu,L,S) to represent the LS

coupled subshell states
(cid:12)
(cid:12)
♣
(cid:12)
nl N νLS
(l,N,nu,L,S,check ) to check, in addition,
coupled subshell state with
that the given quantum numbers give rise to a valid LS
(cid:12)
(cid:12)
(cid:12)
l = 0, . . . , 2; the program terminates with an proper error message if this is not the
case.

nl N wνLS
(cid:12)
(cid:12)
(cid:12)

, respectively.

−

−

♣

E

E

Additional information: All quantum numbers (except of n) must evaluate to proper
integers or half–integers.
The principal quantum number n is often not required for
the transformation of subshell states but enters the notation, if diﬀerent subshell states
are coupled to each other or, in particular, in the evaluation of (most physical) matrix
elements.

All occupation numbers must be in the range N = 0, . . . , 2(2l + 1).

♣

♣

See also: csf LS(), shell jj(), Racah shell print(), Racah tabulate().

23

B.2 Commands for LS

jj transformations

−

This Appendix lists the commands for the transformation of coupled (subshell and conﬁgu-
ration) states where we utilize the (auxiliarity) notation from the previous part. This enables
us with a very compact but still ﬂexible notation for the input and output of the individual
procedures; for example, a notation like ...,shell LSa,shell LSb,... means that the user
may type explicitly ...,shell LS(la,Na,nua,La,Sa),shell LS(lb,Nb,nub,Lb,Sb),... in
the parameter list or ﬁrst assign these (unevaluated) calls to shell LS() to any variables, say
wa, wb, and later only use these variables at input time: ...,wa,wb,.... To ’extract’ the
quantum numbers from these unevaluated calls, the command Racah tabulate() is used.

Racah csf print(csf jj)

•

...(’κ1ˆN1, nu1, J1’; ’κ2ˆN2, nu2, J2’) J12; ...>” to facilitate
Returns a string of type ”
|
coupled CSF. The value of κi is printed in spectroscopic notation
the printout of jj
; if, moreover, the principal quantum number n is given, a
such as d 3/2, f 7/2, ...
string like 3d 5/2ˆ2, ... is returned.

−

Output: A string is returned.

(csf LS) to return ”
...(’l1ˆN1, nu1, ˆ2S1+1, L1’;
|

l2ˆN2, nu2,
Argument options:
ˆ2S2+1, L2’) L12, S12;
...>”. The values of li and Li are printed in spectroscopic
notation such as s, p, d, ... and S, P, D, ..., respectively. For f
electrons (li = 3), the
...(l1ˆN1, (w1) nu1,
additional quantum number wi is printed in parenthesis such as ”
|
ˆ2S1+1, L1; l2ˆN2, (w2) nu2, ˆ2S2+1, L2) L12, S12; ...>”.

−

See also: csf LS(), csf jj() and Racah shell print().

Racah matrix LS jj(shell LS,shell jj−,shell jj+,J)

•

Returns the LS

jj transformation matrix

−

subshells with l = 0, . . . , 3 and the according

l N νLSJ

*
−
κ = l and

(cid:12)
+
(cid:12)
κ =
(cid:12)

Output: A (ﬂoating–point) number is returned.

−
N −
ν

−
J,

−
κ
(

+
N +
ν

+
κ

+
J)J

for all

+

(l + 1).

−

Argument options: (shell LS,shell jj−,shell jj+,J,algebraic) to return the same element
of the LS

jj transformation matrix but in algebraic form.

(shell LS,shell jj−,shell jj+,J,prime) to return the same element of the LS

jj trans-

♣
formation matrix but in prime–number representation.

−

−

(shell LS1,shell LS2,L,S,shell jj1−,shell jj1+,J1,shell jj2−,J12,shell jj2+,J) to return

♣

24

the LS

jj transformation matrix

−

(l N1
1 ν1L1S1, l N2

2 ν2L2S2)LSJ

−
N 1

+
N 1

−
ν 1

−
J 1,

+
κ

1

−
κ

1

(((

−
N 2

+
ν 1

+
J 1)J1,

−
κ

2

−
ν 2

−
J 2)J12,

+
N 2

+
κ

2

+
ν 2

+
J 2)J

(cid:12)
(cid:12)
(cid:12)

*
Additional information: The subshell angular momenta and occupation numbers are
1/2
not independent of each other; they must fulﬁll the relation l = j− + 1/2 = j+ −
+
N ; the program terminates with an proper error message if this is not
and N =
If the principal quantum number n is given, it must be the same for all (sub–
the case.
) shells.
For two and more coupled subshell states, these relations and condition must
hold for each group of subshell states on the lhs and rhs of the transformation matrix.

−
N +

+

♣

♣

−
N = 0 and

For l = 0 follows

−
κ = 0; such (unphysical) subshell states are formally
♣
allowed in the Racah program but can also be omitted from the list of parameters
+
κ can be omitted from the
above.

The subshell shell jj− with

♣

list of parameters above if
representation, see Racah calculate prime().

−
N = 0 or

−
κ or shell jj+ with
+
N = 0.

♣

For details about the prime–number

See also: Racah set coupling().

Racah set coupling(LS )

•

•

Deﬁnes the use of LS
coupling for the
Output: A null expression is returned.

−

(cid:12)
(cid:12)
(cid:12)

E

Argument options: (SL) to deﬁnes the use of SL
states.

−

l N νLS

subshell states.

coupling for the

l N νSL

subshell

(cid:12)
(cid:12)
(cid:12)

E

Additional information: The information about the current coupling scheme for the
LS subshell states is kept in the global variable Racah save coupling LS; its default value
If the coupling scheme of the subshell states is to be
is Racah save coupling LS=LS.
changes, this procedure must be called before any transformation is made.

♣

See also: Racah set coupling scheme().

Racah shell print(shell jj)

Returns a string ”κ, ˆN, nu, J” to facilitate the printout of jj
The value of κi is printed in spectroscopic notation such as d 3/2, f 7/2, ...
moreover, the principal quantum number n is given, a string like 3d 5/2ˆ2,
returned.

coupled subshell states.
if,
is

;
...

−

Output: A string is returned.

Argument options: (shell jj,state) to return ”
(shell LS) to return
κ, ˆN, nu, J>”.
|
”lˆN, nu, ˆ2S+1, L” or ”lˆN, w, nu, ˆ2S+1, L”. The values of l and L are printed in
(shell LS,state)
spectroscopic notation such as s, p, d, ... and S, P, D, ..., respectively.
lˆN, w, nu, ˆ2S+1, L>”.
lˆN, nu, ˆ2S+1, L>” or ”
to return ”
|
|

♣

♣

Additional information: These strings facilitate the line–mode printout of (coupled)
subshell states and CSF.

25

See also: shell LS(), shell jj() and Racah csf print().

Racah tabulate(shell jj)

•

•

Return a table with all deﬁned quantum numbers of a jj

coupled subshell state.

−

Output: A table T with entries T[n], T[kappa], T[N], T[nu], and T[J] is returned.

Argument options: (shell LS) to return a table T with all deﬁned quantum numbers of
coupled shell state; it has the entries T[n], T[l], T[N], T[w], T[nu], T[L],
a LS
−
and T[S].

Additional information: If some quantum numbers such as the orbital quantum num-
ber l is not deﬁned, fail is returned for the corresponding entry.

See also: shell jj(), shell LS().

Racah transform asf(”jj–>LS”,csf jj1,a1,csf jj2,a2,...)

Expands an atomic state function, which is represented in a jj

coupled CSF basis

−

into a basis of LS

coupled CSF, i.e.

−

Ψαi
|

=

CSF (jj)
k

a (jj)
k

(α) ,

Xk (cid:12)
(cid:12)
(cid:12)

Xi

(cid:12)
(cid:12)
(cid:12)

E

E

Ψαi
|

=

CSF (LS)
i

c (LS)
i

.

Output: A list [ [csf LS1,c1], [csf LS2,c2], ...]
LS

coupled CSF and ci the corresponding mixing coeﬃcient in the expansion.

is returned where csf LS i describes a

−

Argument options: (”jj–>LS”,csf jj1,a1,csf jj2,a2,...,algebraic) to return the mixing co-
(”jj–>LS”,csf jj1,a1,csf jj2,a2,...,print) to print the expan-
eﬃcients in algebraic form.
CSF (LS)
, and a null expression is
sion in line mode. One line is printed per term ci ∗
i
(”LS–>jj”,csf LS1,a1,csf LS2,a2,...) to expand an atomic state
returned in this case.
function, which is represented in a LS

coupled CSF basis

♣

♣

(cid:12)
(cid:12)
(cid:12)

E

into a basis of jj

coupled CSF, i.e.

−

Φαi
|

=

−
CSF (LS)
k

E

Xk (cid:12)
(cid:12)
(cid:12)

a (LS)
k

(α) ,

Φαi
|

=

c (jj)
i

.

CSF (jj)
i
(cid:12)
(cid:12)
(cid:12)

E

Xi

Additional information: The subshell states of all jj
subshells with j = l
in standard order, i.e. if both jj
always couple like

−

−
±

coupled CSF must be provided
1/2 occur in a CSF, they must

−
N −
ν

−
J,

+
κ

+
N +
ν

+
J)J

−
κ
(

26

if they represent the ﬁrst two subshells, and

−
N −
ν

−
κ

−
J)J,

+
κ

+
N +
ν

+
J)J ′...)

((...,

♣

coupled CSF basis, the subshell states also
otherwise.
For any expansion into a jj
−
appear in standard order in the output.
If the principal quantum number(s) n are
♣
given, they are transfered properly to the output but must be the same for each group of
For the use of a SL
subshell states in the expansion of the CSF.
coupled CSF basis,
−
♣
−
+
κ can be omitted from the arguments of
κ or
see Racah set coupling().

The subshell

csf jj if

−
N = 0 or

+
N = 0.

♣

See also: csf jj(), csf LS(), shell jj(), shell LS().

Racah transform csf(”jj–>LS”,csf jj)

•

Expands a jj

coupled CSF into a basis of LS

coupled CSF

−

−
CSF (LS)
i

ci .

E

CSF (jj)

=

(cid:12)
(cid:12)
(cid:12)
Output: A list [ [csf LS1,c1], [csf LS2,c2], ...]
LS

(cid:12)
(cid:12)
(cid:12)

E

Xi

−

is returned where csf LS i describes a

coupled CSF and ci the corresponding mixing coeﬃcient in the expansion.

Argument options: (”jj–>LS”,csf jj,algebraic) to return the mixing coeﬃcients in al-
(”jj–>LS”,csf jj,print) to print the expansion in line mode. One line
gebraic form.
, and a null expression is returned in this case.
is printed per term ci ∗
coupled CSF
♣
CSF (LS)

(”LS–>jj”,csf LS) to expand a LS

coupled CSF into a basis of jj

CSF (LS)
i

−

−

=

♣

E

ci .

E

P

(cid:12)
E
Additional information: The subshell states of all jj
(cid:12)
(cid:12)
in standard order, i.e. if both jj
subshells with j = l
always couple like

−

−
±

coupled CSF must be provided
1/2 occur in a CSF, they must

i

(cid:12)
(cid:12)
CSF (jj)
(cid:12)
i
(cid:12)
(cid:12)
(cid:12)

if they represent the ﬁrst two subshells, and

−
N −
ν

−
J,

+
κ

+
N +
ν

+
J)J

−
κ
(

−
N −
ν

−
κ

−
J)J,

+
κ

+
N +
ν

+
J)J ′...)

((...,

otherwise where
basis, the subshell states also appear in standard order in the output.

For any expansion into a jj

(l + 1).

−

♣

−

−
κ = l and

+
κ =

coupled CSF

If the principal quantum number(s) n are given, they are transfered properly to the
♣
output but must be the same for each group of subshell states in the expansion of
The
the CSF.
♣
−
κ or

+
κ can be omitted from the argument of the csf jj if

coupled CSF basis, see Racah set coupling().

For the use of a SL

−
N = 0 or

♣
+
N = 0.

subshell

−

See also: csf jj(), csf LS(), shell jj(), shell LS().

27

•

•

Racah transform csf jj LS(csf jj)

Expands a single jj

coupled CSF into a basis of LS

coupled CSF

−

CSF (jj)

=

−
CSF (LS)
i

ci .

E

(cid:12)
(cid:12)
(cid:12)
Output: A list [ [csf LS1,c1], [csf LS2,c2], ...]
LS

(cid:12)
(cid:12)
(cid:12)

E

Xi

−

coupled CSF and ci the corresponding mixing coeﬃcient in the expansion.

Argument options: (csf jj,algebraic) to return the mixing coeﬃcients in algebraic form.

is returned where csf LSi describes a

See also: csf jj(), csf LS(), shell jj(), shell LS(), Racah set coupling(),
Racah transform csf().

Racah transform csf LS jj(csf LS)

Expands a single LS

coupled CSF into a basis of jj

coupled CSF

−

CSF (LS)

=

(cid:12)
(cid:12)
(cid:12)

E

Xi

(cid:12)
(cid:12)
(cid:12)

−
CSF (jj)
i

ci .

E

[csf jj1,c1],

[csf jj2,c2],

...]

is returned where csf jji describes a

coupled CSF and ci the corresponding mixing coeﬃcient in the expansion.

Output: A list [
jj

−

Argument options: (csf LS,algebraic) to return the mixing coeﬃcients in algebraic
form.

See also: csf jj(), csf LS(), shell jj(), shell LS(), Racah set coupling(),
Racah transform csf().

References

1997).

(2003).

[1] H. M. S. Blackford and A. Hibbert, At. Data Nucl. Data Tables 58, 101 (1994).

[2] R. D. Cowan, The Theory of Atomic Structure and Spectra (University of California

Press, Brekeley and Los Angels, 1981).

[3] Z. B. Rudzikas, Theoretical Atomic Spectroscopy (Cambrige University Press, Cambrige,

[4] K. G. Dyall, Comp. Phys. Commun. 39, 141 (1986).

[5] G. Gaigalas, T. Zalandauskas and Z. Rudzikas, At. Data Nucl. Data Tables, 84, 99

[6] S. Fritzsche, Comp. Phys. Commun. 103, 51 (1997); S. Fritzsche, S. Varga, D. Geschke

and B. Fricke, Comp. Phys. Commun. 111, 167 (1998).

28

[7] G. Gaigalas, S. Fritzsche B. Fricke, Comp. Phys. Commun. 135, 219 (2001).

[8] T. Inghoﬀ, S. Fritzsche and B. Fricke, Comp. Phys. Commun. 139, 297 (2001).

[9] S. Fritzsche, T. Inghoﬀ, T. Bastug and B. Fricke, Comp. Phys. Commun. 139, 314

(2001).

(2001).

157 (2000).

[10] F.A. Parpia, C.F. Fischer and I.P. Grant, Comp. Phys. Commun. 94, 249 (1996).

[11] S. Fritzsche, J. Electr. Spec. Rel. Phenom. 114–116, 1155 (2001).

[12] G. Gaigalas, T. Zalandauskas and Z. Rudzikas, Lithuanian Journal of Physics 41, 226

[13] Y. H. Le Teuﬀ, T. J. Millar, and A. J. Markwick, Astron. Astrophys. Suppl. Ser. 146,

[14] D. Redfern, The Maple Handbook (Springer, New York, Berlin, a.o., 1996).

[15] W. C. Martin and W. L. Wiese, in Atomic, Molecular & Optical Physics Handbook, ed.

G. W. F. Drake (AIP Press, New York, 1996), p. 135.

[16] J. B. Calvert and E. R. Tuttle, Il Nuovo Cimento 54 B, 413 (1979).

[17] W. J. Childs, At. Data Nucl. Data Tables 67, 1 (1997).

[18] K. G. Dyall and I. P. Grant, J. Phys. B 15, L371 (1982).

[19] G. Gaigalas, Z. Rudzikas and C. Froese Fischer, At. Data Nucl. Data Tables 70, 1

(1998).

[20] G. Gaigalas, S. Fritzsche and Z. Rudzikas, At. Data Nucl. Data Tables 76, 235 (2000).

29

TEST RUN OUTPUT

> Racah_LS_jj_calculate_table();

"LS-jj transformation matrices for f subshells with occupation N=7"
"J=", 1/2
"f^7, (w=0) nu=5, ^6F"
"f_5/2^1 nu=1, 5/2", "f_7/2^6 nu=2, 2", [1, 2, 1, 0, -3]
"f_5/2^2 nu=2, 2", "f_7/2^5 nu=3, 3/2", [-1, 4, 1, -1, -4]
"f_5/2^2 nu=2, 2", "f_7/2^5 nu=3, 5/2", [-1, 0, 0, -1, -3, 1]
"f_5/2^2 nu=2, 4", "f_7/2^5 nu=1, 7/2", [1, 3, 0, 1, -3]
"f_5/2^2 nu=2, 4", "f_7/2^5 nu=3, 9/2", [-1, 0, 0, 0, -4, 1, 1]
"f_5/2^3 nu=1, 5/2", "f_7/2^4 nu=2, 2", [0]
"f_5/2^3 nu=1, 5/2", "f_7/2^4 nu=4, 2", [1, 0, 1, 0, -3, 1]
"f_5/2^3 nu=3, 3/2", "f_7/2^4 nu=2, 2", [1, 1, 1, 0, -4]
"f_5/2^3 nu=3, 3/2", "f_7/2^4 nu=4, 2", [0]
"f_5/2^3 nu=3, 9/2", "f_7/2^4 nu=2, 4", [1, 2, 0, 2, -4, 1]
"f_5/2^3 nu=3, 9/2", "f_7/2^4 nu=4, 4", [0]
"f_5/2^3 nu=3, 9/2", "f_7/2^4 nu=4, 5", [0]
"f_5/2^4 nu=2, 2", "f_7/2^3 nu=3, 3/2", [-1, 4, 1, -1, -4]
"f_5/2^4 nu=2, 2", "f_7/2^3 nu=3, 5/2", [-1, 0, 0, -1, -3, 1]
"f_5/2^4 nu=2, 4", "f_7/2^3 nu=1, 7/2", [-1, 3, 0, 1, -3]
"f_5/2^4 nu=2, 4", "f_7/2^3 nu=3, 9/2", [-1, 0, 0, 0, -4, 1, 1]
"f_5/2^5 nu=1, 5/2", "f_7/2^2 nu=2, 2", [-1, 2, 1, 0, -3]
.
.

30

