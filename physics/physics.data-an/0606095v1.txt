Comparison Tests of Variable-Stepsize Algorithms for Stochastic

Ordinary Diﬀerential Equations of Finance

Yin Mei Wong1 and Joshua Wilkie2

1 Innovative Stochastic Algorithms, Vancouver,

British Columbia V6E 2C8, Canada

2 Department of Chemistry, Simon Fraser University,

Burnaby, British Columbia V5A 1S6, Canada

(Dated: July 28, 2013)

Abstract

Since the introduction of the Black-Scholes model stochastic processes have played an increasingly

important role in mathematical ﬁnance.

In many cases prices, volatility and other quantities

can be modeled using stochastic ordinary diﬀerential equations. Available methods for solving

such equations have until recently been markedly inferior to analogous methods for deterministic

ordinary diﬀerential equations. Recently, a number of methods which employ variable stepsizes to

control local error have been developed which appear to oﬀer greatly improved speed and accuracy.

Here we conduct a comparative study of the performance of these algorithms for problems taken

from the mathematical ﬁnance literature.

6
0
0
2
 
n
u
J
 
1
1
 
 
]
n
a
-
a
t
a
d
.
s
c
i
s
y
h
p
[
 
 
1
v
5
9
0
6
0
6
0
/
s
c
i
s
y
h
p
:
v
i
X
r
a

1

I.

INTRODUCTION

Stochastic processes play an increasingly important role in mathematical ﬁnance as ev-

idenced by the large and growing literature on stochastic volatility models[1, 2, 3, 4, 5,

6, 7, 8, 9, 10, 11, 12]. Often these theories are expressed in terms of stochastic ordinary

diﬀerential equations (SODEs). Examples include the Cox-Ingersoll-Ross[1, 2, 3], Hull-

White[4, 5, 6], Log Ornstein-Uhlenbeck[7], Nelson[8], Aﬃne[11] and Log-linear[12] models

of stochastic volatility. Other schemes like ARCH models[8, 13] use discrete time diﬀer-

ence equations which can be viewed as approximations to diﬀusions[8], and which are often

favored for computational and other reasons. SODE based models tend to have closer rela-

tionships to fundamental theory, but have the drawback that analytic solutions are rarely

known. In general these equations must be solved using numerical approximation schemes.

Numerical methods for SODEs have a long history[14] but until recently these algo-

rithms have not achieved the speed and accuracy characteristic of analogous methods for

deterministic ordinary diﬀerential equations (ODEs)[15]. This is partly due to the lack of

variable-stepsize algorithms which allow for the control of local error, and partly due to a

lack of suﬃciently high order algorithms. The MAPLE Stochastic Package[16], for example,

fails to include variable-stepsize routines and most methods are of rather low order. Poten-

tial solutions to both of these problems have been reported in the last few years. Discussions

of variable stepsize strategies for SODEs[17, 18] and some basic observations regarding Tay-

lor expansions for SODEs[19] have led to the emergence of a number of published[20] and

unpublished[21] variable-stepsize codes. These algorithms also have a number of promising

additional features such as linear scaling of computational cost with numbers of Wiener

processes.

In this manuscript we perform a variety of tests to see whether the algorithms give the

expected improved performance and accuracy. We refer to the method developed by Wilkie

and C¸ etinba¸s[19, 20] as SDE9, and the unpublished commercial method[21] as ANISE. We

will not attempt to discuss how these codes work but merely focus on their performance.

We do not consider other variable-stepsize codes such as the weak method introduced in

Ref. [20] since they have restricted domains of applicability.

2

The methods SDE9 and ANISE when applied to an Itˆo stochastic diﬀerential equation

for an observable Xt with Wiener processes Wit require knowledge of the partial derivatives

of the solutions, i.e.,

dXt = a(Xt, t)dt +

bi(Xt, t)dWit

m

Xi=1

∂Xt
∂Wit
∂Xt
∂t

= bi(Xt, t)

= a(Xt, t)

m

1
2

−

Xi=1

∂bi(Xt, t)
∂Wit

.

All of the problems we consider are formulated with Itˆo stochastic diﬀerential equations and

we provide these derivatives for each problem. ANISE and SDE9 are more easily applied to

Stratonovich stochastic diﬀerential equations

dXt = a(Xt, t)dt +

bi(Xt, t)

dWit

◦

m

Xi=1

for which

(1)

(2)

(3)

(4)

(5)

(6)

∂Xt
∂Wit
∂Xt
∂t

= bi(Xt, t)

= a(Xt, t).

Extensions to jump diﬀusions[12] are also straightforward, but are not considered here.

Our study shows that both SDE9 and ANISE yield accurate solutions to a wide variety

of stochastic volatility models. ANISE tends to be about twice as fast as SDE9. For one

problem we ﬁnd that ANISE performs hundreds of times faster than SDE9. Both methods

provide a means of obtaining high accuracy solutions to SODE problems, and may prove to

be useful quantitative tools for further research in mathematical ﬁnance.

In section II we explore Monte-Carlo convergence of numerically calculated means and

variances of price and volatilities for seven stochastic volatility models taken from the ﬁnance

literature. Section III examines the accuracies of the algorithms for individual trajectories.

II. MONTE-CARLO CONVERGENCE TESTS

Here our goal is to test the accuracy and compare computational performance for the

ANISE and SDE9 numerical methods for SODEs discussed in the introduction. To do this

3

we compare exact and numerically calculated average quantities like mean price and mean

volatility for a selection of models from the ﬁnance literature.

For each model we compare known exact average quantities Xt to the numerical av-

erages X approx. = 1
N

N

j=1 X (j)

t

computed from individual stochastic evolutions X (j)

for

t

j = 1, . . . , N, obtained using the SODE methods. We examine convergence to the ex-

P

act solution by varying the number of trajectories N. For each observable Xt we calculate

the base ten log of the mean relative error,

|}
and plot this against time. This speciﬁc denominator, max

{|

|

|

log10[

Xt

|
max

−
Xt

X approx.
,

t
|
X approx.

t

],

(7)

Xt

,

|

|

{|

X approx.

t

|}

, is chosen since

some observables Xt pass through zero and relative error can therefore blow up. We also

examine the relative CPU times for the two methods. All calculations were performed on a
600 MHz Alpha processor with a requested tolerance of 10−12.

A. Nelson Model

In the Nelson model[8] the log-price Pt and volatility Vt obey

dPt =

VtdW1t

q

dVt = θ(ω

Vt)dt + √2λθVtdW2t,

−

where the normally distributed real stochastic diﬀerentials are uncorrelated and have dWit =

0 and dW 2

it = dt. Thus, this model has two Wiener processes and two equations.

The derivatives required by the SODE methods are given in Table I. We employed a time

step dt = .1 and integrated to 100. As with ODE methods, the intermediate steps taken in

Xt

Pt

Vt

∂Xt
∂t

0

θ(ω

Vt)

λθVt

−

−

∂Xt
∂W1t

√Vt

∂Xt
∂W2t

0

0

√2λθ Vt

TABLE I: Derivatives for Nelson Model.

ANISE and SDE9 do not necessarily reﬂect certain aspects of the true solutions such as the

positivity of Vt. To avoid ﬂoating point problems one thus programs

Vt

rather than √Vt.

q|

|

4

The actual solutions returned for Vt will of course satisfy positivity as we will see in section

III where we explore the accuracy of individual trajectories.

We explored convergence for the average quantities Pt, var(Pt), Vt, and var(Vt). The

known exact solutions for these quantities are given by

Pt = P0

var(Pt) = ωt +

ω

V0

−
θ

(e−θt

1)

−
e−θt)
ω2

var(Vt) = V 2

Vt = V0e−θt + ω(1
−
0 e−2θ(1−λ)t +
2ω(ω
1

−
2λ

1
(e−θt

V0)

−

−

(1

e−2θ(1−λ)t)

λ
−
e−2θ(1−λ)t)

−

−

2.

Vt

−

(8)

(9)

(10)

(11)

We chose parameters θ = .035, ω = .636, λ = .296, and set initial price and volatility to

P0 = .5 and V0 = .029.

In Fig. 1 we plot the log base ten mean relative error in mean price Pt against time for

ANISE (in part (a)) and SDE9 (in part (b)). Results are shown for 105 (dashed curve), 106

(dot-dashed curve) and 107 (solid curve) trajectories. Convergence with increasing numbers

of trajectories is good in both cases. For ten million trajectories the averages have a relative

accuracy of about one part in a thousand. Errors this small are not visible in plots and

so we do not show the actual solutions. The requirement of millions to tens of millions

of trajectories for full convergence is typical of systems of SODEs with white noises, since

Monte Carlo error bounds scale as the inverse square root of the number of trajectories.

Figure 1 also shows plots of the log base ten mean relative error in variance of price

var(Pt) against time for ANISE (in part (c)) and SDE9 (in part (d)). Here the convergence

is slightly better than that for mean price.

In Fig. 2 we show plots of the log base ten mean relative errors in the mean and variance

of the volatility Vt. Here the variance has larger error than the mean. Again ANISE and

SDE9 show similar rates of convergence.

The CPU times for various numbers of trajectories are shown in Table II. ANISE takes

about 7 seconds to compute 1000 trajectories. The SDE9 calculations take about 60%

longer. This table also shows that both methods scale well with the number of trajectories.

In other words there are no rare problematic trajectories.

5

 20

 40

 60

 80

 100

 20

 40

 60

 80

 100

’NelmnP_e5.a’
’NelmnP_e6.a’
’NelmnP_e7.a’

’NelmnP_e5.s’
’NelmnP_e6.s’
’NelmnP_e7.s’

(a) Error in Pt vs. t for ANISE.

(b) Error in Pt vs. t for SDE9.

-5

 0

-1

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

 0

t

t

-5

 0

-1

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

 0

t

t

 20

 40

 60

 80

 100

 20

 40

 60

 80

 100

’NelvarP_e5.a’
’NelvarP_e6.a’
’NelvarP_e7.a’

’NelvarP_e5.s’
’NelvarP_e6.s’
’NelvarP_e7.s’

(c) Error in var(Pt) vs. t for ANISE.

(d) Error in var(Pt) vs. t for SDE9.

FIG. 1: Error in mean and variance of Pt for Nelson model.

B. Hull-White Model

For the Hull-White model[4, 5, 6] the log-price Pt and volatility Vt obey SODEs

VtdW1t

dPt =

q
dVt = (θ

λVt)dt + γdW2t.

−

Thus, we again have two equations and two Wiener processes.

The derivatives needed by the numerical methods are given in Table III. A time step of

dt = .1 was used and the equations were integrated to 100. Once again care must be taken

to program

Vt

rather than √Vt.

q|

|

We explored convergence for the average quantities Pt, var(Pt), Vt, and var(Vt). The

6

 20

 40

 60

 80

 100

 20

 40

 60

 80

 100

’NelmnV_e5.a’
’NelmnV_e6.a’
’NelmnV_e7.a’

’NelmnV_e5.s’
’NelmnV_e6.s’
’NelmnV_e7.s’

(a) Error in Vt vs. t for ANISE.

(b) Error in Vt vs. t for SDE9.

-6

 0

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

-1

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

 0

t

t

-6

 0

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

-1

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

 0

t

t

 20

 40

 60

 80

 100

 20

 40

 60

 80

 100

’NelvarV_e5.a’
’NelvarV_e6.a’
’NelvarV_e7.a’

’NelvarV_e5.s’
’NelvarV_e6.s’
’NelvarV_e7.s’

(c) Error in var(Vt) vs. t for ANISE.

(d) Error in var(Vt) vs. t for SDE9.

FIG. 2: Error in mean and variance of Vt for Nelson model.

exact solutions for these observables are given by

var(Pt) =

(1

Pt = P0
V0
λ
−
Vt = V0e−λt +
γ2
2λ

(1

−

e−λt) +

(1

θ
λ
e−2λt)

−

var(Vt) =

θ
λ2 (λt + e−λt
e−λt)

1)

−

(12)

(13)

(14)

(15)

for this model.

P0 = .5.

We set parameters θ = .03, λ = .035, γ = .0068, and initial conditions V0 = .029 and

In Fig. 3 we plot the log base ten error in the mean and variance of Pt for ANISE ((a) and

7

# Trajectories

ANISE CPU Time

SDE9 CPU Time

CPU Time Ratio SDE9/ANISE

103

104

105

106

107

0.69E+01

0.68E+02

0.68E+03

0.68E+04

0.68E+05

0.11E+02

0.11E+03

0.11E+04

0.11E+05

0.11E+06

1.59

1.62

1.63

1.62

1.62

TABLE II: CPU times for Nelson Model in seconds.

Xt

Pt

Vt

∂Xt
∂t

0

λVt

θ

−

∂Xt
∂W1t

√Vt

0

∂Xt
∂W2t

0

γ

TABLE III: Derivatives for Hull-White Model.

(c), respectively) and for SDE9 ((b) and (d), respectively). Dotted curves show the results

for 105 trajectories while dot-dashed and solid curves are for 106 and 107 trajectories, re-

spectively. Good convergence with numbers of trajectories is seen. Once again, convergence

for the variance is slightly better than that for the mean.

Figure 4 shows the log base ten error in the mean and variance of the volatility Vt for

ANISE ((a) and (c), respectively) and for SDE9 ((b) and (d), respectively). Again good

convergence to the exact results is observed. The errors in the variance are larger than those

in the mean.

Cpu times are compared in Table IV for various numbers of trajectories. ANISE takes

7.5 s to compute 1000 trajectories. Again we observe that SDE9 takes 50 % longer. Once

again good scaling is obtained for both methods with the number of trajectories.

C. Cox-Ingersoll-Ross Model

The SODEs for the Cox-Ingersoll-Ross model[2] are

dPt = (αdt +

VtdW1t)Pt

q
Vt)dt + σ

dVt = κ(θ

−

Vt [ρdW1t +

1
q

−

ρ2dW2t]

(16)

(17)

q

8

 20

 40

 60

 80

 100

 20

 40

 60

 80

 100

’HW_mnP_e5.a’
’HW_mnP_e6.a’
’HW_mnP_e7.a’

’HW_mnP_e5.s’
’HW_mnP_e6.s’
’HW_mnP_e7.s’

(a) Error in Pt vs. t for ANISE.

(b) Error in Pt vs. t for SDE9.

-5

 0

-1

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

-6

 0

t

t

-5

 0

-1

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

-6

 0

t

t

 20

 40

 60

 80

 100

 20

 40

 60

 80

 100

’HW_varP_e5.a’
’HW_varP_e6.a’
’HW_varP_e7.a’

’HW_varP_e5.s’
’HW_varP_e6.s’
’HW_varP_e7.s’

(c) Error in var(Pt) vs. t for ANISE.

(d) Error in var(Pt) vs. t for SDE9.

FIG. 3: Error in mean and variance of Pt for Hull-White model.

and so we have two equations with two Wiener processes. In this case the volatility depends

on both Wiener processes.

The derivatives needed by the numerical methods are provided in Table V. A time step

of dt = .01 was used and the equations were integrated to 10.

We look for convergence in four observables; mean log-price ln Pt, variance in log-price

var(ln Pt), mean volatility Vt, and variance of the volatility var(Vt). The exact solutions for

these quantities are given by

ln Pt = ln P0 + (α

)t +

θ
2
σ
4κ

−

−

1
(V0 −
2κ
σ
(V0 −
κ

θ)(e−κt

1)

−
σ
2κ

θ)(ρ

−

)]t +

)te−κt

σθ
κ

(ρ

−

var(ln Pt) = [θ

(18)

9

 20

 40

 60

 80

 100

 20

 40

 60

 80

 100

’HW_mnV_e5.a’
’HW_mnV_e6.a’
’HW_mnV_e7.a’

’HW_mnV_e5.s’
’HW_mnV_e6.s’
’HW_mnV_e7.s’

(a) Error in Vt vs. t for ANISE.

(b) Error in Vt vs. t for SDE9.

-7

 0

-3

-3.5

-4

-4.5

-5

-5.5

-6

-6.5

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

-6

 0

t

t

-7

 0

-3

-3.5

-4

-4.5

-5

-5.5

-6

-6.5

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

-6

 0

t

t

 20

 40

 60

 80

 100

 20

 40

 60

 80

 100

’HW_varV_e5.a’
’HW_varV_e6.a’
’HW_varV_e7.a’

’HW_varV_e5.s’
’HW_varV_e6.s’
’HW_varV_e7.s’

(c) Error in var(Vt) vs. t for ANISE.

(d) Error in var(Vt) vs. t for SDE9.

FIG. 4: Error in mean and variance of Vt for Hull-White model.

σ
2κ

)

−

θ(ρ

σ
4κ

)]

−

θ

V0 −
κ

}

−

(e−κt

1)

−

+

σ
κ2 [(V0 −
{
σ2
θ
4κ3 (V0 −
2
Vt = V0e−κt + θ(1
V0σ2
κ

(e−κt

−

−

θ)(ρ

−
)(e−κt

1)2

−
e−κt)

−
e−2κt) +

var(Vt) =

θσ2
2κ

(1

−

e−κt)2

(19)

(20)

(21)

The parameters were set to α = .1, κ = .29368, θ = .07935, σ = .11425, ρ =

.2 and price

−

and volatility was set to initial values P0 = 1 and V0 = .1.

In Fig. 5 we show the log base ten error in ln Pt and var(ln Pt) plotted against time for

ANISE ((a) and (c)) and SDE9 ((b) and (d)). Dashed, dot-dashed and solid curves represent

errors for runs of 105, 106 and 107 trajectories, respectively. Good convergence is seen for

10

103

104

105

106

107

103

104

105

106

107

# Trajectories

ANISE CPU Time

SDE9 CPU Time

CPU Time Ratio SDE9/ANISE

0.76E+01

0.76E+02

0.76E+03

0.76E+04

0.76E+05

0.11E+02

0.11E+03

0.11E+04

0.11E+05

0.11E+06

TABLE IV: CPU times for Hull-White in seconds.

Xt

Pt

Vt

∂Xt
∂t

[α

1

2 (Vt + 1
Vt)

2 σρ)]Pt
1
4 σ2

−
κ(θ

−

−

∂Xt
∂W1t

Pt√Vt

σρ√Vt

∂Xt
∂W2t

0

σ

1
p

−

ρ2√Vt

TABLE V: Derivatives for Cox-Ingersoll-Ross Model.

both methods at all times, although errors in the variance are larger than those in the mean.

Figure 6 plots errors in Vt and var(Vt). Again we see excellent convergence in both cases.

Errors in the variance are bigger than those in the mean.

The cpu times for various numbers of trajectories are shown in Table VI. ANISE takes

less than 5 s to compute 1000 trajectories. The ratio of cpu time for SDE9 to that of ANISE

is now a much larger 2.5. This relative slowing down of SDE9 is probably caused by the fact

that Vt now depends on two Wiener processes. Once again the ratio is independent of the

number of trajectories indicating that both methods handle all trajectories equally well.

# Trajectories

ANISE CPU Time

SDE9 CPU Time

CPU Time Ratio SDE9/ANISE

0.48E+01

0.48E+02

0.48E+03

0.48E+04

0.48E+05

0.12E+02

0.12E+03

0.12E+04

0.12E+05

0.12E+06

11

TABLE VI: CPU times for Cox-Ingersoll-Ross model in seconds.

1.47

1.44

1.46

1.46

1.46

2.45

2.46

2.46

2.47

2.47

’CIRmnlnP_e5.a’
’CIRmnlnP_e6.a’
’CIRmnlnP_e7.a’

’CIRmnlnP_e5.s’
’CIRmnlnP_e6.s’
’CIRmnlnP_e7.s’

-1

-2

-3

-4

-5

-6

 0

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

 0

t

t

-1

-2

-3

-4

-5

-6

 0

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

 0

t

t

 2

 4

 6

 8

 10

 2

 4

 6

 8

 10

(a) Error in ln Pt vs. t for ANISE.

(b) Error in ln Pt vs. t for SDE9.

’CIRvarlnP_e5.a’
’CIRvarlnP_e6.a’
’CIRvarlnP_e7.a’

’CIRvarlnP_e5.s’
’CIRvarlnP_e6.s’
’CIRvarlnP_e7.s’

 2

 4

 6

 8

 10

 2

 4

 6

 8

 10

(c) Error in var(ln Pt) vs. t for ANISE.

(d) Error in var(ln Pt) vs. t for SDE9.

FIG. 5: Error in mean and variance of ln Pt for Cox-Ingersoll-Ross model.

D. Log-Ornstein-Uhlenbeck Model

The fourth example is the Log Ornstein-Uhlenbeck model[7] for price Pt and volatility

Vt. In this model

dPt = (adt + eVtdW1t)Pt

dVt = (a

bVt)dt +

[ρdW1t +

−

1
q

−

ρ2dW2t]

and so we again have two equations and two Wiener processes. The volatility depends on

both Wiener processes.

The derivatives required by the SODE methods are given in Table VII. A time step of

10−4 was used and the equations were integrated to 0.1.

1
2

12

’CIRmnV_e5.a’
’CIRmnV_e6.a’
’CIRmnV_e7.a’

’CIRmnV_e5.s’
’CIRmnV_e6.s’
’CIRmnV_e7.s’

 2

 4

 6

 8

 10

 2

 4

 6

 8

 10

(a) Error in Vt vs. t for ANISE.

(b) Error in Vt vs. t for SDE9.

-6

 0

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

-6

 0

t

t

-6

 0

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

-6

 0

t

t

 2

 4

 6

 8

 10

 2

 4

 6

 8

 10

’CIRvarV_e5.a’
’CIRvarV_e6.a’
’CIRvarV_e7.a’

’CIRvarV_e5.s’
’CIRvarV_e6.s’
’CIRvarV_e7.s’

(c) Error in var(Vt) vs. t for ANISE.

(d) Error in var(Vt) vs. t for SDE9.

FIG. 6: Error in mean and variance of Vt for Cox-Ingersoll-Ross model.

Xt

Pt

Vt

∂Xt
∂t

aPt

−

1

2 PteVt ( 1
a + bVt

2 ρ + eVt)

∂Xt
∂W1t
eVt Pt

1
2 ρ

∂Xt
∂W2t

0

1
2

1
p

−

ρ2

TABLE VII: Derivatives for Log Ornstein-Uhlenbeck Model.

We look for convergence in three quantities; mean log-price ln Pt, mean volatility Vt, and

variance in volatility var(Vt). Exact solutions for these observables are given by

ln Pt = ln P0 + at
−
a
(1
b

Vt = V0e−bt +

t

1
2 Z
0
e−bt)

−

dt′ exp

2[V0e−bt′

+

{

a
b

(1

−

e−bt′

)] +

1
4b

(1

−

e−2bt′

)

}

(22)

(23)

13

var(Vt) =

1
8b

(1

−

e−2bt)

(24)

The solution for ln Pt was obtained using a variable-stepsize Runge-Kutta code for ODEs[15].

Parameters were set to a = 70, b = 100, ρ = .2 and initial conditions P0 = .5 and V0 = .029

were used.

-1

-2

-3

-4

-5

-6

-7

 0

 0.02

 0.04

 0.06

 0.08

 0.1

 0.02

 0.04

 0.06

 0.08

 0.1

t

t

’LOUmnlnP_e5.a’
’LOUmnlnP_e6.a’
’LOUmnlnP_e7.a’

’LOUmnlnP_e5.s’
’LOUmnlnP_e6.s’
’LOUmnlnP_e7.s’

(a) Error in Pt vs. t for ANISE.

(b) Error in Pt vs. t for SDE9.

FIG. 7: Error in mean of ln Pt for Log-Ornstein-Uhlenbeck model.

In Fig. 7 we plot the log base ten relative error in ln Pt for ANISE in (a) and SDE9 in

(b). Errors are shown for averages over 105 (dashed curve), 106 (dot-dashed curve) and 107

(solid curve) trajectories. In all cases a spike in error is seen near the time t = .01 where the

exact ln Pt passes through zero. The absolute error is small and so the spike in relative error

indicated in the plots is essentially ﬁctitious and convergence is in fact good at all times for

both methods.

Figure 8 plots the mean relative error in the mean and variance of the volatility for ANISE

((a) and (c), respectively) and SDE9 ((b) and (d), respectively). The error in the variance is

larger than that in the mean. Here we see good convergence for both methods at all times.

The cpu times for various numbers of trajectories are shown in Table VIII. ANISE takes

about 5 s to compute 1000 trajectories. The ratio of cpu time of SDE9 to ANISE is again

larger than two. The ratio is roughly independent of the number of trajectories.

-1

-2

-3

-4

-5

-6

-7

 0

14

 0.02

 0.04

 0.06

 0.08

 0.1

 0.02

 0.04

 0.06

 0.08

 0.1

’LOUmnV_e5.a’
’LOUmnV_e6.a’
’LOUmnV_e7.a’

’LOUmnV_e5.s’
’LOUmnV_e6.s’
’LOUmnV_e7.s’

(a) Error in Vt vs. t for ANISE.

(b) Error in Vt vs. t for SDE9.

-7

 0

-3

-3.5

-4

-4.5

-5

-5.5

-6

-6.5

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

-6

 0

t

t

-7

 0

-3

-3.5

-4

-4.5

-5

-5.5

-6

-6.5

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

-6

 0

t

t

 0.02

 0.04

 0.06

 0.08

 0.1

 0.02

 0.04

 0.06

 0.08

 0.1

’LOUvarV_e5.a’
’LOUvarV_e6.a’
’LOUvarV_e7.a’

’LOUvarV_e5.s’
’LOUvarV_e6.s’
’LOUvarV_e7.s’

(c) Error in var(Vt) vs. t for ANISE.

(d) Error in var(Vt) vs. t for SDE9.

FIG. 8: Error in mean and variance of Vt for Log-Ornstein-Uhlenbeck model.

E. Aﬃne Two Volatility Factor Model

The equations for the log-price and volatilities of an aﬃne two volatility model[11, 12]

are

dPt = µdt +

ξ0 + ξ1V1t + ξ2V2t dW3t

q

dV1t = (α10 + α11V1t)dt +

V1t dW1t

dV2t = (α20 + α21V2t)dt +

V2t dW2t

q

q

(25)

(26)

(27)

and so we now have three equations and three Wiener processes.

The derivatives required by the numerical methods are given in Table IX. A time step of

dt = .001 was employed and the equations were integrated to 0.5.

15

# Trajectories

ANISE CPU Time

SDE9 CPU Time

CPU Time Ratio SDE9/ANISE

103

104

105

106

107

0.53E+01

0.52E+02

0.52E+03

0.52E+04

0.52E+05

0.13E+02

0.12E+03

0.12E+04

0.12E+05

0.12E+06

2.46

2.38

2.29

2.28

2.29

TABLE VIII: CPU times for Log-Ornstein-Uhlenbeck model in seconds.

Xt

Pt

∂Xt
∂t

µ

∂Xt
∂W1t

0

V1t α10 + α11V1t

V2t α20 + α21V2t

1
4 √V1t
1
4

0

−

−

∂Xt
∂W2t

0

0

√V2t

√ξ0 −

ξ1V1t

ξ2V2t

−

∂Xt
∂W3t

0

0

TABLE IX: Derivatives for Aﬃne Two Volatility Factor Model.

We examined quantities Pt, var(Pt), V1t, and var(V1t) which have exact solutions given

by

]t +

(V10 +

ξ1
α11

α10
α11

)(eα11t

1)

−

Pt = P0 + µt

var(Pt) = [ξ0 −
+

(V20 +

ξ2
α21
V1t = V10eα11t +

ξ1α10
α11 −
α20
α21
α10
α11

ξ2α20
α21
)(eα21t

1)

−

(eα11t

1)

var(V1t) =

(eα11t

1)2 +

(e2α11t

eα11t).

−

−

α10
2α2
11

−
V10
α11

(28)

(29)

(30)

(31)

The parameters were set as ξ0 = .01, ξ1 = .1258, ξ2 = .0344, µ = .02, α10 = .2894,

α11 = 17.4321, α20 = .0602, α21 = 13.6036, P0 = 1, V10 = .2, and V20 = .2. Note that on

average V1t increases exponentially with a large exponent, and so the noises in the equation

for the price Pt are strongly weighted.

In Fig. 9 we show convergence via the log base ten relative error in the mean and variance

of the price for ANISE ((a) and (c), respectively) and SDE9 (b) and (d), respectively). For

ANISE the plots show three curves corresponding to runs with averages over 105 (dashed

16

 0.05

 0.1

 0.15

 0.2

 0.25

 0.3

 0.35

 0.4

 0.45

 0.5

 0.05

 0.1

 0.15

 0.2

 0.25

 0.3

 0.35

 0.4

 0.45

 0.5

(a) Error in Pt vs. t for ANISE.

(b) Error in Pt vs. t for SDE9.

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

-6

 0

-1

-2

-3

-4

-5

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

-6

 0

-1

-2

-3

-4

-5

’Aff_mnP_e5.a’
’Aff_mnP_e6.a’
’Aff_mnP_e7.a’

’Aff_varP_e5.a’
’Aff_varP_e6.a’
’Aff_varP_e7.a’

t

t

’Aff_mnP_e5.s’
’Aff_mnP_e6.s’

’Aff_varP_e5.s’
’Aff_varP_e6.s’

t

t

 0

 0.05

 0.1

 0.15

 0.2

 0.25

 0.3

 0.35

 0.4

 0.45

 0.5

 0

 0.05

 0.1

 0.15

 0.2

 0.25

 0.3

 0.35

 0.4

 0.45

 0.5

(c) Error in var(Pt) vs. t for ANISE.

(d) Error in var(Pt) vs. t for SDE9.

FIG. 9: Error in mean and variance of Pt for Aﬃne model.

curve), 106 (dot-dashed curve), and 107 (solid curve) trajectories. For SDE9 the plots show

just two curves corresponding to runs with averages over 105 (dashed curve) and 106 (dot-

dashed curve) trajectories. In both cases good convergence is observed toward the exact

solution. The error in the variance is larger than that in the mean. As we discuss below the

relative cpu time for SDE9 is much larger than for previous problems. Indeed, the run with

107 trajectories did not ﬁnish and so does not appear in the ﬁgures.

Figure 10 plots the errors in V1t and var(V1t) against time for ANISE ((a) and (c), respec-

tively) and SDE9 (b) and (d), respectively) for the same numbers of trajectories as in the

previous ﬁgure. Error in the variance is larger than that in the mean. Good convergence is

again observed for both methods.

17

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

 0

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

 0

t

t

 0.05

 0.1

 0.15

 0.2

 0.25

 0.3

 0.35

 0.4

 0.45

 0.5

 0.05

 0.1

 0.15

 0.2

 0.25

 0.3

 0.35

 0.4

 0.45

 0.5

’Aff_mnV_e5.a’
’Aff_mnV_e6.a’
’Aff_mnV_e7.a’

’Aff_mnV_e5.s’
’Aff_mnV_e6.s’

(a) Error in V1t vs. t for ANISE.

(b) Error in V1t vs. t for SDE9.

 0.05

 0.1

 0.15

 0.2

 0.25

 0.3

 0.35

 0.4

 0.45

 0.5

 0.05

 0.1

 0.15

 0.2

 0.25

 0.3

 0.35

 0.4

 0.45

 0.5

’Aff_varV_e5.a’
’Aff_varV_e6.a’
’Aff_varV_e7.a’

’Aff_varV_e5.s’
’Aff_varV_e6.s’

(c) Error in var(V1t) vs. t for ANISE.

(d) Error in var(V1t) vs. t for SDE9.

FIG. 10: Error in mean and variance of V1t for Aﬃne model.

The cpu times for various numbers of trajectories are shown in Table X. ANISE takes

about 3.5 s to compute 1000 trajectories. In spite of the fact that good convergence was

observed for the SDE9 method its computation times show a large jump from the 104

calculation to the 105 calculation. For 105 and 106 ANISE is several hundred times faster

than SDE9. Rare trajectories with diﬃcult stochastic paths appear to be responsible for the

poor performance of SDE9.

t

t

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

 0

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

 0

18

103

104

105

106

107

Xt

Pt

V2t

V3t

# Trajectories

ANISE CPU Time

SDE9 CPU Time

CPU Time Ratio SDE9/ANISE

0.34E+01

0.34E+02

0.34E+03

0.34E+04

0.34E+05

0.10E+02

0.92E+02

0.88E+05

0.13E+07

NA

2.96

2.74

261.61

386.63

NA

TABLE X: CPU times for Aﬃne model in seconds.

F. Log Linear Two Volatility Factor Model Without Feedback

The price and volatilities obey[12]

dPt =

(α10 + α12V2t)dt + eβ10+β13V3t[

{

1
q

ψ2

13dW1t + ψ13dW3t]
}

Pt

−

dV2t = α22V2tdt + dW2t

dV3t = α33V3tdt + dW3t

and so we have three equations and three Wiener processes.

The derivatives needed by the numerical methods are given in Table XI. A time step of

10−4 was used and the equations were integrated to 0.1.

[α10 + α12V2t

−

1
2 β13ψ13Ft]Pt

1
p

−

∂Xt
∂t
1
2 F 2
t −
α22V2t

α33V3t

∂Xt
∂W1t

∂Xt
∂W2t

∂Xt
∂W3t

(ψ13)2 FtPt

ψ13FtPt

0

1

0

0

1

0

0

TABLE XI: Derivatives for Log Linear model without feedback. Here Ft = eβ10+β13V3t.

We calculated ln Pt, V2t, V3t, and var(V3t), some of which have known exact solutions

(32)

(33)

(34)

(35)

(36)

(37)

V2t = V20eα22t

V3t = V30eα33t

var(V3t) =

1
2α33

(e2α33t

1).

−

19

Once again we had to solve an ODE

dln Pt
dt

= α10 + α12V20eα22t

exp

2β10 + 2β13V30eα33t +

(e2α33t

1
2

−

{

β2
13
α33

1)
}

−

(38)

numerically to ﬁnd ln Pt. This was again accomplished using a Runge-Kutta algorithm for

ODEs[15].

The parameters were set as α10 = .0337, α12 = .4820, α22 = 1.0043, α33 = .0291,

β10 = 1.0294, β13 = .0261, ψ13 = .3285, P0 = 1, V20 = .1, V30 = .05.

’LL2Vn_mnlnP_e5.a’
’LL2Vn_mnlnP_e6.a’
’LL2Vn_mnlnP_e7.a’

’LL2Vn_mnlnP_e5.s’
’LL2Vn_mnlnP_e6.s’
’LL2Vn_mnlnP_e7.s’

 0

 0.02

 0.04

 0.06

 0.08

 0.1

 0

 0.02

 0.04

 0.06

 0.08

 0.1

(a) ln Pt vs. t for ANISE

(b) ln Pt vs. t for SDE9

-1

-2

-3

-4

-5

-2

-2.5

-3

-3.5

-4

-4.5

-5

 0

t

t

-1

-2

-3

-4

-5

-2

-2.5

-3

-3.5

-4

-4.5

-5

 0

t

t

 0.02

 0.04

 0.06

 0.08

 0.1

 0.02

 0.04

 0.06

 0.08

 0.1

’LL2Vn_mnU2_e5.a’
’LL2Vn_mnU2_e6.a’
’LL2Vn_mnU2_e7.a’

’LL2Vn_mnU2_e5.s’
’LL2Vn_mnU2_e6.s’
’LL2Vn_mnU2_e7.s’

(c) V2t vs. t for ANISE

(d) V2t vs. t for SDE9

FIG. 11: Means of ln Pt and V2t for Log Linear model without feedback

In Fig. 11 we plot the log base ten relative error in ln Pt and V2t for ANISE ((a) and (c),

respectively) and SDE9 ((b) and (d), respectively). In all cases the dashed curve represents

an average over 105 trajectories while the dot-dashed and solid curves are for 106 and 107

20

trajectories, respectively. Good convergence is seen in all cases except near t = 0 for ln Pt.

The exact solution for ln Pt vanishes at t = 0 for our initial condition, and poor relative

accuracy is seen as a consequence. In fact the absolute accuracy is good at all times for 107

trajectories.

-5

 0

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

 0

t

t

-5

 0

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

 0

t

t

 0.02

 0.04

 0.06

 0.08

 0.1

 0.02

 0.04

 0.06

 0.08

 0.1

’LL2Vn_mnU3_e5.a’
’LL2Vn_mnU3_e6.a’
’LL2Vn_mnU3_e7.a’

’LL2Vn_mnU3_e5.s’
’LL2Vn_mnU3_e6.s’
’LL2Vn_mnU3_e7.s’

(a) V3t vs. t for ANISE

(b) V3t vs. t for SDE9

’LL2Vn_varU3_e5.a’
’LL2Vn_varU3_e6.a’
’LL2Vn_varU3_e7.a’

’LL2Vn_varU3_e5.s’
’LL2Vn_varU3_e6.s’
’LL2Vn_varU3_e7.s’

 0.02

 0.04

 0.06

 0.08

 0.1

 0.02

 0.04

 0.06

 0.08

 0.1

(c) var(V3t) vs. t for ANISE

(d) var(V3t) vs. t for SDE9

FIG. 12: Error in mean and variance of V3t for Log Linear model without feedback

Figure 12 plots the errors in V3t and var(V3t) against time for ANISE and SDE9. Once

again, good convergence is observed. Errors in the mean and variance are comparable.

The cpu times for various numbers of trajectories are shown in Table XII. ANISE takes

6.5 s to compute 1000 trajectories. Once again the ratio of cpu time for SDE9 to that

of ANISE is a little greater than two and this number is independent of the number of

trajectories.

21

# Trajectories

ANISE CPU Time

SDE9 CPU Time

CPU Time Ratio SDE9/ANISE

103

104

105

106

107

0.65E+01

0.64E+02

0.64E+03

0.64E+04

0.64E+05

0.14E+02

0.14E+03

0.14E+04

0.14E+05

0.14E+06

2.11

2.13

2.18

2.18

2.17

TABLE XII: CPU times for Log Linear model without feedback in seconds.

G. Log Linear Two Volatility Factor Model With Feedback

The equations for this model[12] are

dPt =

(α10 + α12V2t)dt

{

+ eβ10+β13V3t+β14V4t[

dV2t = α22V2tdt + dW2t

dV3t = α33V3tdt + (1 + β33V3t)dW3t

dV4t = α44V4tdt + (1 + β44V4t)dW4t.

1
q

ψ2

13 −

ψ2

14dW1t + ψ13dW3t + ψ14dW4t]
}

Pt

−

(39)

(40)

(41)

(42)

In this case we have four equations and four Wiener processes.

The derivatives required by the numerical methods are given in Table XIII. A time step

of dt = 10−4 was employed and the equations were integrated to 0.1.

Xt

Pt

V2t

V3t

V4t

α10 + α12V2t
{
2 [ψ13β13(1 + β33V3t) + 1

1

1
2 F 2
t

−

−

2 ψ14β14(1 + β44V4t)]Ft

Pt
}

∂Xt
∂t

α22V2t

α33V3t

α44V4t

−

−

1
2 β33(1 + β33V3t)
1
2 β44(1 + β44V4t)

∂Xt
∂W1t

ρFtPt

∂Xt
∂W2t

∂Xt
∂W3t

∂Xt
∂W4t

ψ13FtPt

ψ14FtPt

0

0

0

1 + β33V3t

0

0

0

0

1 + β44V4t

0

1

0

0

TABLE XIII: Derivatives for Log Linear model with feedback. Here Ft = eβ10+β13V3t+β14V4t and

ρ =

1
q

−

ψ2

13 −

ψ2

14.

22

We examined quantities ln Pt, V2t, V3t, and var(V3t) some of which have exact solutions

(43)

(44)

(45)

(46)

(47)

V2t = V20eα22t

V3t = V30eα33t
var(V3t) = (V30)2(e(2α33+β2

33)t

+

1
2α33 + β2
33

−
(e(2α33+β2

33)t

1).

−

e2α33t) +

2β33V30
α33 + β2
33

(e(2α33+β2

33)t

eα33t)

−

We obtained ln Pt numerically by solving the ordinary diﬀerential equation

dln Pt
dt

= α10 + α12V20eα22t

e2β13V3t e2β14V4t

using a variable-stepsize Runge-Kutta scheme[15]. The averages e2β1iVit for i = 3, 4 were

obtained from the moments (Vit)n using exVit =

∞
n=0

xn
n! (Vit)n (numerically truncated after

e2β10
2

−

P

n = 20) and iteration using

Vit = Vi0eαiit

(Vit)2 = (Vi0)2e(2αii+β2

ii)t +

(e(2αii+β2

ii)t

2βiiVi0
αii + β2
ii
β2
ii)t + n(n

eαiit) +

1
2αii + β2
−
ii
t
dt′ (Vit′)n−1 e(nαii+

(e(2αii+β2

ii)t

1) (48)

−
ii)(t−t′)
β2

n(n−1)
2

(Vit)n = (Vi0)ne(nαii+

n(n−1)
2

t

−
dt′ (Vit′)n−2 e(nαii+

n(n−1)
2

ii)(t−t′),
β2

1)βii Z

0

+

n(n

1)

−
2

Z
0

for

n = 3, 4, . . .

(49)

which are also readily obtained using an ODE code.

The parameters were set as α10 = .0279, α12 = .7281, α22 = 5.9997, α33 = .1227,

α44 = 8.2119, β10 = .0486, β13 = .0695, β14 = .3130, β33 = .3672, β44 = .3655, ψ13 = .1077,

ψ14 = .0564, with initial conditions P0 = 1, V20 = .1, V30 = .05, V40 = .2.

In Fig. 13 we plot the log base ten relative accuracy of ln Pt and V2t against time for

ANISE ((a) and (c), respectively) and SDE9 ((b) and (d), respectively). The dashed curve

represents an average over 105 trajectories, while the dot-dashed and solid curves represent

calculations with 106 and 107 trajectories, respectively.

In all cases convergence is good

except for ln Pt in the vicinity of zero where the exact solution vanishes and the relative

accuracy becomes poorly deﬁned.

Figure 14 plots the error in V3t and var(V3t) for ANISE and SDE9. Good convergence is

observed in all cases. Errors in the mean are greater than those in the variance.

The cpu times for various numbers of trajectories are given in Table XIV. ANISE takes

7.5 s to compute 1000 trajectories. Once again ANISE is about twice as fast as SDE9.

23

 0

-1

-2

-3

-4

-5

 0

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

 0

 0.02

 0.04

 0.06

 0.08

 0.1

 0.02

 0.04

 0.06

 0.08

 0.1

’LL2VmnlnP_e5.a’
’LL2VmnlnP_e6.a’
’LL2VmnlnP_e7.a’

’LL2VmnlnP_e5.s’
’LL2VmnlnP_e6.s’
’LL2VmnlnP_e7.s’

(a) ln Pt vs. t for ANISE

(b) ln Pt vs. t for SDE9

’LL2VmnU2_e5.a’
’LL2VmnU2_e6.a’
’LL2VmnU2_e7.a’

t

t

t

t

 0.02

 0.04

 0.06

 0.08

 0.1

 0.02

 0.04

 0.06

 0.08

 0.1

’LL2VmnU2_e5.s’
’LL2VmnU2_e6.s’
’LL2VmnU2_e7.s’

(c) V2t vs. t for ANISE

(d) V2t vs. t for SDE9

FIG. 13: Means of ln Pt and V2t for Log Linear model with feedback

III. ACCURACY FOR INDIVIDUAL TRAJECTORIES

Here we again request a relative accuracy of 10−12 and determine what accuracy is in

fact obtained on average for individual trajectories. While it is unlikely that results of this

high precision would be required in actual ﬁnancial applications, it is worth exploring this

issue for a few problems where exact solutions of the SODEs are known. We ﬁnd that the
calculations are not very sensitive to the requested tolerance, and accuracies of 10−12 are
sometimes achieved even when the requested tolerance is only 10−6. The calculations are

also insensitive to the stepsize.

For each realization of the observable we thus calculate an exact solution Xt and an

 0

-1

-2

-3

-4

-5

 0

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

 0

24

 0.02

 0.04

 0.06

 0.08

 0.1

 0.02

 0.04

 0.06

 0.08

 0.1

’LL2VmnU3_e5.a’
’LL2VmnU3_e6.a’
’LL2VmnU3_e7.a’

’LL2VmnU3_e5.s’
’LL2VmnU3_e6.s’
’LL2VmnU3_e7.s’

(a) V3t vs. t for ANISE

(b) V3t vs. t for SDE9

-5

 0

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

-6

 0

t

t

-5

 0

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-1.5

-2

-2.5

-3

-3.5

-4

-4.5

-5

-5.5

-6

 0

t

t

 0.02

 0.04

 0.06

 0.08

 0.1

 0.02

 0.04

 0.06

 0.08

 0.1

’LL2VvarU3_e5.a’
’LL2VvarU3_e6.a’
’LL2VvarU3_e7.a’

’LL2VvarU3_e5.s’
’LL2VvarU3_e6.s’
’LL2VvarU3_e7.s’

(c) var(V3t) vs. t for ANISE

(d) var(V3t) vs. t for SDE9

FIG. 14: Error in mean and variance of V3t for Log Linear model with feedback

approximate solution X approx.

t

from which we compute the log base ten relative error

Xt

log10[

|
max

−
Xt

X approx.
,

t
|
X approx.

t

].

(50)

|
We plot the average of this quantity against time t for each model. The exact solutions

|}

{|

|

involve some diﬃcult integrals which are also computed using the numerical method, so our

tests are essentially self-consistency checks.

For both models we have requested large time steps and integrated to very long times

in order to make the calculation somewhat challenging. The errors shown are computed as

time averages over short intervals since there are high frequency ﬂuctuations in the data

which make identiﬁcation of the line types in the ﬁgures diﬃcult.

25

# Trajectories

ANISE CPU Time

SDE9 CPU Time

CPU Time Ratio SDE9/ANISE

103

104

105

106

107

0.74E+01

0.75E+02

0.74E+03

0.75E+04

0.75E+05

0.15E+02

0.15E+03

0.16E+04

0.15E+05

0.15E+06

2.04

2.06

2.08

2.08

2.08

TABLE XIV: CPU times for Log Linear model with feedback in seconds.

A. Vasicek interest rate model

The SODE for this model is

dVt = c(µ

Vt)dt + σdWt,

which has the solution

Vt = V0e−ct + µ(1

e−ct) + σe−ct

ecsdWs.

t

Z

0

The derivatives needed by the numerical methods are given in Table XV.

(51)

(52)

Model

Vasicek

CEV

κ(θ

∂Vt
∂t

c(µ

Vt)

−
Vt)

−

−

1
2 α2Vt

∂Vt
∂Wt

σ

αVt

TABLE XV: equation array for Vasicek and CEV Models

We set the parameters to c = .05, µ = .09, σ = .03, and V0 = .08. We set the time step

to dt = 2.4 and integrated to 12000. This is of course a very long dynamics. We plot the

average relative error in Fig. 15 (a) for ANISE (solid curve) and SDE9 (dot-dashed curve).

Both ANISE and SDE9 return results consistent with the requested tolerance. SDE9 returns

a greater relative tolerance than that requested.

The cpu times are compared in Table XVI. Here we see that SDE9 also runs somewhat

faster than ANISE for this problem.

−

−

26

Model

ANISE

SDE9

Ratio SDE9/ANISE

Vasicek

.79E+05

.57E+05

CEV

.37E+05

.65E+05

0.72

1.75

TABLE XVI: CPU times for tol = 10−12 and 1 million trajectories.

B. Mean-reverting CEV model

Here the SODE is of the form[3]

dVt = κ(θ

Vt)dt + αVtdWt

−

(53)

which has the exact solution

Vt = exp

(κ +

α2)t + αWt

[V0 + κθ

ds exp

(κ +

α2)s

}

t

Z

0

1
2

{

1
2

{−

αWs

].

}

−

(54)

The derivatives needed by the numerical methods are given in Table XV.

The parameters were chosen as κ = .05, θ = .09, α = .1, and V0 = .08. We set the time

step to dt = 5 and integrated to 10000. The average relative error is plotted in Fig. 15

(b) for ANISE (solid curve) and SDE9 (dot-dashed curve). Both ANISE and SDE9 return

results consistent with the requested tolerance. Once again SDE9 returns a better relative

Table XVI contains the cpu times for the two methods. SDE9 takes 75 % longer than

tolerance than that requested.

ANISE.

IV. CONCLUSIONS

Good convergence is obtainable using both ANISE and SDE9 for all the problems con-

sidered. In most cases ANISE runs roughly twice as fast. For the Vasicek model in section

III SDE9 performed 40 % faster than ANISE. ANISE performed several hundreds of times

faster than SDE9 for the Aﬃne model in section II.

In addition to our study of convergence, we examined the accuracy of individual tra-

jectories for a given requested relative accuracy. We found that both methods returned

trajectories with relative accuracies consistent with the accuracy requested, even for very

long integration times.

27

-11

-11.5

-12

-12.5

-13

-13.5

-14

-14.5

-15

 0

-12.2

-12.4

-12.6

-12.8

-13

-13.2

-13.4

-13.6

-13.8

-14

-14.2

-14.4

 2000

 4000

 8000

 10000

 12000

 0

 1000

 2000

 3000

 4000

 5000

 6000

 7000

 8000

 9000

 10000

’F2_ave.a’
’F2_ave.s’

 6000

t

’F3_ave.s’
’F3_ave.a’

t

(a) ANISE (solid) and SDE9 (dot-dashed)

(b) ANISE (solid) and SDE9 (dot-dashed)

for Vasicek.

for CEV.

FIG. 15: Average error in volatility Vt for individual trajectories.

Both algorithms appear to be suﬃciently accurate for the models considered. ANISE

performed better overall. The two methods appear capable of handling larger systems of

equations with more Wiener processes, and could therefore prove to be valuable computa-

tional tools for further research in ﬁnance.

ACKNOWLEDGMENTS

of Canada.

J.W. acknowledges the support of the Natural Sciences and Engineering Research Council

[1] Pearson N.D.and Sun T.-S. 1994 Exploiting the conditional density in estimating the term

structure: an application to the Cox, Ingersoll, and Ross model J. Finance 49, 1279-1304

[2] Cox J.C., Ingersoll J.E. and Ross S.A. 1985 An intertemporal general equilibrium model of

asset prices Econometrica 53, 363-384

[3] Cox J.C., Ingersoll J.E. and Ross S.A. 1985 A theory of the term structure of interest rates

[4] Davis, M.H.A. 2004 Complete-market models of stochastic volatility, Proc. Roy. Soc. Lond.

Econometrica 53, 385-407

A 460, 11-26

28

[5] Hull J. and White A. 1987 The pricing of options with stochastic volatilities J. Finance 42,

281-300

[6] Hull J. and White A. 1988 An analysis of the bias in option pricing caused by a stochastic

volatility Adv. Futures Opt. Res. 3, 29-61

[7] Scott, L. 1987 Option pricing when the variance changes randomly: theory, estimation and

an application J. Financial and Quantitative Analysis 22, 419-438

[8] Nelson D.B. 1990 ARCH models as diﬀusion approximations J. Econometrics 45, 7-38

[9] Anderson T.G. and Bollerslev T. 1998 Answering the Sceptics: yes, standard volatility models

do provide accurate forcasts International Economic Review 39, 885-905

[10] Hobson D.G. and Rogers L.C.G. 1998 Complete models with stochastic volatility Mathematical

Finance 8, 27-48

[11] Duﬃe D. Kan R. 1996 A yield-factor model of interest rates Mathematical Finance 6, 379-406

[12] Chernov M., Gallant A.R., Ghysels E. and Tauchen G. 2003 Alternative models for stock price

dynamics J. Econometrics 116, 225-257

[13] Engle R.F. 1982 Autoregressive conditional heteroscedasticity with estimates of the variance

of United Kingdom inﬂation Econometrica 50, 987-1007

[14] Kloeden P.E. and Platen E. 1992 Numerical Solution of Stochastic Diﬀerential Equations

[15] Hairer E., Norsett S.P. and Wanner G. 1993 Solving Ordinary Diﬀerential Equations (Berlin:

(Berlin: Springer)

Springer-Verlag)

[16] See http://www.math.uni-frankfurt.de/

numerik/maplestoch/

∼

[17] Gaines J.G. 1997 Variable step size control in the numerical solution of stochastic diﬀerential

equations SIAM J. Appl. Math. 57, 1455-1484

[18] Lamba H. 2003 An adaptive timestepping algorithm for stochastic diﬀerential equations J.

Comput. Appl. Math. 161, 417-430

[19] Wilkie J. 2004 Numerical methods for stochastic diﬀerential equations Phys. Rev. E 70, 017701

[20] Wilkie J. and C¸ etinba¸s M. 2005 Variable-stepsize Runge-Kutta methods for stochastic

Schr¨odinger equations Phys. Lett. A 337, 166-182

[21] ANISE c

(cid:13) (available as a free trial), from Innovative Stochastic Algorithms

[22] Vasicek, O. 1977 An equilibrium characterization of the term structure J. Financial Economics

5, 177-188

29

